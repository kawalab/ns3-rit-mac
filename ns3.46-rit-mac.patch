From 47c64f53b3ae9d8e546d1e508b0ef829e081c0d9 Mon Sep 17 00:00:00 2001
From: tomoya0528 <c1039548@planet.kanazawa-it.ac.jp>
Date: Fri, 19 Dec 2025 11:11:30 +0900
Subject: [PATCH] rit-mac-change

---
 .../doc/{figures => }/802-15-4-ber.eps        |    0
 .../doc/{figures => }/802-15-4-per-sens.eps   |    0
 .../{figures => }/802-15-4-psr-distance.eps   |    0
 .../doc/{figures => }/lr-wpan-arch.dia        |  Bin
 .../{figures => }/lr-wpan-assocSequence.dia   |  Bin
 .../{figures => }/lr-wpan-data-example.dia    |  Bin
 src/lr-wpan/doc/{figures => }/lr-wpan-phy.dia |  Bin
 .../doc/{figures => }/lr-wpan-primitives.dia  |  Bin
 src/lr-wpan/doc/lr-wpan.rst                   |    6 +-
 src/lr-wpan/model/lr-wpan-mac-base.h          |   21 +
 src/lr-wpan/model/lr-wpan-mac-header.cc       |    8 +
 src/lr-wpan/model/lr-wpan-mac-header.h        |   18 +-
 src/lr-wpan/model/lr-wpan-mac-pl-headers.cc   |   93 +
 src/lr-wpan/model/lr-wpan-mac-pl-headers.h    |   43 +
 src/lr-wpan/model/lr-wpan-mac.cc              |  427 ++--
 src/lr-wpan/model/lr-wpan-mac.h               |  253 +--
 src/lr-wpan/model/lr-wpan-phy.cc              |  111 +-
 src/lr-wpan/model/lr-wpan-phy.h               |    4 +
 src/rit-wpan/CMakeLists.txt                   |   38 +
 src/rit-wpan/application/periodic-sender.cc   |  234 ++
 src/rit-wpan/application/periodic-sender.h    |  116 +
 src/rit-wpan/application/random-sender.cc     |  271 +++
 src/rit-wpan/application/random-sender.h      |  133 ++
 src/rit-wpan/examples/rit-grid-converge.cc    |  488 +++++
 src/rit-wpan/examples/rit-wpan-data.cc        |  147 ++
 src/rit-wpan/helper/periodic-sender-helper.cc |  119 +
 src/rit-wpan/helper/periodic-sender-helper.h  |   72 +
 src/rit-wpan/helper/random-sender-helper.cc   |  127 ++
 src/rit-wpan/helper/random-sender-helper.h    |   76 +
 src/rit-wpan/helper/rit-rank-helper.cc        |  141 ++
 src/rit-wpan/helper/rit-rank-helper.h         |   58 +
 src/rit-wpan/helper/rit-wpan-helper.cc        | 1142 ++++++++++
 src/rit-wpan/helper/rit-wpan-helper.h         |  231 ++
 src/rit-wpan/model/clock-drift-applier.cc     |   91 +
 src/rit-wpan/model/clock-drift-applier.h      |   67 +
 src/rit-wpan/model/rit-sub-header.cc          |  114 +
 src/rit-wpan/model/rit-sub-header.h           |   75 +
 src/rit-wpan/model/rit-wpan-mac.cc            | 1923 +++++++++++++++++
 src/rit-wpan/model/rit-wpan-mac.h             |  393 ++++
 src/rit-wpan/model/rit-wpan-net-device.cc     |  465 ++++
 src/rit-wpan/model/rit-wpan-net-device.h      |  154 ++
 src/rit-wpan/model/rit-wpan-nwk-header.cc     |  149 ++
 src/rit-wpan/model/rit-wpan-nwk-header.h      |   68 +
 src/rit-wpan/model/rit-wpan-nwk.cc            |  366 ++++
 src/rit-wpan/model/rit-wpan-nwk.h             |  182 ++
 src/rit-wpan/model/rit-wpan-precs.cc          |  166 ++
 src/rit-wpan/model/rit-wpan-precs.h           |  155 ++
 src/rit-wpan/model/time-drift-applier.cc      |   63 +
 src/rit-wpan/model/time-drift-applier.h       |   37 +
 src/rit-wpan/test/periodic-sender-test.cc     |  159 ++
 src/rit-wpan/test/rit-wpan-trx-test.cc        |  160 ++
 51 files changed, 8816 insertions(+), 348 deletions(-)
 rename src/lr-wpan/doc/{figures => }/802-15-4-ber.eps (100%)
 rename src/lr-wpan/doc/{figures => }/802-15-4-per-sens.eps (100%)
 rename src/lr-wpan/doc/{figures => }/802-15-4-psr-distance.eps (100%)
 rename src/lr-wpan/doc/{figures => }/lr-wpan-arch.dia (100%)
 rename src/lr-wpan/doc/{figures => }/lr-wpan-assocSequence.dia (100%)
 rename src/lr-wpan/doc/{figures => }/lr-wpan-data-example.dia (100%)
 rename src/lr-wpan/doc/{figures => }/lr-wpan-phy.dia (100%)
 rename src/lr-wpan/doc/{figures => }/lr-wpan-primitives.dia (100%)
 create mode 100644 src/rit-wpan/CMakeLists.txt
 create mode 100644 src/rit-wpan/application/periodic-sender.cc
 create mode 100644 src/rit-wpan/application/periodic-sender.h
 create mode 100644 src/rit-wpan/application/random-sender.cc
 create mode 100644 src/rit-wpan/application/random-sender.h
 create mode 100644 src/rit-wpan/examples/rit-grid-converge.cc
 create mode 100644 src/rit-wpan/examples/rit-wpan-data.cc
 create mode 100644 src/rit-wpan/helper/periodic-sender-helper.cc
 create mode 100644 src/rit-wpan/helper/periodic-sender-helper.h
 create mode 100644 src/rit-wpan/helper/random-sender-helper.cc
 create mode 100644 src/rit-wpan/helper/random-sender-helper.h
 create mode 100644 src/rit-wpan/helper/rit-rank-helper.cc
 create mode 100644 src/rit-wpan/helper/rit-rank-helper.h
 create mode 100644 src/rit-wpan/helper/rit-wpan-helper.cc
 create mode 100644 src/rit-wpan/helper/rit-wpan-helper.h
 create mode 100644 src/rit-wpan/model/clock-drift-applier.cc
 create mode 100644 src/rit-wpan/model/clock-drift-applier.h
 create mode 100644 src/rit-wpan/model/rit-sub-header.cc
 create mode 100644 src/rit-wpan/model/rit-sub-header.h
 create mode 100644 src/rit-wpan/model/rit-wpan-mac.cc
 create mode 100644 src/rit-wpan/model/rit-wpan-mac.h
 create mode 100644 src/rit-wpan/model/rit-wpan-net-device.cc
 create mode 100644 src/rit-wpan/model/rit-wpan-net-device.h
 create mode 100644 src/rit-wpan/model/rit-wpan-nwk-header.cc
 create mode 100644 src/rit-wpan/model/rit-wpan-nwk-header.h
 create mode 100644 src/rit-wpan/model/rit-wpan-nwk.cc
 create mode 100644 src/rit-wpan/model/rit-wpan-nwk.h
 create mode 100644 src/rit-wpan/model/rit-wpan-precs.cc
 create mode 100644 src/rit-wpan/model/rit-wpan-precs.h
 create mode 100644 src/rit-wpan/model/time-drift-applier.cc
 create mode 100644 src/rit-wpan/model/time-drift-applier.h
 create mode 100644 src/rit-wpan/test/periodic-sender-test.cc
 create mode 100644 src/rit-wpan/test/rit-wpan-trx-test.cc

diff --git a/src/lr-wpan/doc/figures/802-15-4-ber.eps b/src/lr-wpan/doc/802-15-4-ber.eps
similarity index 100%
rename from src/lr-wpan/doc/figures/802-15-4-ber.eps
rename to src/lr-wpan/doc/802-15-4-ber.eps
diff --git a/src/lr-wpan/doc/figures/802-15-4-per-sens.eps b/src/lr-wpan/doc/802-15-4-per-sens.eps
similarity index 100%
rename from src/lr-wpan/doc/figures/802-15-4-per-sens.eps
rename to src/lr-wpan/doc/802-15-4-per-sens.eps
diff --git a/src/lr-wpan/doc/figures/802-15-4-psr-distance.eps b/src/lr-wpan/doc/802-15-4-psr-distance.eps
similarity index 100%
rename from src/lr-wpan/doc/figures/802-15-4-psr-distance.eps
rename to src/lr-wpan/doc/802-15-4-psr-distance.eps
diff --git a/src/lr-wpan/doc/figures/lr-wpan-arch.dia b/src/lr-wpan/doc/lr-wpan-arch.dia
similarity index 100%
rename from src/lr-wpan/doc/figures/lr-wpan-arch.dia
rename to src/lr-wpan/doc/lr-wpan-arch.dia
diff --git a/src/lr-wpan/doc/figures/lr-wpan-assocSequence.dia b/src/lr-wpan/doc/lr-wpan-assocSequence.dia
similarity index 100%
rename from src/lr-wpan/doc/figures/lr-wpan-assocSequence.dia
rename to src/lr-wpan/doc/lr-wpan-assocSequence.dia
diff --git a/src/lr-wpan/doc/figures/lr-wpan-data-example.dia b/src/lr-wpan/doc/lr-wpan-data-example.dia
similarity index 100%
rename from src/lr-wpan/doc/figures/lr-wpan-data-example.dia
rename to src/lr-wpan/doc/lr-wpan-data-example.dia
diff --git a/src/lr-wpan/doc/figures/lr-wpan-phy.dia b/src/lr-wpan/doc/lr-wpan-phy.dia
similarity index 100%
rename from src/lr-wpan/doc/figures/lr-wpan-phy.dia
rename to src/lr-wpan/doc/lr-wpan-phy.dia
diff --git a/src/lr-wpan/doc/figures/lr-wpan-primitives.dia b/src/lr-wpan/doc/lr-wpan-primitives.dia
similarity index 100%
rename from src/lr-wpan/doc/figures/lr-wpan-primitives.dia
rename to src/lr-wpan/doc/lr-wpan-primitives.dia
diff --git a/src/lr-wpan/doc/lr-wpan.rst b/src/lr-wpan/doc/lr-wpan.rst
index e271334..7419a02 100644
--- a/src/lr-wpan/doc/lr-wpan.rst
+++ b/src/lr-wpan/doc/lr-wpan.rst
@@ -1,10 +1,10 @@
+.. include:: replace.txt
+.. highlight:: cpp
+.. highlight:: bash
 
 IEEE 802.15.4: Low-Rate Wireless Personal Area Network (LR-WPAN)
 ================================================================
 
-.. include:: replace.txt
-.. highlight:: cpp
-
 This chapter describes the implementation of |ns3| models for the
 low-rate, wireless personal area network (LR-WPAN) as specified by
 IEEE standard 802.15.4 (2003,2006,2011). The current emphasis is on direct transmissions running on both,
diff --git a/src/lr-wpan/model/lr-wpan-mac-base.h b/src/lr-wpan/model/lr-wpan-mac-base.h
index e20b40e..049828f 100644
--- a/src/lr-wpan/model/lr-wpan-mac-base.h
+++ b/src/lr-wpan/model/lr-wpan-mac-base.h
@@ -289,6 +289,16 @@ enum MacPibAttributeIdentifier
     macResponseWaitTime = 0x5a, //!< The maximum time in multiples of aBaseSuperframeDuration, a
                                 //!< device shall wait for a response command frame to be
                                 //!< available following a request command frame.
+
+    macRitPeriod = 0xF1,           //!< Rit period attribute identifier (temporary ID)
+    macRitDataWaitDuration = 0xF2, //!< Data reception waiting time after RIT Data Request
+    macRitTxWaitDuration = 0xF3,   //!< Beacon reception waiting time in RIT transmitter mode
+    macRitRequestPayload = 0xF4,   //!< RIT Data Request payload
+
+    macRitPeriodTime = 0xF5,           //!< RIT period time in seconds
+    macRitDataWaitDurationTime = 0xF6, //!< RIT data wait duration time in seconds
+    macRitTxWaitDurationTime = 0xF7,   //!< RIT transmission wait duration time in seconds
+
     unsupported = 255
     // TODO: complete other MAC pib attributes
 };
@@ -312,6 +322,17 @@ struct MacPibAttributes : public SimpleRefCount<MacPibAttributes>
                                     //!<  (Receive all mode).
     uint8_t pCurrentChannel{11};    //!< The current logical channel in used in the PHY
     uint8_t pCurrentPage{0};        //!< The current logical page in use in the PHY
+
+    // RIT specific attributes
+    uint32_t macRitPeriod{0};          //!< RIT interval (0x000000 ~ 0xFFFFFF)
+    uint8_t macRitDataWaitDuration{0}; //!< Reception waiting time after RIT (0x00 ~ 0xFF)
+    uint32_t macRitTxWaitDuration{
+        0}; //!< Beacon waiting time (macRitPeriod or more, up to 0xFFFFFF)
+    std::vector<uint8_t> macRitRequestPayload{}; //!< Payload for RIT command transmission
+
+    Time macRitPeriodTime{Seconds(0)};           //!< RIT period time in seconds
+    Time macRitDataWaitDurationTime{Seconds(0)}; //!< RIT data wait duration time in seconds
+    Time macRitTxWaitDurationTime{Seconds(0)};   //!< RIT transmission wait duration time in seconds
     // TODO: complete other MAC pib attributes
 };
 
diff --git a/src/lr-wpan/model/lr-wpan-mac-header.cc b/src/lr-wpan/model/lr-wpan-mac-header.cc
index a4a00aa..e15f11f 100644
--- a/src/lr-wpan/model/lr-wpan-mac-header.cc
+++ b/src/lr-wpan/model/lr-wpan-mac-header.cc
@@ -62,6 +62,8 @@ LrWpanMacHeader::GetType() const
         return LRWPAN_MAC_ACKNOWLEDGMENT;
     case 3:
         return LRWPAN_MAC_COMMAND;
+    case 5:
+        return LRWPAN_MAC_MULTIPURPOSE;
     default:
         return LRWPAN_MAC_RESERVED;
     }
@@ -252,6 +254,12 @@ LrWpanMacHeader::IsCommand() const
     return (m_fctrlFrmType == LRWPAN_MAC_COMMAND);
 }
 
+bool
+LrWpanMacHeader::IsMultipurpose() const
+{
+    return (m_fctrlFrmType == LRWPAN_MAC_MULTIPURPOSE);
+}
+
 void
 LrWpanMacHeader::SetType(LrWpanMacType wpanMacType)
 {
diff --git a/src/lr-wpan/model/lr-wpan-mac-header.h b/src/lr-wpan/model/lr-wpan-mac-header.h
index 7d5b35d..98d389a 100644
--- a/src/lr-wpan/model/lr-wpan-mac-header.h
+++ b/src/lr-wpan/model/lr-wpan-mac-header.h
@@ -51,6 +51,7 @@ class LrWpanMacHeader : public Header
         LRWPAN_MAC_DATA = 1,           //!< LRWPAN_MAC_DATA
         LRWPAN_MAC_ACKNOWLEDGMENT = 2, //!< LRWPAN_MAC_ACKNOWLEDGMENT
         LRWPAN_MAC_COMMAND = 3,        //!< LRWPAN_MAC_COMMAND
+        LRWPAN_MAC_MULTIPURPOSE = 5,   //!< LRWPAN_MAC_MULTIPURPOSE
         LRWPAN_MAC_RESERVED            //!< LRWPAN_MAC_RESERVED
     };
 
@@ -237,6 +238,11 @@ class LrWpanMacHeader : public Header
      * @return true if the header is a command
      */
     bool IsCommand() const;
+    /**
+     * Returns true if the header is a multipurpose frame
+     * @return true if the header is a multipurpose frame
+     */
+    bool IsMultipurpose() const;
     /**
      * Set the Frame Control field "Frame Type" bits
      * @param wpanMacType the frame type
@@ -393,11 +399,13 @@ class LrWpanMacHeader : public Header
                             //!< Command
     uint8_t m_fctrlSecU;    //!< Frame Control field Bit 3      = 0 - no AuxSecHdr ,  1 - security
                             //!< enabled AuxSecHdr present
-    uint8_t m_fctrlFrmPending;  //!< Frame Control field Bit 4
-    uint8_t m_fctrlAckReq;      //!< Frame Control field Bit 5
-    uint8_t m_fctrlPanIdComp;   //!< Frame Control field Bit 6      = 0 - no compression, 1 - using
-                                //!< only DstPanId for both Src and DstPanId
-    uint8_t m_fctrlReserved;    //!< Frame Control field Bit 7-9
+    uint8_t m_fctrlFrmPending; //!< Frame Control field Bit 4
+    uint8_t m_fctrlAckReq;     //!< Frame Control field Bit 5
+    uint8_t m_fctrlPanIdComp;  //!< Frame Control field Bit 6      = 0 - no compression, 1 - using
+                               //!< only DstPanId for both Src and DstPanId
+    uint8_t m_fctrlReserved;   //!< Frame Control field Bit 7-8
+    uint8_t m_presentIe; //!< Frame Control field Bit 9 - 1 if Information Elements are present in
+                         //!< the header, 0 otherwise
     uint8_t m_fctrlDstAddrMode; //!< Frame Control field Bit 10-11  = 0 - No DstAddr, 2 -
                                 //!< ShtDstAddr, 3 - ExtDstAddr
     uint8_t m_fctrlFrmVer;      //!< Frame Control field Bit 12-13
diff --git a/src/lr-wpan/model/lr-wpan-mac-pl-headers.cc b/src/lr-wpan/model/lr-wpan-mac-pl-headers.cc
index 1cf4781..1e622b2 100644
--- a/src/lr-wpan/model/lr-wpan-mac-pl-headers.cc
+++ b/src/lr-wpan/model/lr-wpan-mac-pl-headers.cc
@@ -175,6 +175,11 @@ CommandPayloadHeader::GetSerializedSize() const
     case GTS_REQ:
     case CMD_RESERVED:
         break;
+    case RIT_DATA_REQ:
+        break;
+    case RIT_DATA_RES:
+        break;
+        // size + 4; // Command ID + 0xFF header flag + 3 RIT payload bytes
     }
     return size;
 }
@@ -210,6 +215,16 @@ CommandPayloadHeader::Serialize(Buffer::Iterator start) const
     case GTS_REQ:
     case CMD_RESERVED:
         break;
+    case RIT_DATA_REQ:
+        // TODO: Support for RIT IE and RIT Payload
+        // i.WriteU8(0xFF); // Header flag indicating RIT payload
+        // i.WriteU8(m_ritTimeToFirstListen);
+        // i.WriteU8(m_ritNumRepeatListen);
+        // i.WriteU8(m_ritRepeatInterval);
+        break;
+
+    case RIT_DATA_RES:
+        break;
     }
 }
 
@@ -244,6 +259,27 @@ CommandPayloadHeader::Deserialize(Buffer::Iterator start)
     case GTS_REQ:
     case CMD_RESERVED:
         break;
+    case RIT_DATA_REQ: {
+        // TODO: Support for RIT IE and RIT Payload
+        // uint8_t headerFlag = i.ReadU8();
+        // if (headerFlag != 0xFF)
+        // {
+        //     NS_LOG_WARN("Invalid RIT payload header flag: " <<
+        //     static_cast<uint32_t>(headerFlag)); return 0;
+        // }
+        // m_ritTimeToFirstListen = i.ReadU8();
+        // if (m_ritTimeToFirstListen == 0xFF)
+        // {
+        //     NS_LOG_WARN("Invalid Time To First Listen value: 0xFF is not allowed");
+        //     return 0;
+        // }
+        // m_ritNumRepeatListen = i.ReadU8();
+        // m_ritRepeatInterval = i.ReadU8();
+        // size += 4; // Header flag + 3 RIT payload bytes
+        break;
+    case RIT_DATA_RES:
+        break;
+    }
     }
 
     return i.GetDistanceFrom(start);
@@ -285,6 +321,13 @@ CommandPayloadHeader::Print(std::ostream& os) const
     case CMD_RESERVED:
     default:
         break;
+    case RIT_DATA_REQ:
+        // TODO: Support for RIT IE and RIT Payload
+        // os << "RIT Data Request, TimeToFirstListen="
+        //    << static_cast<uint32_t>(m_ritTimeToFirstListen)
+        //    << ", NumRepeatListen=" << static_cast<uint32_t>(m_ritNumRepeatListen)
+        //    << ", RepeatInterval=" << static_cast<uint32_t>(m_ritRepeatInterval);
+        break;
     }
 }
 
@@ -352,6 +395,10 @@ CommandPayloadHeader::GetCommandFrameType() const
         return COOR_REALIGN;
     case 0x09:
         return GTS_REQ;
+    case 0x20:
+        return RIT_DATA_REQ;
+    case 0x23:
+        return RIT_DATA_RES;
     default:
         return CMD_RESERVED;
     }
@@ -419,5 +466,51 @@ CommandPayloadHeader::GetPanId() const
     return m_panid;
 }
 
+// TODO: Support for RIT IE and RIT Payload
+// Implement RIT payload getters and setters
+// void
+// CommandPayloadHeader::SetRitTimeToFirstListen(uint8_t timeToFirstListen)
+// {
+//     if (timeToFirstListen == 0xFF)
+//     {
+//         NS_LOG_WARN("Time To First Listen cannot be 0xFF, setting to 0xFE");
+//         m_ritTimeToFirstListen = 0xFE;
+//     }
+//     else
+//     {
+//         m_ritTimeToFirstListen = timeToFirstListen;
+//     }
+// }
+
+// uint8_t
+// CommandPayloadHeader::GetRitTimeToFirstListen() const
+// {
+//     return m_ritTimeToFirstListen;
+// }
+
+// void
+// CommandPayloadHeader::SetRitNumRepeatListen(uint8_t numRepeatListen)
+// {
+//     m_ritNumRepeatListen = numRepeatListen;
+// }
+
+// uint8_t
+// CommandPayloadHeader::GetRitNumRepeatListen() const
+// {
+//     return m_ritNumRepeatListen;
+// }
+
+// void
+// CommandPayloadHeader::SetRitRepeatInterval(uint8_t repeatInterval)
+// {
+//     m_ritRepeatInterval = repeatInterval;
+// }
+
+// uint8_t
+// CommandPayloadHeader::GetRitRepeatInterval() const
+// {
+//     return m_ritRepeatInterval;
+// }
+
 } // namespace lrwpan
 } // namespace ns3
diff --git a/src/lr-wpan/model/lr-wpan-mac-pl-headers.h b/src/lr-wpan/model/lr-wpan-mac-pl-headers.h
index 70c8bc5..897b4c7 100644
--- a/src/lr-wpan/model/lr-wpan-mac-pl-headers.h
+++ b/src/lr-wpan/model/lr-wpan-mac-pl-headers.h
@@ -99,6 +99,7 @@ class CommandPayloadHeader : public Header
     /**
      *  The MAC command frames.
      *  See IEEE 802.15.4-2011, Table 5
+     *  *Add* RIT Command ID, See IEEE802.15.4-2020, Table 7-53
      */
     enum MacCommand
     {
@@ -111,6 +112,8 @@ class CommandPayloadHeader : public Header
         BEACON_REQ = 0x07,           //!< Beacon Request (RFD true: none )
         COOR_REALIGN = 0x08,         //!< Coordinator Realignment (RFD true: Rx)
         GTS_REQ = 0x09,              //!< GTS Request (RFD true: none)
+        RIT_DATA_REQ = 0x20,         //!< RIT Data Request (RFD true: none)
+        RIT_DATA_RES = 0x23,         //!< RIT Data Response (RFD true: none)
         CMD_RESERVED = 0xff          //!< Reserved
     };
 
@@ -173,6 +176,41 @@ class CommandPayloadHeader : public Header
      * @param status The status resulting from the association attempt
      */
     void SetAssociationStatus(uint8_t status);
+    // /**
+    //  * Set the RIT Time To First Listen value
+    //  * \param timeToFirstListen time to first listen value (must not be 0xFF)
+    //  */
+    // void SetRitTimeToFirstListen(uint8_t timeToFirstListen);
+
+    // /**
+    //  * Get the RIT Time To First Listen value
+    //  * \return the time to first listen value
+    //  */
+    // uint8_t GetRitTimeToFirstListen() const;
+
+    // /**
+    //  * Set the RIT Number of Repeat Listen value
+    //  * \param numRepeatListen number of repeat listen value
+    //  */
+    // void SetRitNumRepeatListen(uint8_t numRepeatListen);
+
+    // /**
+    //  * Get the RIT Number of Repeat Listen value
+    //  * \return the number of repeat listen value
+    //  */
+    // uint8_t GetRitNumRepeatListen() const;
+
+    // /**
+    //  * Set the RIT Repeat Interval value
+    //  * \param repeatInterval repeat interval value
+    //  */
+    // void SetRitRepeatInterval(uint8_t repeatInterval);
+
+    // /**
+    //  * Get the RIT Repeat Interval value
+    //  * \return the repeat interval value
+    //  */
+    // uint8_t GetRitRepeatInterval() const;
     /**
      * Get the Short address assigned by the coordinator
      * (Association Response and Coordinator Realigment commands).
@@ -228,6 +266,11 @@ class CommandPayloadHeader : public Header
     uint8_t m_logCh;               //!< The channel number (Coordinator realigment command)
     uint8_t m_logChPage;           //!< The channel page number (Coordinator realigment command)
     uint8_t m_assocStatus;         //!< Association Status (Association Response Command)
+
+    // RIT payload fields
+    // uint8_t m_ritTimeToFirstListen; ///< Time To First Listen (must not be 0xFF)
+    // uint8_t m_ritNumRepeatListen;   ///< Number of Repeat Listen
+    // uint8_t m_ritRepeatInterval;    ///< Repeat Listen Interval
 };
 
 } // namespace lrwpan
diff --git a/src/lr-wpan/model/lr-wpan-mac.cc b/src/lr-wpan/model/lr-wpan-mac.cc
index 8d1079c..becbd3d 100644
--- a/src/lr-wpan/model/lr-wpan-mac.cc
+++ b/src/lr-wpan/model/lr-wpan-mac.cc
@@ -15,6 +15,7 @@
 
 #include "lr-wpan-constants.h"
 #include "lr-wpan-csmaca.h"
+#include "lr-wpan-mac-header.h"
 #include "lr-wpan-mac-pl-headers.h"
 #include "lr-wpan-mac-trailer.h"
 
@@ -1029,12 +1030,17 @@ LrWpanMac::MlmeGetRequest(MacPibAttributeIdentifier id)
 }
 
 void
-LrWpanMac::ReceiveInPromiscuousMode(uint8_t lqi,
-                                    const LrWpanMacHeader& receivedMacHdr,
-                                    Ptr<Packet> p)
+LrWpanMac::ReceiveInPromiscuousMode(uint8_t lqi, Ptr<Packet> p)
 {
     NS_LOG_FUNCTION(this);
 
+    // Strip the MAC header and MAC trailer
+    LrWpanMacTrailer receivedMacTrailer;
+    p->RemoveTrailer(receivedMacTrailer);
+
+    LrWpanMacHeader receivedMacHdr;
+    p->RemoveHeader(receivedMacHdr);
+
     NS_LOG_DEBUG("promiscuous mode, forwarding up");
 
     // TODO: Fix here, this should trigger different Indication Callbacks
@@ -1802,7 +1808,7 @@ LrWpanMac::BeaconSearchTimeout()
 }
 
 void
-LrWpanMac::ReceiveBeacon(uint8_t lqi, const LrWpanMacHeader& receivedMacHdr, Ptr<Packet> p)
+LrWpanMac::ReceiveBeacon(uint8_t lqi, Ptr<Packet> p)
 {
     NS_LOG_FUNCTION(this << lqi << p);
     // The received beacon size in symbols
@@ -1819,7 +1825,13 @@ LrWpanMac::ReceiveBeacon(uint8_t lqi, const LrWpanMacHeader& receivedMacHdr, Ptr
     NS_LOG_DEBUG("Beacon Received; forwarding up (m_macBeaconRxTime: "
                  << m_macBeaconRxTime.As(Time::S) << ")");
 
-    // Strip the Beacon Payload
+    // Strip the MAC header, the trailer and the Beacon Payload
+    LrWpanMacTrailer receivedMacTrailer;
+    p->RemoveTrailer(receivedMacTrailer);
+
+    LrWpanMacHeader receivedMacHdr;
+    p->RemoveHeader(receivedMacHdr);
+
     BeaconPayloadHeader receivedMacPayload;
     p->RemoveHeader(receivedMacPayload);
 
@@ -2000,12 +2012,18 @@ LrWpanMac::ReceiveBeacon(uint8_t lqi, const LrWpanMacHeader& receivedMacHdr, Ptr
 }
 
 void
-LrWpanMac::ReceiveCommand(uint8_t lqi, const LrWpanMacHeader& receivedMacHdr, Ptr<Packet> p)
+LrWpanMac::ReceiveCommand(uint8_t lqi, Ptr<Packet> p)
 {
     NS_LOG_FUNCTION(this << lqi << p);
 
     auto symbolRate = (uint64_t)m_phy->GetDataOrSymbolRate(false); // symbols per second
 
+    LrWpanMacTrailer receivedMacTrailer;
+    p->RemoveTrailer(receivedMacTrailer);
+
+    LrWpanMacHeader receivedMacHdr;
+    p->RemoveHeader(receivedMacHdr);
+
     CommandPayloadHeader receivedMacPayload;
     p->RemoveHeader(receivedMacPayload);
 
@@ -2077,10 +2095,16 @@ LrWpanMac::ReceiveCommand(uint8_t lqi, const LrWpanMacHeader& receivedMacHdr, Pt
 }
 
 void
-LrWpanMac::ReceiveData(uint8_t lqi, const LrWpanMacHeader& receivedMacHdr, Ptr<Packet> p)
+LrWpanMac::ReceiveData(uint8_t lqi, Ptr<Packet> p)
 {
     NS_LOG_FUNCTION(this << lqi << p);
 
+    LrWpanMacTrailer receivedMacTrailer;
+    p->RemoveTrailer(receivedMacTrailer);
+
+    LrWpanMacHeader receivedMacHdr;
+    p->RemoveHeader(receivedMacHdr);
+
     NS_LOG_DEBUG("Data Packet is for me; forwarding up");
 
     if (!m_mcpsDataIndicationCallback.IsNull())
@@ -2123,183 +2147,32 @@ LrWpanMac::ReceiveData(uint8_t lqi, const LrWpanMacHeader& receivedMacHdr, Ptr<P
 }
 
 void
-LrWpanMac::ReceiveAcknowledgment(const LrWpanMacHeader& receivedMacHdr, Ptr<Packet> p)
+LrWpanMac::PrintPacket(Ptr<Packet> p)
 {
-    NS_LOG_FUNCTION(this << p);
-
-    // Make a copy of the original transmitted packet that required ACK and
-    // extract its MAC header.
-    Ptr<Packet> txPkt = m_txPkt->Copy();
-    LrWpanMacHeader txMacHdr;
-    txPkt->RemoveHeader(txMacHdr);
-
-    // If it is an ACK with an unexpected sequence number, mark the current
-    // transmission as failed and start a retransmit. (cf 7.5.6.4.3)
-    if (receivedMacHdr.GetSeqNum() != txMacHdr.GetSeqNum())
-    {
-        m_ackWaitTimeout.Cancel();
-        if (!PrepareRetransmission())
-        {
-            m_setMacState.Cancel();
-            m_setMacState = Simulator::ScheduleNow(&LrWpanMac::SetLrWpanMacState, this, MAC_IDLE);
-        }
-        else
-        {
-            m_setMacState.Cancel();
-            m_setMacState = Simulator::ScheduleNow(&LrWpanMac::SetLrWpanMacState, this, MAC_CSMA);
-        }
-
-        return;
-    }
-
-    // If it is an ACK with the expected sequence number, finish the transmission
-    m_ackWaitTimeout.Cancel();
-    m_macTxOkTrace(m_txPkt);
-
-    // TODO: check  if the IFS is the correct size after ACK.
-    double symbolRate = m_phy->GetDataOrSymbolRate(false);
-    Time ifsWaitTime = Seconds((double)GetIfsSize() / symbolRate);
-
-    if (txMacHdr.IsCommand())
-    {
-        // We received an ACK to a command, we need to take actions depending on the
-        // transmitted command.
-
-        // Extract the command payload of the originally transmitted packet to know
-        // what command we transmitted.
-        CommandPayloadHeader txCmdPayload;
-        txPkt->RemoveHeader(txCmdPayload);
-
-        switch (txCmdPayload.GetCommandFrameType())
-        {
-        case CommandPayloadHeader::ASSOCIATION_REQ: {
-            Time waitTime = Seconds(static_cast<double>(m_macResponseWaitTime) / symbolRate);
-            if (!m_beaconTrackingOn)
-            {
-                m_respWaitTimeout =
-                    Simulator::Schedule(waitTime, &LrWpanMac::SendDataRequestCommand, this);
-            }
-            else
-            {
-                // TODO: The data must be extracted by the coordinator within
-                // macResponseWaitTime on timeout, MLME-ASSOCIATE.confirm is set
-                // with status NO_DATA, and this should trigger the cancellation
-                // of the beacon tracking (MLME-SYNC.request  trackBeacon
-                // =FALSE)
-            }
-            break;
-        }
-
-        case CommandPayloadHeader::ASSOCIATION_RESP: {
-            // MLME-comm-status.Indication generated as a result of an
-            // association response command, therefore src and dst address use
-            // extended mode (see 5.3.2.1)
-            if (!m_mlmeCommStatusIndicationCallback.IsNull())
-            {
-                MlmeCommStatusIndicationParams commStatusParams;
-                commStatusParams.m_panId = m_macPanId;
-                commStatusParams.m_srcAddrMode = LrWpanMacHeader::EXTADDR;
-                commStatusParams.m_srcExtAddr = txMacHdr.GetExtSrcAddr();
-                commStatusParams.m_dstAddrMode = LrWpanMacHeader::EXTADDR;
-                commStatusParams.m_dstExtAddr = txMacHdr.GetExtDstAddr();
-                commStatusParams.m_status = MacStatus::SUCCESS;
-                m_mlmeCommStatusIndicationCallback(commStatusParams);
-            }
-            // Remove element from Pending Transaction List
-            RemovePendTxQElement(m_txPkt->Copy());
-            break;
-        }
-
-        case CommandPayloadHeader::DATA_REQ: {
-            if (!m_ignoreDataCmdAck)
-            {
-                // Schedule an event in case the Association Response Command
-                // never reached this device during an association process.
-                Time waitTime = Seconds(static_cast<double>(m_assocRespCmdWaitTime) / symbolRate);
-                m_assocResCmdWaitTimeout =
-                    Simulator::Schedule(waitTime, &LrWpanMac::LostAssocRespCommand, this);
-            }
-
-            if (!m_mlmePollConfirmCallback.IsNull())
-            {
-                MlmePollConfirmParams pollConfirmParams;
-                pollConfirmParams.m_status = MacStatus::SUCCESS;
-                m_mlmePollConfirmCallback(pollConfirmParams);
-            }
-            break;
-        }
-
-        case CommandPayloadHeader::COOR_REALIGN: {
-            // ACK of coordinator realigment commands is not specified in the
-            // standard, in here, we assume they are required as in other
-            // commands.
-            if (!m_mlmeCommStatusIndicationCallback.IsNull())
-            {
-                MlmeCommStatusIndicationParams commStatusParams;
-                commStatusParams.m_panId = m_macPanId;
-                commStatusParams.m_srcAddrMode = LrWpanMacHeader::EXTADDR;
-                commStatusParams.m_srcExtAddr = txMacHdr.GetExtSrcAddr();
-                commStatusParams.m_dstAddrMode = LrWpanMacHeader::EXTADDR;
-                commStatusParams.m_dstExtAddr = txMacHdr.GetExtDstAddr();
-                commStatusParams.m_status = MacStatus::SUCCESS;
-                m_mlmeCommStatusIndicationCallback(commStatusParams);
-            }
-            break;
-        }
-
-        default: {
-            // TODO: add response to other request commands (e.g. Orphan)
-            break;
-        }
-        }
-    }
-    else
-    {
-        // Receive ACK to data packet
-        if (!m_mcpsDataConfirmCallback.IsNull())
-        {
-            Ptr<TxQueueElement> txQElement = m_txQueue.front();
-            McpsDataConfirmParams confirmParams;
-            confirmParams.m_msduHandle = txQElement->txQMsduHandle;
-            confirmParams.m_status = MacStatus::SUCCESS;
-            m_mcpsDataConfirmCallback(confirmParams);
-        }
-    }
-
-    // Ack was successfully received, wait for the Interframe Space (IFS) and
-    // then proceed
-    RemoveFirstTxQElement();
-    m_setMacState.Cancel();
-    m_setMacState = Simulator::ScheduleNow(&LrWpanMac::SetLrWpanMacState, this, MAC_IDLE);
-    m_ifsEvent = Simulator::Schedule(ifsWaitTime, &LrWpanMac::IfsWaitTimeout, this, ifsWaitTime);
-}
+    LrWpanMacHeader peekedMacHdr;
+    p->PeekHeader(peekedMacHdr);
 
-void
-LrWpanMac::PrintReceivedPacket(const LrWpanMacHeader& receivedMacHdr)
-{
-    if (receivedMacHdr.GetSrcAddrMode() == SHORT_ADDR &&
-        receivedMacHdr.GetDstAddrMode() == SHORT_ADDR)
+    if (peekedMacHdr.GetSrcAddrMode() == SHORT_ADDR && peekedMacHdr.GetDstAddrMode() == SHORT_ADDR)
     {
-        NS_LOG_DEBUG("Packet from [" << receivedMacHdr.GetShortSrcAddr() << "] to ["
-                                     << receivedMacHdr.GetShortDstAddr() << "]");
+        NS_LOG_DEBUG("Packet from [" << peekedMacHdr.GetShortSrcAddr() << "] to ["
+                                     << peekedMacHdr.GetShortDstAddr() << "]");
     }
-    else if (receivedMacHdr.GetSrcAddrMode() == EXT_ADDR &&
-             receivedMacHdr.GetDstAddrMode() == EXT_ADDR)
+    else if (peekedMacHdr.GetSrcAddrMode() == EXT_ADDR && peekedMacHdr.GetDstAddrMode() == EXT_ADDR)
     {
-        NS_LOG_DEBUG("Packet from [" << receivedMacHdr.GetExtSrcAddr() << "] to ["
-                                     << receivedMacHdr.GetExtDstAddr() << "]");
+        NS_LOG_DEBUG("Packet from [" << peekedMacHdr.GetExtSrcAddr() << "] to ["
+                                     << peekedMacHdr.GetExtDstAddr() << "]");
     }
-    else if (receivedMacHdr.GetSrcAddrMode() == SHORT_ADDR &&
-             receivedMacHdr.GetDstAddrMode() == EXT_ADDR)
+    else if (peekedMacHdr.GetSrcAddrMode() == SHORT_ADDR &&
+             peekedMacHdr.GetDstAddrMode() == EXT_ADDR)
     {
-        NS_LOG_DEBUG("Packet from [" << receivedMacHdr.GetShortSrcAddr() << "] to ["
-                                     << receivedMacHdr.GetExtDstAddr() << "]");
+        NS_LOG_DEBUG("Packet from [" << peekedMacHdr.GetShortSrcAddr() << "] to ["
+                                     << peekedMacHdr.GetExtDstAddr() << "]");
     }
-    else if (receivedMacHdr.GetSrcAddrMode() == EXT_ADDR &&
-             receivedMacHdr.GetDstAddrMode() == SHORT_ADDR)
+    else if (peekedMacHdr.GetSrcAddrMode() == EXT_ADDR &&
+             peekedMacHdr.GetDstAddrMode() == SHORT_ADDR)
     {
-        NS_LOG_DEBUG("Packet from [" << receivedMacHdr.GetExtSrcAddr() << "] to ["
-                                     << receivedMacHdr.GetShortDstAddr() << "]");
+        NS_LOG_DEBUG("Packet from [" << peekedMacHdr.GetExtSrcAddr() << "] to ["
+                                     << peekedMacHdr.GetShortDstAddr() << "]");
     }
 }
 
@@ -2322,8 +2195,22 @@ LrWpanMac::CheckQueue()
                 m_setMacState =
                     Simulator::ScheduleNow(&LrWpanMac::SetLrWpanMacState, this, MAC_CSMA);
             }
+            else
+            {
+                NS_LOG_DEBUG(this << " Cannot check queue, MAC is in IFS");
+            }
+        }
+        else
+        {
+            NS_LOG_ERROR(this << " Cannot check queue, MAC state is " << m_macState
+                              << " or not in CSMA-CA mode");
         }
     }
+    else
+    {
+        NS_LOG_ERROR(this << " Cannot check queue, MAC state is " << m_macState
+                          << " or no packets in the queue");
+    }
 }
 
 uint16_t
@@ -2397,31 +2284,26 @@ LrWpanMac::PdDataIndication(uint32_t psduLength, Ptr<Packet> p, uint8_t lqi)
     NS_ASSERT(m_macState == MAC_IDLE || m_macState == MAC_ACK_PENDING || m_macState == MAC_CSMA);
     NS_LOG_FUNCTION(this << psduLength << p << (uint16_t)lqi);
 
-    Ptr<Packet> originalPkt = p->Copy();
+    bool acceptFrame;
 
-    // If active, pass the complete packet to the traces
-    if (!m_promiscSnifferTrace.IsEmpty())
-    {
-        m_promiscSnifferTrace(p->Copy());
-    }
-    else if (!m_macPromiscRxTrace.IsEmpty())
-    {
-        m_macPromiscRxTrace(p->Copy());
-    }
+    Ptr<Packet> originalPkt = p->Copy();                           // because we will strip headers
+    auto symbolRate = (uint64_t)m_phy->GetDataOrSymbolRate(false); // symbols per second
+
+    m_promiscSnifferTrace(originalPkt);
+    m_macPromiscRxTrace(originalPkt);
+    // XXX no rejection tracing (to macRxDropTrace) being performed below
 
-    // Extract the MAC trailer
     LrWpanMacTrailer receivedMacTrailer;
     p->RemoveTrailer(receivedMacTrailer);
 
-    // Extract the MAC Header from the packet
-    LrWpanMacHeader receivedMacHdr;
-    p->RemoveHeader(receivedMacHdr);
-
     if (Node::ChecksumEnabled())
     {
         receivedMacTrailer.EnableFcs(true);
     }
 
+    LrWpanMacHeader receivedMacHdr;
+    p->RemoveHeader(receivedMacHdr);
+
     // From section 7.5.6.2 Reception and rejection, IEEE 802.15.4-2006
     // - Level 1 filtering: Test FCS field and reject if frame fails.
     // - Level 2 filtering: If promiscuous mode pass frame to higher layer
@@ -2442,13 +2324,12 @@ LrWpanMac::PdDataIndication(uint32_t psduLength, Ptr<Packet> p, uint8_t lqi)
     // Level 2 filtering
     if (m_macPromiscuousMode)
     {
-        PrintReceivedPacket(receivedMacHdr);
-        ReceiveInPromiscuousMode(lqi, receivedMacHdr, p);
+        PrintPacket(originalPkt);
+        ReceiveInPromiscuousMode(lqi, originalPkt);
         return;
     }
 
     // Level 3 frame filtering
-    bool acceptFrame;
     acceptFrame = (receivedMacHdr.GetType() != LrWpanMacHeader::LRWPAN_MAC_RESERVED);
 
     if (acceptFrame)
@@ -2535,7 +2416,6 @@ LrWpanMac::PdDataIndication(uint32_t psduLength, Ptr<Packet> p, uint8_t lqi)
             Time timeLeftInCap = Simulator::GetDelayLeft(m_capEvent);
             uint64_t ackSymbols = lrwpan::aTurnaroundTime + m_phy->GetPhySHRDuration() +
                                   ceil(6 * m_phy->GetPhySymbolsPerOctet());
-            auto symbolRate = m_phy->GetDataOrSymbolRate(false); // symbols per second
             Time ackTime = Seconds((double)ackSymbols / symbolRate);
 
             if (ackTime >= timeLeftInCap)
@@ -2591,7 +2471,7 @@ LrWpanMac::PdDataIndication(uint32_t psduLength, Ptr<Packet> p, uint8_t lqi)
 
         // save received packet and LQI to process the appropriate indication/response
         // after sending ACK (PD-DATA.confirm)
-        m_rxPkt = originalPkt;
+        m_rxPkt = originalPkt->Copy();
         m_lastRxFrameLqi = lqi;
 
         // LOG Commands with ACK required.
@@ -2634,23 +2514,168 @@ LrWpanMac::PdDataIndication(uint32_t psduLength, Ptr<Packet> p, uint8_t lqi)
             Simulator::ScheduleNow(&LrWpanMac::SendAck, this, receivedMacHdr.GetSeqNum());
     }
 
-    PrintReceivedPacket(receivedMacHdr);
+    PrintPacket(originalPkt);
 
     if (receivedMacHdr.IsBeacon())
     {
-        ReceiveBeacon(lqi, receivedMacHdr, p);
+        ReceiveBeacon(lqi, originalPkt);
     }
     else if (receivedMacHdr.IsCommand())
     {
-        ReceiveCommand(lqi, receivedMacHdr, p);
+        ReceiveCommand(lqi, originalPkt);
     }
     else if (receivedMacHdr.IsData())
     {
-        ReceiveData(lqi, receivedMacHdr, p);
+        ReceiveData(lqi, originalPkt);
     }
     else if (receivedMacHdr.IsAcknowledgment() && m_txPkt && m_macState == MAC_ACK_PENDING)
     {
-        ReceiveAcknowledgment(receivedMacHdr, p);
+        LrWpanMacHeader peekedMacHdr;
+        m_txPkt->PeekHeader(peekedMacHdr);
+        // If it is an ACK with the expected sequence number, finish the transmission
+        if (receivedMacHdr.GetSeqNum() == peekedMacHdr.GetSeqNum())
+        {
+            m_ackWaitTimeout.Cancel();
+            m_macTxOkTrace(m_txPkt);
+
+            // TODO: check  if the IFS is the correct size after ACK.
+            Time ifsWaitTime = Seconds((double)GetIfsSize() / symbolRate);
+
+            // We received an ACK to a command
+            if (peekedMacHdr.IsCommand())
+            {
+                // check the original sent command frame which belongs to this received
+                // ACK
+                Ptr<Packet> pkt = m_txPkt->Copy();
+                LrWpanMacHeader macHdr;
+                CommandPayloadHeader cmdPayload;
+                pkt->RemoveHeader(macHdr);
+                pkt->RemoveHeader(cmdPayload);
+
+                switch (cmdPayload.GetCommandFrameType())
+                {
+                case CommandPayloadHeader::ASSOCIATION_REQ: {
+                    double symbolRate = m_phy->GetDataOrSymbolRate(false);
+                    Time waitTime =
+                        Seconds(static_cast<double>(m_macResponseWaitTime) / symbolRate);
+                    if (!m_beaconTrackingOn)
+                    {
+                        m_respWaitTimeout =
+                            Simulator::Schedule(waitTime, &LrWpanMac::SendDataRequestCommand, this);
+                    }
+                    else
+                    {
+                        // TODO: The data must be extracted by the coordinator within
+                        // macResponseWaitTime on timeout, MLME-ASSOCIATE.confirm is set
+                        // with status NO_DATA, and this should trigger the cancellation
+                        // of the beacon tracking (MLME-SYNC.request  trackBeacon
+                        // =FALSE)
+                    }
+                    break;
+                }
+
+                case CommandPayloadHeader::ASSOCIATION_RESP: {
+                    // MLME-comm-status.Indication generated as a result of an
+                    // association response command, therefore src and dst address use
+                    // extended mode (see 5.3.2.1)
+                    if (!m_mlmeCommStatusIndicationCallback.IsNull())
+                    {
+                        MlmeCommStatusIndicationParams commStatusParams;
+                        commStatusParams.m_panId = m_macPanId;
+                        commStatusParams.m_srcAddrMode = LrWpanMacHeader::EXTADDR;
+                        commStatusParams.m_srcExtAddr = macHdr.GetExtSrcAddr();
+                        commStatusParams.m_dstAddrMode = LrWpanMacHeader::EXTADDR;
+                        commStatusParams.m_dstExtAddr = macHdr.GetExtDstAddr();
+                        commStatusParams.m_status = MacStatus::SUCCESS;
+                        m_mlmeCommStatusIndicationCallback(commStatusParams);
+                    }
+                    // Remove element from Pending Transaction List
+                    RemovePendTxQElement(m_txPkt->Copy());
+                    break;
+                }
+
+                case CommandPayloadHeader::DATA_REQ: {
+                    if (!m_ignoreDataCmdAck)
+                    {
+                        // Schedule an event in case the Association Response Command
+                        // never reached this device during an association process.
+                        double symbolRate = m_phy->GetDataOrSymbolRate(false);
+                        Time waitTime =
+                            Seconds(static_cast<double>(m_assocRespCmdWaitTime) / symbolRate);
+                        m_assocResCmdWaitTimeout =
+                            Simulator::Schedule(waitTime, &LrWpanMac::LostAssocRespCommand, this);
+                    }
+
+                    if (!m_mlmePollConfirmCallback.IsNull())
+                    {
+                        MlmePollConfirmParams pollConfirmParams;
+                        pollConfirmParams.m_status = MacStatus::SUCCESS;
+                        m_mlmePollConfirmCallback(pollConfirmParams);
+                    }
+                    break;
+                }
+
+                case CommandPayloadHeader::COOR_REALIGN: {
+                    // ACK of coordinator realigment commands is not specified in the
+                    // standard, in here, we assume they are required as in other
+                    // commands.
+                    if (!m_mlmeCommStatusIndicationCallback.IsNull())
+                    {
+                        MlmeCommStatusIndicationParams commStatusParams;
+                        commStatusParams.m_panId = m_macPanId;
+                        commStatusParams.m_srcAddrMode = LrWpanMacHeader::EXTADDR;
+                        commStatusParams.m_srcExtAddr = macHdr.GetExtSrcAddr();
+                        commStatusParams.m_dstAddrMode = LrWpanMacHeader::EXTADDR;
+                        commStatusParams.m_dstExtAddr = macHdr.GetExtDstAddr();
+                        commStatusParams.m_status = MacStatus::SUCCESS;
+                        m_mlmeCommStatusIndicationCallback(commStatusParams);
+                    }
+                }
+
+                default: {
+                    // TODO: add response to other request commands (e.g. Orphan)
+                    break;
+                }
+                }
+            }
+            else
+            {
+                if (!m_mcpsDataConfirmCallback.IsNull())
+                {
+                    Ptr<TxQueueElement> txQElement = m_txQueue.front();
+                    McpsDataConfirmParams confirmParams;
+                    confirmParams.m_msduHandle = txQElement->txQMsduHandle;
+                    confirmParams.m_status = MacStatus::SUCCESS;
+                    m_mcpsDataConfirmCallback(confirmParams);
+                }
+            }
+
+            // Ack was successfully received, wait for the Interframe Space (IFS) and
+            // then proceed
+            RemoveFirstTxQElement();
+            m_setMacState.Cancel();
+            m_setMacState = Simulator::ScheduleNow(&LrWpanMac::SetLrWpanMacState, this, MAC_IDLE);
+            m_ifsEvent =
+                Simulator::Schedule(ifsWaitTime, &LrWpanMac::IfsWaitTimeout, this, ifsWaitTime);
+        }
+        else
+        {
+            // If it is an ACK with an unexpected sequence number, mark the current
+            // transmission as failed and start a retransmit. (cf 7.5.6.4.3)
+            m_ackWaitTimeout.Cancel();
+            if (!PrepareRetransmission())
+            {
+                m_setMacState.Cancel();
+                m_setMacState =
+                    Simulator::ScheduleNow(&LrWpanMac::SetLrWpanMacState, this, MAC_IDLE);
+            }
+            else
+            {
+                m_setMacState.Cancel();
+                m_setMacState =
+                    Simulator::ScheduleNow(&LrWpanMac::SetLrWpanMacState, this, MAC_CSMA);
+            }
+        }
     }
 }
 
@@ -2788,7 +2813,7 @@ LrWpanMac::PrepareRetransmission()
 
         if (peekedMacHdr.IsCommand())
         {
-            m_macTxDropTrace(m_txPkt);
+            // m_macTxDropTrace(m_txPkt);
 
             Ptr<Packet> pkt = m_txPkt->Copy();
             LrWpanMacHeader macHdr;
diff --git a/src/lr-wpan/model/lr-wpan-mac.h b/src/lr-wpan/model/lr-wpan-mac.h
index 382378a..f7bf8ed 100644
--- a/src/lr-wpan/model/lr-wpan-mac.h
+++ b/src/lr-wpan/model/lr-wpan-mac.h
@@ -16,7 +16,6 @@
 
 #include "lr-wpan-fields.h"
 #include "lr-wpan-mac-base.h"
-#include "lr-wpan-mac-header.h"
 #include "lr-wpan-phy.h"
 
 #include "ns3/event-id.h"
@@ -290,7 +289,7 @@ class LrWpanMac : public LrWpanMacBase
      * @param p the packet to be transmitted
      * @param lqi Link quality (LQI) value measured during reception of the PPDU
      */
-    void PdDataIndication(uint32_t psduLength, Ptr<Packet> p, uint8_t lqi);
+    virtual void PdDataIndication(uint32_t psduLength, Ptr<Packet> p, uint8_t lqi);
 
     /**
      * IEEE 802.15.4-2006 section 6.2.1.2
@@ -298,7 +297,7 @@ class LrWpanMac : public LrWpanMacBase
      * @param status to report to MAC
      *        PHY PD-DATA.confirm status
      */
-    void PdDataConfirm(PhyEnumeration status);
+    virtual void PdDataConfirm(PhyEnumeration status);
 
     /**
      * IEEE 802.15.4-2006 section 6.2.2.2
@@ -333,7 +332,7 @@ class LrWpanMac : public LrWpanMacBase
      * Set PHY state
      * @param status in RX_ON,TRX_OFF,FORCE_TRX_OFF,TX_ON
      */
-    void PlmeSetTRXStateConfirm(PhyEnumeration status);
+    virtual void PlmeSetTRXStateConfirm(PhyEnumeration status);
 
     /**
      * IEEE 802.15.4-2006 section 6.2.2.10
@@ -349,7 +348,7 @@ class LrWpanMac : public LrWpanMacBase
      *
      * @param macState indicate BUSY or IDLE channel condition
      */
-    void SetLrWpanMacState(MacState macState);
+    virtual void SetLrWpanMacState(MacState macState);
 
     /**
      * Set the max size of the transmit queue.
@@ -732,12 +731,20 @@ class LrWpanMac : public LrWpanMacBase
     // NS_DEPRECATED() - tag for future removal
     typedef void (*StateTracedCallback)(MacState oldState, MacState newState);
 
+    /**
+     * Send an acknowledgment packet for the given sequence number.
+     *
+     * @param seqno the sequence number for the ACK
+     */
+    void SendAck(uint8_t seqno);
+
   protected:
     // Inherited from Object.
     void DoInitialize() override;
     void DoDispose() override;
 
-  private:
+    /** Protected method section modified for RIT */
+
     /**
      * Helper structure for managing transmission queue elements.
      */
@@ -747,6 +754,102 @@ class LrWpanMac : public LrWpanMacBase
         Ptr<Packet> txQPkt;    //!< Queued packet
     };
 
+    /**
+     * Add an element to the transmission queue.
+     *
+     * @param txQElement The element added to the Tx Queue.
+     */
+    void EnqueueTxQElement(Ptr<TxQueueElement> txQElement);
+
+    /**
+     * Remove the tip of the transmission queue, including clean up related to the
+     * last packet transmission.
+     */
+    void RemoveFirstTxQElement();
+
+    /**
+     * Used to process the reception of data.
+     *
+     * @param lqi The value of the link quality indicator (LQI) of the received packet
+     * @param p The packet containing the MAC header and the data payload.
+     */
+    void ReceiveData(uint8_t lqi, Ptr<Packet> p);
+
+    /**
+     * Handle an ACK timeout with a packet retransmission, if there are
+     * retransmission left, or a packet drop.
+     */
+    virtual void AckWaitTimeout();
+
+    /**
+     * Change the current MAC state to the given new state.
+     *
+     * @param newState the new state
+     */
+    void ChangeMacState(MacState newState);
+
+    /**
+     * The transmit queue used by the MAC.
+     */
+    std::deque<Ptr<TxQueueElement>> m_txQueue;
+
+    /**
+     * The trace source fired for packets successfully received by the device
+     * immediately before being forwarded up to higher layers (at the L2/L3
+     * transition).  This is a non-promiscuous trace.
+     *
+     * @see class CallBackTraceSource
+     */
+    TracedCallback<Ptr<const Packet>> m_macRxTrace;
+
+    /**
+     * The trace source fired for packets successfully received by the device
+     * but dropped before being forwarded up to higher layers (at the L2/L3
+     * transition).
+     *
+     * @see class CallBackTraceSource
+     */
+    TracedCallback<Ptr<const Packet>> m_macRxDropTrace;
+
+    /**
+     * The PHY associated with this MAC.
+     */
+    Ptr<LrWpanPhy> m_phy;
+
+    /**
+     * The current state of the MAC layer.
+     */
+    TracedValue<MacState> m_macState;
+
+    /**
+     * The CSMA/CA implementation used by this MAC.
+     */
+    Ptr<LrWpanCsmaCa> m_csmaCa;
+
+    /**
+     * The packet which is currently being sent by the MAC layer.
+     */
+    Ptr<Packet> m_txPkt;
+
+    /**
+     * Scheduler event for the ACK timeout of the currently transmitted data
+     * packet.
+     */
+    EventId m_ackWaitTimeout;
+
+    /**
+     * The short address (16 bit address) used by this MAC. If supported,
+     * the short address must be assigned to the device by the coordinator
+     * during the association process.
+     */
+    Mac16Address m_shortAddress;
+
+    /**
+     * The extended 64 address (IEEE EUI-64) used by this MAC.
+     */
+    Mac64Address m_macExtendedAddress;
+
+  protected:
     /**
      * Helper structure for managing pending transaction list elements (Indirect transmissions).
      */
@@ -763,12 +866,9 @@ class LrWpanMac : public LrWpanMacBase
      * Process a frame when promiscuous mode is active.
      *
      * @param lqi The LQI value of the received packet
-     * @param receivedMacHdr The reference to the received MAC header
-     * @param p The packet containing the MAC payload
+     * @param p The frame with the MPDU
      */
-    void ReceiveInPromiscuousMode(uint8_t lqi,
-                                  const LrWpanMacHeader& receivedMacHdr,
-                                  Ptr<Packet> p);
+    void ReceiveInPromiscuousMode(uint8_t lqi, Ptr<Packet> p);
 
     /**
      * Called to send a single beacon frame.
@@ -870,78 +970,26 @@ class LrWpanMac : public LrWpanMacBase
     /**
      * Used to process the reception of a beacon packet.
      *
-     * @param lqi The value of the link quality indicator (LQI) of the received packet.
-     * @param receivedMacHdr The reference to the received MAC header.
-     * @param p The packet containing the beacon payload information.
+     * @param lqi The value of the link quality indicator (LQI) of the received packet
+     * @param p The packet containing the MAC header and the beacon payload information
      */
-    void ReceiveBeacon(uint8_t lqi, const LrWpanMacHeader& receivedMacHdr, Ptr<Packet> p);
+    void ReceiveBeacon(uint8_t lqi, Ptr<Packet> p);
 
     /**
      * Used to process the reception of a command packet.
      *
-     * @param lqi The value of the link quality indicator (LQI) of the received packet.
-     * @param receivedMacHdr The reference to the received MAC header.
-     * @param p The packet containing the command payload information.
-     */
-    void ReceiveCommand(uint8_t lqi, const LrWpanMacHeader& receivedMacHdr, Ptr<Packet> p);
-
-    /**
-     * Used to process the reception of data.
-     *
-     * @param lqi The value of the link quality indicator (LQI) of the received packet.
-     * @param receivedMacHdr The reference to the received MAC header.
-     * @param p The packet containing the data payload.
+     * @param lqi The value of the link quality indicator (LQI) of the received packet
+     * @param p The packet containing the MAC header and the beacon payload information
      */
-    void ReceiveData(uint8_t lqi, const LrWpanMacHeader& receivedMacHdr, Ptr<Packet> p);
-
-    /**
-     * Used to process an acknowledgment packet.
-     *
-     * @param receivedMacHdr The reference to the received MAC header.
-     * @param p The packet containing the MAC header and the data payload.
-     */
-    void ReceiveAcknowledgment(const LrWpanMacHeader& receivedMacHdr, Ptr<Packet> p);
+    void ReceiveCommand(uint8_t lqi, Ptr<Packet> p);
 
     /**
      * Display the MAC header contents of a successfully received packet when
      * logs are active.
      *
-     * @param receivedMacHdr The reference of the received MAC header
-     */
-    void PrintReceivedPacket(const LrWpanMacHeader& receivedMacHdr);
-
-    /**
-     * Send an acknowledgment packet for the given sequence number.
-     *
-     * @param seqno the sequence number for the ACK
+     * @param p The packet containing the MAC header
      */
-    void SendAck(uint8_t seqno);
-
-    /**
-     * Add an element to the transmission queue.
-     *
-     * @param txQElement The element added to the Tx Queue.
-     */
-    void EnqueueTxQElement(Ptr<TxQueueElement> txQElement);
-
-    /**
-     * Remove the tip of the transmission queue, including clean up related to the
-     * last packet transmission.
-     */
-    void RemoveFirstTxQElement();
-
-    /**
-     * Change the current MAC state to the given new state.
-     *
-     * @param newState the new state
-     */
-    void ChangeMacState(MacState newState);
-
-    /**
-     * Handle an ACK timeout with a packet retransmission, if there are
-     * retransmission left, or a packet drop.
-     */
-    void AckWaitTimeout();
+    void PrintPacket(Ptr<Packet> p);
 
     /**
      * After a successful transmission of a frame (beacon, data) or an ack frame reception,
@@ -950,7 +998,7 @@ class LrWpanMac : public LrWpanMacBase
      *
      * @param ifsTime IFS time
      */
-    void IfsWaitTimeout(Time ifsTime);
+    virtual void IfsWaitTimeout(Time ifsTime);
 
     /**
      * Check for remaining retransmissions for the packet currently being sent.
@@ -1109,24 +1157,6 @@ class LrWpanMac : public LrWpanMacBase
      */
     TracedCallback<Ptr<const Packet>> m_macPromiscRxTrace;
 
-    /**
-     * The trace source fired for packets successfully received by the device
-     * immediately before being forwarded up to higher layers (at the L2/L3
-     * transition).  This is a non-promiscuous trace.
-     *
-     * @see class CallBackTraceSource
-     */
-    TracedCallback<Ptr<const Packet>> m_macRxTrace;
-
-    /**
-     * The trace source fired for packets successfully received by the device
-     * but dropped before being forwarded up to higher layers (at the L2/L3
-     * transition).
-     *
-     * @see class CallBackTraceSource
-     */
-    TracedCallback<Ptr<const Packet>> m_macRxDropTrace;
-
     /**
      * A trace source that emulates a non-promiscuous protocol sniffer connected
      * to the device.  Unlike your average everyday sniffer, this trace source
@@ -1178,21 +1208,6 @@ class LrWpanMac : public LrWpanMacBase
     // NS_DEPRECATED() - tag for future removal
     TracedCallback<MacState, MacState> m_macStateLogger;
 
-    /**
-     * The PHY associated with this MAC.
-     */
-    Ptr<LrWpanPhy> m_phy;
-
-    /**
-     * The CSMA/CA implementation used by this MAC.
-     */
-    Ptr<LrWpanCsmaCa> m_csmaCa;
-
-    /**
-     * The current state of the MAC layer.
-     */
-    TracedValue<MacState> m_macState;
-
     /**
      * The current period of the incoming superframe.
      */
@@ -1203,34 +1218,12 @@ class LrWpanMac : public LrWpanMacBase
      */
     TracedValue<SuperframeStatus> m_outSuperframeStatus;
 
-    /**
-     * The packet which is currently being sent by the MAC layer.
-     */
-    Ptr<Packet> m_txPkt;
-
     /**
      * The command request packet received. Briefly stored to proceed with operations
      * that take place after ACK messages.
      */
     Ptr<Packet> m_rxPkt;
 
-    /**
-     * The short address (16 bit address) used by this MAC. If supported,
-     * the short address must be assigned to the device by the coordinator
-     * during the association process.
-     */
-    Mac16Address m_shortAddress;
-
-    /**
-     * The extended 64 address (IEEE EUI-64) used by this MAC.
-     */
-    Mac64Address m_macExtendedAddress;
-
-    /**
-     * The transmit queue used by the MAC.
-     */
-    std::deque<Ptr<TxQueueElement>> m_txQueue;
-
     /**
      * The indirect transmit queue used by the MAC pending messages (The pending transaction
      * list).
@@ -1316,12 +1309,6 @@ class LrWpanMac : public LrWpanMacBase
 
     bool m_ignoreDataCmdAck;
 
-    /**
-     * Scheduler event for the ACK timeout of the currently transmitted data
-     * packet.
-     */
-    EventId m_ackWaitTimeout;
-
     /**
      * Scheduler event for a response to a request command frame.
      */
diff --git a/src/lr-wpan/model/lr-wpan-phy.cc b/src/lr-wpan/model/lr-wpan-phy.cc
index 6b4da4c..6575c84 100644
--- a/src/lr-wpan/model/lr-wpan-phy.cc
+++ b/src/lr-wpan/model/lr-wpan-phy.cc
@@ -352,7 +352,20 @@ LrWpanPhy::SetAntenna(Ptr<AntennaModel> a)
 void
 LrWpanPhy::StartRx(Ptr<SpectrumSignalParameters> spectrumRxParams)
 {
-    NS_LOG_FUNCTION(this << spectrumRxParams);
+    NS_LOG_FUNCTION(this << spectrumRxParams << m_isRxCanceled << m_EndRx.GetUid() << "ts "
+                         << m_EndRx.GetTs());
+    if (m_EndRx.IsPending())
+    {
+        NS_LOG_DEBUG("end rx is pending" << m_EndRx.GetUid());
+    }
+    else if (m_EndRx.IsExpired())
+    {
+        NS_LOG_DEBUG("end rx is expired" << m_EndRx.GetUid());
+    }
+    else
+    {
+        NS_LOG_DEBUG("end rx is not pending" << m_EndRx.GetUid());
+    }
 
     if (!m_edRequest.IsExpired())
     {
@@ -385,7 +398,10 @@ LrWpanPhy::StartRx(Ptr<SpectrumSignalParameters> spectrumRxParams)
             }
         }
 
-        Simulator::Schedule(spectrumRxParams->duration, &LrWpanPhy::EndRx, this, spectrumRxParams);
+        m_EndRx = Simulator::Schedule(spectrumRxParams->duration,
+                                      &LrWpanPhy::EndRx,
+                                      this,
+                                      spectrumRxParams);
         return;
     }
 
@@ -482,7 +498,18 @@ LrWpanPhy::StartRx(Ptr<SpectrumSignalParameters> spectrumRxParams)
     // Always call EndRx to update the interference.
     // We keep track of this event, and if necessary cancel this event when a TX of a packet.
 
-    Simulator::Schedule(spectrumRxParams->duration, &LrWpanPhy::EndRx, this, spectrumRxParams);
+    m_EndRx =
+        Simulator::Schedule(spectrumRxParams->duration, &LrWpanPhy::EndRx, this, spectrumRxParams);
+    NS_LOG_DEBUG("scheduled EndRx for " << spectrumRxParams->duration.As(Time::MS) << " ms"
+                                        << m_EndRx.GetTs() << m_EndRx.GetUid());
+    if (m_EndRx.IsPending())
+    {
+        NS_LOG_DEBUG("end rx is pending");
+    }
+    else
+    {
+        NS_LOG_DEBUG("end rx is not pending");
+    }
 }
 
 void
@@ -495,7 +522,12 @@ LrWpanPhy::CheckInterference()
     // We are currently receiving a packet.
     if (m_trxState == IEEE_802_15_4_PHY_BUSY_RX)
     {
-        // NS_ASSERT (currentRxParams && !m_currentRxPacket.second);
+        // NS_ASSERT(currentRxParams && !m_currentRxPacket.second);
+        if (m_currentRxPacket.first == nullptr)
+        {
+            //  SINR 
+            return;
+        }
 
         Ptr<Packet> currentPacket = currentRxParams->packetBurst->GetPackets().front();
         if (m_errorModel)
@@ -538,7 +570,8 @@ LrWpanPhy::CheckInterference()
 void
 LrWpanPhy::EndRx(Ptr<SpectrumSignalParameters> par)
 {
-    NS_LOG_FUNCTION(this);
+    NS_LOG_FUNCTION(this << m_isRxCanceled << m_EndRx.GetUid() << "parfirst" << par
+                         << "currentfirst" << m_currentRxPacket.first);
 
     Ptr<LrWpanSpectrumSignalParameters> params = DynamicCast<LrWpanSpectrumSignalParameters>(par);
 
@@ -601,6 +634,7 @@ LrWpanPhy::EndRx(Ptr<SpectrumSignalParameters> par)
         }
         else
         {
+            NS_LOG_DEBUG("Packet reception failed, dropping packet");
             // The packet was destroyed due to interference, post-rx corruption or
             // cancelled, therefore drop it.
             m_phyRxDropTrace(currentPacket);
@@ -609,15 +643,22 @@ LrWpanPhy::EndRx(Ptr<SpectrumSignalParameters> par)
             if (!m_isRxCanceled)
             {
                 ChangeTrxState(IEEE_802_15_4_PHY_RX_ON);
+                NS_LOG_DEBUG("Set Rx ON");
             }
             else
             {
                 // The state of The PHY was already changed when the packet was canceled
                 // due to a forced operation.
                 m_isRxCanceled = false;
+                NS_LOG_DEBUG("isRxCanceled" << m_isRxCanceled);
             }
         }
     }
+    else if (params == m_isRxCanceledParams)
+    {
+        NS_LOG_DEBUG("canceled rx packet in endRx after end iterruped by a new tx");
+        m_isRxCanceled = false;
+    }
 }
 
 void
@@ -660,6 +701,15 @@ LrWpanPhy::PdDataRequest(const uint32_t psduLength, Ptr<Packet> p)
             pb->AddPacket(p);
             txParams->packetBurst = pb;
             m_channel->StartTx(txParams);
+            // TODO 
+            if (m_EndRx.IsPending())
+            {
+                NS_LOG_DEBUG("end rx is pending" << m_EndRx.GetUid());
+            }
+            else
+            {
+                NS_LOG_DEBUG("end rx is not pending" << m_EndRx.GetUid());
+            }
             m_pdDataRequest = Simulator::Schedule(txParams->duration, &LrWpanPhy::EndTx, this);
             ChangeTrxState(IEEE_802_15_4_PHY_BUSY_TX);
             return;
@@ -835,6 +885,7 @@ LrWpanPhy::PlmeSetTRXStateRequest(PhyEnumeration state)
     {
         NS_LOG_DEBUG("Phy is busy; setting state pending to " << state);
         m_trxStatePending = state;
+        // m_isRxCanceled = false;
         return; // Send PlmeSetTRXStateConfirm later
     }
 
@@ -877,8 +928,17 @@ LrWpanPhy::PlmeSetTRXStateRequest(PhyEnumeration state)
                 // issued) The current RX frame is marked as incomplete and the reception as
                 // canceled EndRx () will handle the rest accordingly
                 NS_LOG_DEBUG("force TX_ON, terminate reception");
+                m_isRxCanceledParams = m_currentRxPacket.first;
                 m_currentRxPacket.second = true;
                 m_isRxCanceled = true;
+                if (m_EndRx.IsPending())
+                {
+                    NS_LOG_DEBUG("end rx is pending" << m_EndRx.GetUid());
+                }
+                else
+                {
+                    NS_LOG_DEBUG("end rx is not pending" << m_EndRx.GetUid());
+                }
             }
 
             // If CCA is in progress, cancel CCA and return BUSY.
@@ -933,6 +993,7 @@ LrWpanPhy::PlmeSetTRXStateRequest(PhyEnumeration state)
                 // Terminate reception
                 // Mark the packet as incomplete and reception as canceled.
                 NS_LOG_DEBUG("force TRX_OFF, terminate reception");
+                m_isRxCanceledParams = m_currentRxPacket.first;
                 m_currentRxPacket.second = true;
                 m_isRxCanceled = true;
             }
@@ -954,6 +1015,16 @@ LrWpanPhy::PlmeSetTRXStateRequest(PhyEnumeration state)
 
     if (state == IEEE_802_15_4_PHY_RX_ON)
     {
+        if (m_trxState == IEEE_802_15_4_PHY_TX_ON || m_trxState == IEEE_802_15_4_PHY_BUSY_TX ||
+            m_trxState == IEEE_802_15_4_PHY_TRX_OFF)
+        {
+            if (m_isRxCanceled)
+            {
+                NS_LOG_DEBUG("end interruption process");
+                m_isRxCanceled = false; // Reset the flag, as we are not canceling a reception
+            }
+        }
+
         if (m_trxState == IEEE_802_15_4_PHY_TX_ON || m_trxState == IEEE_802_15_4_PHY_TRX_OFF)
         {
             // Turnaround delay
@@ -1499,6 +1570,15 @@ LrWpanPhy::EndSetTRXState()
     {
         m_plmeSetTRXStateConfirmCallback(m_trxState);
     }
+
+    if (m_EndRx.IsPending())
+    {
+        NS_LOG_DEBUG("end rx is pending" << m_EndRx.GetUid());
+    }
+    else
+    {
+        NS_LOG_DEBUG("end rx is not pending" << m_EndRx.GetUid());
+    }
 }
 
 void
@@ -1506,6 +1586,15 @@ LrWpanPhy::EndTx()
 {
     NS_LOG_FUNCTION(this);
 
+    if (m_EndRx.IsPending())
+    {
+        NS_LOG_DEBUG("end rx is pending" << m_EndRx.GetUid());
+    }
+    else
+    {
+        NS_LOG_DEBUG("end rx is not pending" << m_EndRx.GetUid());
+    }
+
     NS_ABORT_IF((m_trxState != IEEE_802_15_4_PHY_BUSY_TX) &&
                 (m_trxState != IEEE_802_15_4_PHY_TRX_OFF));
 
@@ -1532,6 +1621,7 @@ LrWpanPhy::EndTx()
     m_currentTxPacket.first = nullptr;
     m_currentTxPacket.second = false;
 
+    NS_LOG_DEBUG("aaa");
     // We may be waiting to apply a pending state change.
     if (m_trxStatePending != IEEE_802_15_4_PHY_IDLE)
     {
@@ -1539,7 +1629,7 @@ LrWpanPhy::EndTx()
         // switching the state.
         if (!m_setTRXState.IsPending())
         {
-            NS_LOG_LOGIC("Apply pending state change to " << m_trxStatePending);
+            NS_LOG_DEBUG("Apply pending state change to " << m_trxStatePending);
             ChangeTrxState(m_trxStatePending);
             m_trxStatePending = IEEE_802_15_4_PHY_IDLE;
             if (!m_plmeSetTRXStateConfirmCallback.IsNull())
@@ -1547,11 +1637,20 @@ LrWpanPhy::EndTx()
                 m_plmeSetTRXStateConfirmCallback(IEEE_802_15_4_PHY_SUCCESS);
             }
         }
+        else
+        {
+            NS_LOG_DEBUG("Pending state change to " << m_trxStatePending
+                                                    << " will be applied later");
+            // We are already switching the transceiver state.
+            // The pending state change will be applied later.
+        }
     }
     else
     {
+        NS_LOG_DEBUG("No pending state change, set to TX_ON");
         if (m_trxState != IEEE_802_15_4_PHY_TRX_OFF)
         {
+            NS_LOG_DEBUG("Set transceiver state to TX_ON");
             ChangeTrxState(IEEE_802_15_4_PHY_TX_ON);
         }
     }
diff --git a/src/lr-wpan/model/lr-wpan-phy.h b/src/lr-wpan/model/lr-wpan-phy.h
index 7983873..8bb051d 100644
--- a/src/lr-wpan/model/lr-wpan-phy.h
+++ b/src/lr-wpan/model/lr-wpan-phy.h
@@ -916,6 +916,8 @@ class LrWpanPhy : public SpectrumPhy
      */
     std::pair<Ptr<LrWpanSpectrumSignalParameters>, bool> m_currentRxPacket;
 
+    Ptr<LrWpanSpectrumSignalParameters> m_isRxCanceledParams;
+
     /**
      * Status information of the currently transmitted packet. The first parameter
      * contains the frame. If the second parameter is set to true, the frame has not
@@ -944,6 +946,8 @@ class LrWpanPhy : public SpectrumPhy
      */
     EventId m_pdDataRequest;
 
+    EventId m_EndRx;
+
     /**
      * Uniform random variable stream.
      */
diff --git a/src/rit-wpan/CMakeLists.txt b/src/rit-wpan/CMakeLists.txt
new file mode 100644
index 0000000..af0b54a
--- /dev/null
+++ b/src/rit-wpan/CMakeLists.txt
@@ -0,0 +1,38 @@
+build_lib(
+  LIBNAME rit-wpan
+  SOURCE_FILES
+    model/rit-wpan-mac.cc
+    model/rit-sub-header.cc
+    model/rit-wpan-precs.cc
+    model/rit-wpan-nwk.cc
+    model/rit-wpan-nwk-header.cc
+    model/rit-wpan-net-device.cc
+    model/time-drift-applier.cc
+    model/clock-drift-applier.cc
+    application/periodic-sender.cc
+    application/random-sender.cc
+    helper/periodic-sender-helper.cc
+    helper/random-sender-helper.cc
+    helper/rit-wpan-helper.cc
+    helper/rit-rank-helper.cc
+  HEADER_FILES
+    model/rit-wpan-mac.h
+    model/rit-sub-header.h
+    model/rit-wpan-precs.h
+    model/rit-wpan-nwk.h
+    model/rit-wpan-nwk-header.h
+    model/rit-wpan-net-device.h
+    model/time-drift-applier.h
+    model/clock-drift-applier.h
+    application/periodic-sender.h
+    application/random-sender.h
+    helper/periodic-sender-helper.h
+    helper/random-sender-helper.h
+    helper/rit-wpan-helper.h
+    helper/rit-rank-helper.h
+  LIBRARIES_TO_LINK
+    ${liblrwpan}
+  TEST_SOURCES
+    # test/periodic-sender-test.cc
+    test/rit-wpan-trx-test.cc
+)
diff --git a/src/rit-wpan/application/periodic-sender.cc b/src/rit-wpan/application/periodic-sender.cc
new file mode 100644
index 0000000..04cdc89
--- /dev/null
+++ b/src/rit-wpan/application/periodic-sender.cc
@@ -0,0 +1,234 @@
+#include "periodic-sender.h"
+
+#include "ns3/log.h"
+#include "ns3/lr-wpan-net-device.h"
+#include "ns3/net-device.h"
+#include "ns3/node.h"
+#include "ns3/packet.h"
+#include "ns3/simulator.h"
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+NS_LOG_COMPONENT_DEFINE("PeriodicSender");
+NS_OBJECT_ENSURE_REGISTERED(PeriodicSender);
+
+// Define static members
+const Time PeriodicSender::DEFAULT_INTERVAL = Seconds(60);
+const Time PeriodicSender::DEFAULT_INITIAL_DELAY = Seconds(0);
+
+TypeId
+PeriodicSender::GetTypeId()
+{
+    static TypeId tid = TypeId("ns3::lrwpan::PeriodicSender")
+                            .SetParent<Application>()
+                            .SetGroupName("LrWpan")
+                            .AddConstructor<PeriodicSender>()
+                            .AddAttribute("Interval",
+                                          "The interval between packet sends",
+                                          TimeValue(DEFAULT_INTERVAL),
+                                          MakeTimeAccessor(&PeriodicSender::m_interval),
+                                          MakeTimeChecker())
+                            .AddAttribute("PacketSize",
+                                          "Size of packets sent",
+                                          UintegerValue(DEFAULT_PACKET_SIZE),
+                                          MakeUintegerAccessor(&PeriodicSender::m_packetSize),
+                                          MakeUintegerChecker<uint8_t>())
+                            .AddAttribute("DstAddress",
+                                          "The destination Address",
+                                          AddressValue(), // Use default constructor
+                                          MakeAddressAccessor(&PeriodicSender::m_dstAddr),
+                                          MakeAddressChecker())
+                            .AddAttribute("InitialDelay",
+                                          "Initial delay before starting transmissions",
+                                          TimeValue(DEFAULT_INITIAL_DELAY),
+                                          MakeTimeAccessor(&PeriodicSender::m_initialDelay),
+                                          MakeTimeChecker())
+                            .AddTraceSource("Tx",
+                                            "A packet has been sent",
+                                            MakeTraceSourceAccessor(&PeriodicSender::m_txTrace),
+                                            "ns3::Packet::TracedCallback")
+                            .AddTraceSource("Rx",
+                                            "A packet has been received",
+                                            MakeTraceSourceAccessor(&PeriodicSender::m_rxTrace),
+                                            "ns3::Packet::TracedCallback");
+    return tid;
+}
+
+PeriodicSender::PeriodicSender()
+    : m_interval(DEFAULT_INTERVAL),
+      m_initialDelay(DEFAULT_INITIAL_DELAY),
+      m_packetSize(DEFAULT_PACKET_SIZE),
+      m_dstAddr(),
+      m_netDevice(nullptr),
+      m_noSendFlag(false)
+{
+    NS_LOG_FUNCTION(this);
+    m_timeDriftApplier = CreateObject<TimeDriftApplier>();
+}
+
+PeriodicSender::~PeriodicSender()
+{
+    NS_LOG_FUNCTION(this);
+}
+
+void
+PeriodicSender::SetInterval(Time interval)
+{
+    NS_LOG_FUNCTION(this << interval);
+    m_interval = interval;
+}
+
+void
+PeriodicSender::SetInitialDelay(Time delay)
+{
+    NS_LOG_FUNCTION(this << delay);
+    m_initialDelay = delay;
+}
+
+void
+PeriodicSender::SetPacketSize(uint8_t size)
+{
+    NS_LOG_FUNCTION(this << static_cast<uint32_t>(size));
+    m_packetSize = size;
+}
+
+void
+PeriodicSender::SetDstAddr(const Address& addr)
+{
+    NS_LOG_FUNCTION(this << addr);
+    // Verify that the address is either Mac16Address or Mac64Address
+    if (Mac16Address::IsMatchingType(addr) || Mac64Address::IsMatchingType(addr))
+    {
+        m_dstAddr = addr;
+    }
+    else
+    {
+        NS_FATAL_ERROR("Address must be either Mac16Address or Mac64Address");
+    }
+}
+
+void
+PeriodicSender::SetNoSendMode(bool noSendFlag)
+{
+    NS_LOG_FUNCTION(this << noSendFlag);
+    m_noSendFlag = noSendFlag;
+}
+
+void
+PeriodicSender::StartApplication()
+{
+    NS_LOG_FUNCTION(this);
+
+    if (m_noSendFlag)
+    {
+        NS_LOG_DEBUG("PeriodicSender is in no-send mode on node " << GetNode()->GetId());
+        return; // Do not proceed if in no-send mode
+    }
+
+    NS_ASSERT(!m_dstAddr.IsInvalid());
+
+    m_netDevice = m_node->GetDevice(0);
+    if (m_netDevice == nullptr)
+    {
+        NS_LOG_ERROR("No LrWpan device found on node " << m_node->GetId());
+        return;
+    }
+
+    if (!m_noSendFlag)
+    {
+        NS_LOG_DEBUG("(App Params)[nodeID: "
+                     << m_node->GetId() << "] Interval=" << m_interval.GetSeconds() << "s, "
+                     << "Initial Delay=" << m_initialDelay.GetSeconds() << "s, "
+                     << "DstAddress=" << m_dstAddr << ", "
+                     << "PktSize=" << static_cast<int>(m_packetSize));
+
+        Simulator::Cancel(m_sendEvent); // Cancel any pending events
+        m_sendEvent = Simulator::Schedule(m_initialDelay, &PeriodicSender::SendPacket, this);
+    }
+    else
+    {
+        NS_LOG_DEBUG("PeriodicSender is in no-send mode on node " << m_node->GetId());
+    }
+}
+
+void
+PeriodicSender::StopApplication()
+{
+    NS_LOG_FUNCTION(this);
+
+    if (m_sendEvent.IsPending())
+    {
+        Simulator::Cancel(m_sendEvent);
+    }
+
+    // Reset for potential future restart
+    m_netDevice = nullptr;
+}
+
+void
+PeriodicSender::SendPacket()
+{
+    NS_LOG_FUNCTION(this);
+
+    if (!m_netDevice)
+    {
+        NS_LOG_ERROR("Cannot send packet: network device not available");
+        return;
+    }
+
+    // Create a new packet with the configured size
+    Ptr<Packet> packet = Create<Packet>(m_packetSize);
+    bool sendRequestIssued = false;
+
+    // Send packet to the configured destination address (Mac16Address or Mac64Address).
+    if (Mac16Address::IsMatchingType(m_dstAddr))
+    {
+        sendRequestIssued = m_netDevice->Send(packet, Mac16Address::ConvertFrom(m_dstAddr), 0);
+    }
+    else if (Mac64Address::IsMatchingType(m_dstAddr))
+    {
+        sendRequestIssued = m_netDevice->Send(packet, Mac64Address::ConvertFrom(m_dstAddr), 0);
+    }
+    else
+    {
+        NS_FATAL_ERROR("Unsupported address type: " << m_dstAddr);
+    }
+
+    if (sendRequestIssued)
+    {
+        NS_LOG_INFO("[App->NetDev]:At "
+                    << Simulator::Now().GetSeconds() << "s node " << GetNode()->GetId()
+                    << " issued send request for packet with size "
+                    << static_cast<uint32_t>(m_packetSize) << " bytes to " << m_dstAddr);
+        m_txTrace(packet);
+    }
+    else
+    {
+        NS_LOG_ERROR("Failed to issue send request from node " << GetNode()->GetId());
+    }
+
+    // Schedule the next packet transmission
+    // TODO: 
+    m_sendEvent = Simulator::Schedule(m_timeDriftApplier->ApplyByRatio(m_interval, 1),
+                                      &PeriodicSender::SendPacket,
+                                      this);
+}
+
+bool
+PeriodicSender::ReceivePacket(Ptr<NetDevice> device,
+                              Ptr<const Packet> packet,
+                              uint16_t protocol,
+                              const Address& sender)
+{
+    NS_LOG_FUNCTION(this << device << packet << protocol << sender);
+    NS_LOG_INFO("[NetDev->App]:At " << Simulator::Now().GetSeconds() << "s node "
+                                    << GetNode()->GetId() << " received packet from " << sender);
+    m_rxTrace(packet);
+    return true;
+}
+
+} // namespace lrwpan
+} // namespace ns3
diff --git a/src/rit-wpan/application/periodic-sender.h b/src/rit-wpan/application/periodic-sender.h
new file mode 100644
index 0000000..6ed7d1d
--- /dev/null
+++ b/src/rit-wpan/application/periodic-sender.h
@@ -0,0 +1,116 @@
+#pragma once
+
+#include "ns3/address.h"
+#include "ns3/application.h"
+#include "ns3/event-id.h"
+#include "ns3/lr-wpan-mac.h"
+#include "ns3/mac16-address.h"
+#include "ns3/mac64-address.h"
+#include "ns3/net-device.h"
+#include "ns3/ptr.h"
+#include "ns3/time-drift-applier.h"
+#include "ns3/traced-callback.h"
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+/**
+ * @ingroup lr-wpan
+ *
+ * @brief A periodic sender application that generates packets at regular intervals.
+ *
+ * This application sends packets periodically to a specific destination address.
+ * It's designed to work with standard LrWpan networks for testing and simulation.
+ */
+class PeriodicSender : public Application
+{
+  public:
+    /**
+     * Default values for PeriodicSender attributes
+     */
+    static const Time DEFAULT_INTERVAL;                //!< Default packet sending interval
+    static const Time DEFAULT_INITIAL_DELAY;           //!< Default initial delay
+    static constexpr uint8_t DEFAULT_PACKET_SIZE = 20; //!< Default packet size in bytes
+
+    /**
+     * @brief Get the TypeId
+     *
+     * @return The TypeId for this class
+     */
+    static TypeId GetTypeId(void);
+
+    /**
+     * @brief Default constructor
+     */
+    PeriodicSender();
+
+    /**
+     * @brief Destructor
+     */
+    ~PeriodicSender() override;
+
+    /**
+     * @brief Set the sending interval
+     * @param interval The interval between packet transmissions
+     */
+    void SetInterval(Time interval);
+
+    /**
+     * @brief Set initial delay before starting transmissions
+     * @param delay The initial delay
+     */
+    void SetInitialDelay(Time delay);
+
+    /**
+     * @brief Set the size of packets to be sent
+     * @param size The packet size in bytes
+     */
+    void SetPacketSize(uint8_t size);
+
+    /**
+     * @brief Set the destination address for packets
+     * @param addr The destination address (can be Mac16Address or Mac64Address)
+     */
+    void SetDstAddr(const Address& addr);
+
+    void SetNoSendMode(bool noSendFlag);
+
+    /**
+     * @brief Start the application
+     */
+    void StartApplication() override;
+
+    /**
+     * @brief Stop the application
+     */
+    void StopApplication() override;
+
+    bool ReceivePacket(Ptr<NetDevice> device,
+                       Ptr<const Packet> packet,
+                       uint16_t protocol,
+                       const Address& sender);
+
+  private:
+    /**
+     * @brief Send a packet
+     */
+    void SendPacket();
+
+    Time m_interval;            //!< Packet sending interval
+    Time m_initialDelay;        //!< Initial delay before starting transmissions
+    uint8_t m_packetSize;       //!< Size of packets to send
+    Address m_dstAddr;          //!< Destination address (Mac16Address or Mac64Address)
+    Ptr<NetDevice> m_netDevice; //!< Network device used for sending
+    EventId m_sendEvent;        //!< Event to schedule the next packet sending
+    bool m_noSendFlag;          //!< Flag to indicate if the application should not send packets
+
+    Ptr<TimeDriftApplier> m_timeDriftApplier; //!< For randomizing beacon interval
+
+    TracedCallback<Ptr<const Packet>> m_txTrace; //!< Trace of transmitted packets
+    TracedCallback<Ptr<const Packet>> m_rxTrace; //!< Trace of received packets
+};
+
+} // namespace lrwpan
+} // namespace ns3
diff --git a/src/rit-wpan/application/random-sender.cc b/src/rit-wpan/application/random-sender.cc
new file mode 100644
index 0000000..214ae2d
--- /dev/null
+++ b/src/rit-wpan/application/random-sender.cc
@@ -0,0 +1,271 @@
+#include "random-sender.h"
+
+#include "ns3/log.h"
+#include "ns3/lr-wpan-net-device.h"
+#include "ns3/net-device.h"
+#include "ns3/node.h"
+#include "ns3/packet.h"
+#include "ns3/random-variable-stream.h"
+#include "ns3/simulator.h"
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+NS_LOG_COMPONENT_DEFINE("RandomSender");
+NS_OBJECT_ENSURE_REGISTERED(RandomSender);
+
+// Define static members
+const Time RandomSender::DEFAULT_MIN_INTERVAL = Seconds(180);
+const Time RandomSender::DEFAULT_MAX_INTERVAL = Seconds(600);
+const Time RandomSender::DEFAULT_INITIAL_DELAY = Seconds(0);
+
+TypeId
+RandomSender::GetTypeId()
+{
+    static TypeId tid = TypeId("ns3::lrwpan::RandomSender")
+                            .SetParent<Application>()
+                            .SetGroupName("LrWpan")
+                            .AddConstructor<RandomSender>()
+                            .AddAttribute("MinInterval",
+                                          "The minimum interval between packet sends",
+                                          TimeValue(DEFAULT_MIN_INTERVAL),
+                                          MakeTimeAccessor(&RandomSender::m_minInterval),
+                                          MakeTimeChecker())
+                            .AddAttribute("MaxInterval",
+                                          "The maximum interval between packet sends",
+                                          TimeValue(DEFAULT_MAX_INTERVAL),
+                                          MakeTimeAccessor(&RandomSender::m_maxInterval),
+                                          MakeTimeChecker())
+                            .AddAttribute("PacketSize",
+                                          "Size of packets sent",
+                                          UintegerValue(DEFAULT_PACKET_SIZE),
+                                          MakeUintegerAccessor(&RandomSender::m_packetSize),
+                                          MakeUintegerChecker<uint8_t>())
+                            .AddAttribute("DstAddress",
+                                          "The destination Address",
+                                          AddressValue(), // Use default constructor
+                                          MakeAddressAccessor(&RandomSender::m_dstAddr),
+                                          MakeAddressChecker())
+                            .AddAttribute("InitialDelay",
+                                          "Initial delay before starting transmissions",
+                                          TimeValue(DEFAULT_INITIAL_DELAY),
+                                          MakeTimeAccessor(&RandomSender::m_initialDelay),
+                                          MakeTimeChecker())
+                            .AddTraceSource("Tx",
+                                            "A packet has been sent",
+                                            MakeTraceSourceAccessor(&RandomSender::m_txTrace),
+                                            "ns3::Packet::TracedCallback")
+                            .AddTraceSource("Rx",
+                                            "A packet has been received",
+                                            MakeTraceSourceAccessor(&RandomSender::m_rxTrace),
+                                            "ns3::Packet::TracedCallback");
+    return tid;
+}
+
+RandomSender::RandomSender()
+    : m_minInterval(DEFAULT_MIN_INTERVAL),
+      m_maxInterval(DEFAULT_MAX_INTERVAL),
+      m_initialDelay(DEFAULT_INITIAL_DELAY),
+      m_packetSize(DEFAULT_PACKET_SIZE),
+      m_dstAddr(),
+      m_netDevice(nullptr),
+      m_noSendFlag(false)
+{
+    NS_LOG_FUNCTION(this);
+    m_timeDriftApplier = CreateObject<TimeDriftApplier>();
+    m_randomVariable = CreateObject<UniformRandomVariable>();
+}
+
+RandomSender::~RandomSender()
+{
+    NS_LOG_FUNCTION(this);
+}
+
+void
+RandomSender::SetMinInterval(Time minInterval)
+{
+    NS_LOG_FUNCTION(this << minInterval);
+    m_minInterval = minInterval;
+}
+
+void
+RandomSender::SetMaxInterval(Time maxInterval)
+{
+    NS_LOG_FUNCTION(this << maxInterval);
+    m_maxInterval = maxInterval;
+}
+
+void
+RandomSender::SetInitialDelay(Time delay)
+{
+    NS_LOG_FUNCTION(this << delay);
+    m_initialDelay = delay;
+}
+
+void
+RandomSender::SetPacketSize(uint8_t size)
+{
+    NS_LOG_FUNCTION(this << static_cast<uint32_t>(size));
+    m_packetSize = size;
+}
+
+void
+RandomSender::SetDstAddr(const Address& addr)
+{
+    NS_LOG_FUNCTION(this << addr);
+    // Verify that the address is either Mac16Address or Mac64Address
+    if (Mac16Address::IsMatchingType(addr) || Mac64Address::IsMatchingType(addr))
+    {
+        m_dstAddr = addr;
+    }
+    else
+    {
+        NS_FATAL_ERROR("Address must be either Mac16Address or Mac64Address");
+    }
+}
+
+void
+RandomSender::SetNoSendMode(bool noSendFlag)
+{
+    NS_LOG_FUNCTION(this << noSendFlag);
+    m_noSendFlag = noSendFlag;
+}
+
+void
+RandomSender::StartApplication()
+{
+    NS_LOG_FUNCTION(this);
+
+    if (m_noSendFlag)
+    {
+        NS_LOG_DEBUG("RandomSender is in no-send mode on node " << GetNode()->GetId());
+        return; // Do not proceed if in no-send mode
+    }
+
+    NS_ASSERT(!m_dstAddr.IsInvalid());
+
+    m_netDevice = m_node->GetDevice(0);
+    if (m_netDevice == nullptr)
+    {
+        NS_LOG_ERROR("No LrWpan device found on node " << m_node->GetId());
+        return;
+    }
+
+    if (!m_noSendFlag)
+    {
+        NS_LOG_DEBUG("(App Params)[nodeID: "
+                     << m_node->GetId() << "] MinInterval=" << m_minInterval.GetSeconds() << "s, "
+                     << "MaxInterval=" << m_maxInterval.GetSeconds() << "s, "
+                     << "Initial Delay=" << m_initialDelay.GetSeconds() << "s, "
+                     << "DstAddress=" << m_dstAddr << ", "
+                     << "PktSize=" << static_cast<int>(m_packetSize));
+
+        Simulator::Cancel(m_sendEvent); // Cancel any pending events
+        m_sendEvent = Simulator::Schedule(m_initialDelay, &RandomSender::SendPacket, this);
+    }
+    else
+    {
+        NS_LOG_DEBUG("RandomSender is in no-send mode on node " << m_node->GetId());
+    }
+}
+
+void
+RandomSender::StopApplication()
+{
+    NS_LOG_FUNCTION(this);
+
+    if (m_sendEvent.IsPending())
+    {
+        Simulator::Cancel(m_sendEvent);
+    }
+
+    // Reset for potential future restart
+    m_netDevice = nullptr;
+}
+
+void
+RandomSender::SendPacket()
+{
+    NS_LOG_FUNCTION(this);
+
+    if (!m_netDevice)
+    {
+        NS_LOG_ERROR("Cannot send packet: network device not available");
+        return;
+    }
+
+    // Create a new packet with the configured size
+    Ptr<Packet> packet = Create<Packet>(m_packetSize);
+    bool sendRequestIssued = false;
+
+    // Send packet to the configured destination address (Mac16Address or Mac64Address).
+    if (Mac16Address::IsMatchingType(m_dstAddr))
+    {
+        sendRequestIssued = m_netDevice->Send(packet, Mac16Address::ConvertFrom(m_dstAddr), 0);
+    }
+    else if (Mac64Address::IsMatchingType(m_dstAddr))
+    {
+        sendRequestIssued = m_netDevice->Send(packet, Mac64Address::ConvertFrom(m_dstAddr), 0);
+    }
+    else
+    {
+        NS_FATAL_ERROR("Unsupported address type: " << m_dstAddr);
+    }
+
+    if (sendRequestIssued)
+    {
+        NS_LOG_INFO("[App->NetDev]:At "
+                    << Simulator::Now().GetSeconds() << "s node " << GetNode()->GetId()
+                    << " issued send request for packet with size "
+                    << static_cast<uint32_t>(m_packetSize) << " bytes to " << m_dstAddr);
+        m_txTrace(packet);
+    }
+    else
+    {
+        NS_LOG_ERROR("Failed to issue send request from node " << GetNode()->GetId());
+    }
+
+    // Schedule the next packet transmission with random interval
+    Time randomInterval = GetRandomInterval();
+    NS_LOG_DEBUG("Node " << GetNode()->GetId() << " scheduling next transmission in "
+                         << randomInterval.GetSeconds() << "s");
+
+    m_sendEvent = Simulator::Schedule(m_timeDriftApplier->ApplyByRatio(randomInterval, 1),
+                                      &RandomSender::SendPacket,
+                                      this);
+}
+
+bool
+RandomSender::ReceivePacket(Ptr<NetDevice> device,
+                            Ptr<const Packet> packet,
+                            uint16_t protocol,
+                            const Address& sender)
+{
+    NS_LOG_FUNCTION(this << device << packet << protocol << sender);
+    NS_LOG_INFO("[NetDev->App]:At " << Simulator::Now().GetSeconds() << "s node "
+                                    << GetNode()->GetId() << " received packet from " << sender);
+    m_rxTrace(packet);
+    return true;
+}
+
+Time
+RandomSender::GetRandomInterval()
+{
+    double minSeconds = m_minInterval.GetSeconds();
+    double maxSeconds = m_maxInterval.GetSeconds();
+
+    // Ensure min <= max
+    if (minSeconds > maxSeconds)
+    {
+        NS_FATAL_ERROR("MinInterval (" << minSeconds << "s) must be <= MaxInterval (" << maxSeconds
+                                       << "s)");
+    }
+
+    double randomSeconds = m_randomVariable->GetValue(minSeconds, maxSeconds);
+    return Seconds(randomSeconds);
+}
+
+} // namespace lrwpan
+} // namespace ns3
diff --git a/src/rit-wpan/application/random-sender.h b/src/rit-wpan/application/random-sender.h
new file mode 100644
index 0000000..faf7902
--- /dev/null
+++ b/src/rit-wpan/application/random-sender.h
@@ -0,0 +1,133 @@
+#pragma once
+
+#include "ns3/address.h"
+#include "ns3/application.h"
+#include "ns3/event-id.h"
+#include "ns3/lr-wpan-mac.h"
+#include "ns3/mac16-address.h"
+#include "ns3/mac64-address.h"
+#include "ns3/net-device.h"
+#include "ns3/ptr.h"
+#include "ns3/random-variable-stream.h"
+#include "ns3/time-drift-applier.h"
+#include "ns3/traced-callback.h"
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+/**
+ * @ingroup lr-wpan
+ *
+ * @brief A random sender application that generates packets at random intervals.
+ *
+ * This application sends packets at random intervals (between min and max) to a specific
+ * destination address. It's designed to work with standard LrWpan networks for testing and
+ * simulation.
+ */
+class RandomSender : public Application
+{
+  public:
+    /**
+     * Default values for RandomSender attributes
+     */
+    static const Time DEFAULT_MIN_INTERVAL;            //!< Default minimum packet sending interval
+    static const Time DEFAULT_MAX_INTERVAL;            //!< Default maximum packet sending interval
+    static const Time DEFAULT_INITIAL_DELAY;           //!< Default initial delay
+    static constexpr uint8_t DEFAULT_PACKET_SIZE = 20; //!< Default packet size in bytes
+
+    /**
+     * @brief Get the TypeId
+     *
+     * @return The TypeId for this class
+     */
+    static TypeId GetTypeId(void);
+
+    /**
+     * @brief Default constructor
+     */
+    RandomSender();
+
+    /**
+     * @brief Destructor
+     */
+    ~RandomSender() override;
+
+    /**
+     * @brief Set the minimum sending interval
+     * @param minInterval The minimum interval between packet transmissions
+     */
+    void SetMinInterval(Time minInterval);
+
+    /**
+     * @brief Set the maximum sending interval
+     * @param maxInterval The maximum interval between packet transmissions
+     */
+    void SetMaxInterval(Time maxInterval);
+
+    /**
+     * @brief Set initial delay before starting transmissions
+     * @param delay The initial delay
+     */
+    void SetInitialDelay(Time delay);
+
+    /**
+     * @brief Set the size of packets to be sent
+     * @param size The packet size in bytes
+     */
+    void SetPacketSize(uint8_t size);
+
+    /**
+     * @brief Set the destination address for packets
+     * @param addr The destination address (can be Mac16Address or Mac64Address)
+     */
+    void SetDstAddr(const Address& addr);
+
+    void SetNoSendMode(bool noSendFlag);
+
+    /**
+     * @brief Start the application
+     */
+    void StartApplication() override;
+
+    /**
+     * @brief Stop the application
+     */
+    void StopApplication() override;
+
+    bool ReceivePacket(Ptr<NetDevice> device,
+                       Ptr<const Packet> packet,
+                       uint16_t protocol,
+                       const Address& sender);
+
+  private:
+    /**
+     * @brief Send a packet
+     */
+    void SendPacket();
+
+    /**
+     * @brief Get a random interval between min and max
+     * @return Random time interval
+     */
+    Time GetRandomInterval();
+
+    Time m_minInterval;         //!< Minimum packet sending interval
+    Time m_maxInterval;         //!< Maximum packet sending interval
+    Time m_initialDelay;        //!< Initial delay before starting transmissions
+    uint8_t m_packetSize;       //!< Size of packets to send
+    Address m_dstAddr;          //!< Destination address (Mac16Address or Mac64Address)
+    Ptr<NetDevice> m_netDevice; //!< Network device used for sending
+    EventId m_sendEvent;        //!< Event to schedule the next packet sending
+    bool m_noSendFlag;          //!< Flag to indicate if the application should not send packets
+
+    Ptr<TimeDriftApplier> m_timeDriftApplier;    //!< For randomizing beacon interval
+    Ptr<UniformRandomVariable> m_randomVariable; //!< Random variable for interval generation
+
+    TracedCallback<Ptr<const Packet>> m_txTrace; //!< Trace of transmitted packets
+    TracedCallback<Ptr<const Packet>> m_rxTrace; //!< Trace of received packets
+};
+
+} // namespace lrwpan
+} // namespace ns3
diff --git a/src/rit-wpan/examples/rit-grid-converge.cc b/src/rit-wpan/examples/rit-grid-converge.cc
new file mode 100644
index 0000000..7c9d9ed
--- /dev/null
+++ b/src/rit-wpan/examples/rit-grid-converge.cc
@@ -0,0 +1,488 @@
+/*
+ * Copyright (c) 2025 Tomoya Murata
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Author:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+/*
+ * This example provides a reference scenario for verifying the basic operation of the
+ * RIT-WPAN MAC implementation in a grid-like multi-hop topology.
+ *
+ * Notes:
+ *  - This scenario is intended for functional validation and trace collection.
+ *  - It is not intended for performance evaluation or scalability studies.
+ */
+
+#include "ns3/core-module.h"
+#include "ns3/mobility-module.h"
+#include "ns3/network-module.h"
+#include "ns3/rng-seed-manager.h"
+
+#include "ns3/mac16-address.h"
+#include "ns3/periodic-sender-helper.h"
+#include "ns3/random-sender-helper.h"
+#include "ns3/rit-rank-helper.h"
+#include "ns3/rit-wpan-helper.h"
+#include "ns3/rit-wpan-net-device.h"
+
+#include <cstdint>
+#include <string>
+#include <vector>
+
+using namespace ns3;
+using namespace lrwpan;
+
+NS_LOG_COMPONENT_DEFINE("RitGridConverge");
+
+namespace
+{
+
+std::string
+MakeScenarioType(const std::string& placement, const std::string& density, const std::string& app)
+{
+    return placement + "_" + density + "_" + app;
+}
+
+struct ScenarioConfig
+{
+    // RIT parameters (interpreted as milliseconds in the CLI as in the original code)
+    double beaconIntervalMs = 5.0;     // BI
+    double dataWaitDurationMs = 10.0;  // DWD
+    double txWaitDurationMs = 5000.0;  // TWD
+
+    // Topology / run control
+    int32_t routerNodeCount = 12; // Nodes (if -1, derived from placement/density)
+    uint32_t simulationDays = 1;
+    double driftRatio = 10.0;
+    uint32_t randomSeed = 1;
+
+    // MAC module toggles
+    bool dataCsmaEnabled = true;
+    bool beaconCsmaEnabled = false;
+    bool dataPreCsEnabled = false;
+    bool beaconPreCsEnabled = true;
+    bool dataPreCsBEnabled = false;
+    bool beaconPreCsBEnabled = false;
+    bool continuousTxEnabled = false;
+    bool beaconRandomizeEnabled = false;
+    bool compactRitDataRequestEnabled = false;
+    bool beaconAckEnabled = false;
+
+    // Scenario variants
+    std::string nodePlacement = "edge"; // "edge" or "center"
+    std::string nodeDensity = "low";    // "low" or "middle"
+    std::string appType = "periodic";   // "periodic" or "random"
+
+    // Application parameters
+    uint32_t appPacketSize = 8;
+    uint32_t appPeriodicIntervalSec = 300;
+    uint32_t appRandomMinIntervalSec = 180;
+    uint32_t appRandomMaxIntervalSec = 600;
+};
+
+void
+BindCommandLine(CommandLine& cmd, ScenarioConfig& cfg)
+{
+    cmd.AddValue("BI", "Beacon interval (milliseconds)", cfg.beaconIntervalMs);
+    cmd.AddValue("TWD", "Sender wait duration (milliseconds)", cfg.txWaitDurationMs);
+    cmd.AddValue("DWD", "Receiver data wait duration (milliseconds)", cfg.dataWaitDurationMs);
+
+    cmd.AddValue("Nodes", "Number of router nodes (-1: auto)", cfg.routerNodeCount);
+    cmd.AddValue("Days", "Simulation duration in days", cfg.simulationDays);
+    cmd.AddValue("DR", "Drift ratio", cfg.driftRatio);
+    cmd.AddValue("Seed", "Random seed", cfg.randomSeed);
+
+    cmd.AddValue("DataCsma", "Enable CSMA for data transmission", cfg.dataCsmaEnabled);
+    cmd.AddValue("BeaconCsma", "Enable CSMA for beacon transmission", cfg.beaconCsmaEnabled);
+    cmd.AddValue("DataPreCs", "Enable Pre-CS for data transmission", cfg.dataPreCsEnabled);
+    cmd.AddValue("BeaconPreCs", "Enable Pre-CS for beacon transmission", cfg.beaconPreCsEnabled);
+    cmd.AddValue("DataPreCsB", "Enable Pre-CSB for data transmission", cfg.dataPreCsBEnabled);
+    cmd.AddValue("BeaconPreCsB", "Enable Pre-CSB for beacon transmission", cfg.beaconPreCsBEnabled);
+
+    cmd.AddValue("ContinuousTx", "Enable continuous transmission mode", cfg.continuousTxEnabled);
+    cmd.AddValue("BeaconRandomize", "Enable beacon interval randomization", cfg.beaconRandomizeEnabled);
+    cmd.AddValue("CompactRitDataRequest",
+                 "Enable compact RIT Data Request header",
+                 cfg.compactRitDataRequestEnabled);
+    cmd.AddValue("BeaconAck", "Enable ACK for beacon transmission", cfg.beaconAckEnabled);
+
+    cmd.AddValue("Placement", "Node placement type (edge/center)", cfg.nodePlacement);
+    cmd.AddValue("Density", "Node density type (low/middle)", cfg.nodeDensity);
+    cmd.AddValue("App", "Application type (periodic/random)", cfg.appType);
+
+    cmd.AddValue("AppPeriodicInterval",
+                 "Interval for periodic application (seconds)",
+                 cfg.appPeriodicIntervalSec);
+    cmd.AddValue("AppRandomMinInterval",
+                 "Minimum interval for random application (seconds)",
+                 cfg.appRandomMinIntervalSec);
+    cmd.AddValue("AppRandomMaxInterval",
+                 "Maximum interval for random application (seconds)",
+                 cfg.appRandomMaxIntervalSec);
+    cmd.AddValue("AppPacketSize", "Packet size for application (bytes)", cfg.appPacketSize);
+}
+
+void
+ResolveRouterNodeCount(ScenarioConfig& cfg)
+{
+    if (cfg.routerNodeCount != -1)
+    {
+        return;
+    }
+
+    if (cfg.nodePlacement == "edge")
+    {
+        if (cfg.nodeDensity == "low")
+        {
+            cfg.routerNodeCount = 15;
+        }
+        else if (cfg.nodeDensity == "middle")
+        {
+            cfg.routerNodeCount = 45;
+        }
+        else
+        {
+            NS_FATAL_ERROR("Unsupported node density for edge placement: " << cfg.nodeDensity);
+        }
+        return;
+    }
+
+    if (cfg.nodePlacement == "center")
+    {
+        if (cfg.nodeDensity == "low")
+        {
+            cfg.routerNodeCount = 8;
+        }
+        else if (cfg.nodeDensity == "middle")
+        {
+            cfg.routerNodeCount = 48;
+        }
+        else
+        {
+            NS_FATAL_ERROR("Unsupported node density for center placement: " << cfg.nodeDensity);
+        }
+        return;
+    }
+
+    NS_FATAL_ERROR("Unsupported node placement: " << cfg.nodePlacement);
+}
+
+Time
+EffectiveParentBeaconInterval(const ScenarioConfig& cfg)
+{
+    // Preserve the original special-cases exactly.
+    if (cfg.nodePlacement == "edge" && cfg.nodeDensity == "middle")
+    {
+        return MilliSeconds(cfg.beaconIntervalMs / 2.5);
+    }
+    if (cfg.nodePlacement == "center" && cfg.nodeDensity == "middle")
+    {
+        return MilliSeconds(cfg.beaconIntervalMs / 4.0);
+    }
+    return MilliSeconds(cfg.beaconIntervalMs);
+}
+
+RitWpanMacModuleConfig
+MakeModuleConfig(const ScenarioConfig& cfg)
+{
+    RitWpanMacModuleConfig m;
+    m.dataCsmaEnabled = cfg.dataCsmaEnabled;
+    m.dataPreCsEnabled = cfg.dataPreCsEnabled;
+    m.dataPreCsBEnabled = cfg.dataPreCsBEnabled;
+
+    m.beaconCsmaEnabled = cfg.beaconCsmaEnabled;
+    m.beaconPreCsEnabled = cfg.beaconPreCsEnabled;
+    m.beaconPreCsBEnabled = cfg.beaconPreCsBEnabled;
+
+    m.continuousTxEnabled = cfg.continuousTxEnabled;
+    m.beaconRandomizeEnabled = cfg.beaconRandomizeEnabled;
+    m.compactRitDataRequestEnabled = cfg.compactRitDataRequestEnabled;
+    m.beaconAckEnabled = cfg.beaconAckEnabled;
+    return m;
+}
+
+void
+InstallTopologyEdge(const ScenarioConfig& cfg, NodeContainer routers, NodeContainer parent)
+{
+    if (cfg.nodeDensity == "low")
+    {
+        // 12 nodes (3x4), 70 m spacing
+        auto positionAlloc = CreateObject<GridPositionAllocator>();
+        positionAlloc->SetMinX(0.0);
+        positionAlloc->SetMinY(0.0);
+        positionAlloc->SetDeltaX(70.0);
+        positionAlloc->SetDeltaY(70.0);
+        positionAlloc->SetN(3);
+        positionAlloc->SetLayoutType(GridPositionAllocator::ROW_FIRST);
+
+        MobilityHelper mob;
+        mob.SetPositionAllocator(positionAlloc);
+        mob.SetMobilityModel("ns3::ConstantPositionMobilityModel");
+        mob.Install(routers);
+
+        RitWpanRankHelper rankHelper;
+        rankHelper.Install(routers, 3);
+    }
+    else if (cfg.nodeDensity == "middle")
+    {
+        // 45 nodes, 25 m spacing, ranks provided explicitly
+        auto positionAlloc = CreateObject<GridPositionAllocator>();
+        positionAlloc->SetMinX(0.0);
+        positionAlloc->SetMinY(0.0);
+        positionAlloc->SetDeltaX(25.0);
+        positionAlloc->SetDeltaY(25.0);
+        positionAlloc->SetN(5);
+        positionAlloc->SetLayoutType(GridPositionAllocator::ROW_FIRST);
+
+        MobilityHelper mob;
+        mob.SetPositionAllocator(positionAlloc);
+        mob.SetMobilityModel("ns3::ConstantPositionMobilityModel");
+        mob.Install(routers);
+
+        const std::vector<uint8_t> middleRanks = {
+            1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4,
+            4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5
+        };
+
+        RitWpanRankHelper rankHelper;
+        rankHelper.Install(routers, middleRanks);
+    }
+    else
+    {
+        NS_FATAL_ERROR("Unsupported node density for edge placement: " << cfg.nodeDensity);
+    }
+
+    // Parent is always placed above the top edge (same as original).
+    double parentX = 0.0;
+    double parentY = 0.0;
+
+    if (cfg.nodeDensity == "low")
+    {
+        parentX = 70.0;
+        parentY = -70.0;
+    }
+    else if (cfg.nodeDensity == "middle")
+    {
+        parentX = 40.0;
+        parentY = -50.0;
+    }
+    else if (cfg.nodeDensity == "high")
+    {
+        // Kept for parity with the original code path (even if high is not used currently).
+        parentX = 2 * 10.0;
+        parentY = -10.0;
+    }
+
+    auto parentPos = CreateObject<ListPositionAllocator>();
+    parentPos->Add(Vector(parentX, parentY, 0.0));
+
+    MobilityHelper parentMob;
+    parentMob.SetPositionAllocator(parentPos);
+    parentMob.SetMobilityModel("ns3::ConstantPositionMobilityModel");
+    parentMob.Install(parent);
+}
+
+void
+InstallTopologyCenter(const ScenarioConfig& cfg, NodeContainer routers, NodeContainer parent)
+{
+    double spacing = 0.0;
+    double row = 5.0;
+    double parentX = 0.0;
+    double parentY = 0.0;
+    std::vector<uint8_t> ranks;
+
+    if (cfg.nodeDensity == "low")
+    {
+        // Original code aborts here. Keep the behavior.
+        spacing = 30.0;
+        row = 5.0;
+        NS_FATAL_ERROR("Unsupported node density for center placement: "
+                       << cfg.nodeDensity << cfg.nodePlacement);
+    }
+    else if (cfg.nodeDensity == "middle")
+    {
+        spacing = 40.0;
+        row = 7.0;
+        ranks = {
+            3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 3, 3, 2, 1, 1, 1, 2, 3, 3, 2, 1, 0,
+            1, 2, 3, 3, 2, 1, 1, 1, 2, 3, 3, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
+        };
+        parentX = 3 * spacing;
+        parentY = 3 * spacing;
+    }
+    else
+    {
+        NS_FATAL_ERROR("Unsupported node density for center placement: " << cfg.nodeDensity);
+    }
+
+    auto positionAlloc = CreateObject<GridPositionAllocator>();
+    positionAlloc->SetMinX(0.0);
+    positionAlloc->SetMinY(0.0);
+    positionAlloc->SetDeltaX(spacing);
+    positionAlloc->SetDeltaY(spacing);
+    positionAlloc->SetN(row);
+    positionAlloc->SetLayoutType(GridPositionAllocator::ROW_FIRST);
+
+    MobilityHelper mob;
+    mob.SetPositionAllocator(positionAlloc);
+    mob.SetMobilityModel("ns3::ConstantPositionMobilityModel");
+    mob.Install(routers);
+
+    RitWpanRankHelper rankHelper;
+    rankHelper.Install(routers, ranks);
+
+    auto parentPos = CreateObject<ListPositionAllocator>();
+    parentPos->Add(Vector(parentX, parentY, 0.0));
+
+    MobilityHelper parentMob;
+    parentMob.SetPositionAllocator(parentPos);
+    parentMob.SetMobilityModel("ns3::ConstantPositionMobilityModel");
+    parentMob.Install(parent);
+}
+
+void
+InstallApplications(const ScenarioConfig& cfg, NodeContainer routers, NodeContainer parent)
+{
+    const Mac16Address sink("00:00");
+
+    if (cfg.appType == "periodic")
+    {
+        PeriodicSenderHelper routerApp;
+        routerApp.SetPeriod(Seconds(cfg.appPeriodicIntervalSec));
+        routerApp.SetPacketSize(cfg.appPacketSize);
+        routerApp.SetDstAddr(sink);
+        routerApp.Install(routers);
+
+        PeriodicSenderHelper parentApp;
+        parentApp.SetReceiveOnly(true);
+        parentApp.Install(parent);
+        return;
+    }
+
+    if (cfg.appType == "random")
+    {
+        RandomSenderHelper routerApp;
+        routerApp.SetMinInterval(Seconds(cfg.appRandomMinIntervalSec));
+        routerApp.SetMaxInterval(Seconds(cfg.appRandomMaxIntervalSec));
+        routerApp.SetPacketSize(cfg.appPacketSize);
+        routerApp.SetDstAddr(sink);
+        routerApp.Install(routers);
+
+        RandomSenderHelper parentApp;
+        parentApp.SetReceiveOnly(true);
+        parentApp.Install(parent);
+        return;
+    }
+
+    NS_FATAL_ERROR("Unsupported application type: " << cfg.appType);
+}
+
+void
+PrintRunSummary(const ScenarioConfig& cfg, const std::string& scenarioType)
+{
+    NS_LOG_UNCOND("==== Simulation parameters ====");
+    NS_LOG_UNCOND("ScenarioType: " << scenarioType
+                                  << " | BI: " << cfg.beaconIntervalMs << " ms"
+                                  << " | DWD: " << cfg.dataWaitDurationMs << " ms"
+                                  << " | TWD: " << cfg.txWaitDurationMs << " ms"
+                                  << " | Nodes: " << cfg.routerNodeCount
+                                  << " | Days: " << cfg.simulationDays
+                                  << " | DR: " << cfg.driftRatio
+                                  << " | Seed: " << cfg.randomSeed
+                                  << " | DataCsma: " << (cfg.dataCsmaEnabled ? "true" : "false")
+                                  << " | BeaconCsma: " << (cfg.beaconCsmaEnabled ? "true" : "false")
+                                  << " | DataPreCs: " << (cfg.dataPreCsEnabled ? "true" : "false")
+                                  << " | BeaconPreCs: " << (cfg.beaconPreCsEnabled ? "true" : "false")
+                                  << " | ContinuousTx: " << (cfg.continuousTxEnabled ? "true" : "false")
+                                  << " | BeaconRandomize: " << (cfg.beaconRandomizeEnabled ? "true" : "false")
+                                  << " | CompactRitDataRequest: "
+                                  << (cfg.compactRitDataRequestEnabled ? "true" : "false")
+                                  << " | BeaconAck: " << (cfg.beaconAckEnabled ? "true" : "false")
+                                  << " | Placement: " << cfg.nodePlacement
+                                  << " | Density: " << cfg.nodeDensity
+                                  << " | App: " << cfg.appType);
+}
+
+} // namespace
+
+int
+main(int argc, char* argv[])
+{
+    LogComponentEnableAll(LOG_PREFIX_TIME);
+
+    ScenarioConfig cfg;
+
+    CommandLine cmd;
+    BindCommandLine(cmd, cfg);
+    cmd.Parse(argc, argv);
+
+    ResolveRouterNodeCount(cfg);
+    RngSeedManager::SetSeed(cfg.randomSeed);
+
+    const std::string scenarioType = MakeScenarioType(cfg.nodePlacement, cfg.nodeDensity, cfg.appType);
+
+    // ----- Node creation -----
+    NodeContainer parentNodes;
+    NodeContainer routerNodes;
+    NodeContainer allNodes;
+    parentNodes.Create(1);
+    routerNodes.Create(cfg.routerNodeCount);
+    allNodes.Add(parentNodes);
+    allNodes.Add(routerNodes);
+
+    // ----- Device installation -----
+    RitWpanNetHelper helper;
+
+    helper.SetMacRitDataWaitDuration(MilliSeconds(cfg.dataWaitDurationMs));
+    helper.SetMacRitTxWaitDuration(MilliSeconds(cfg.txWaitDurationMs));
+    helper.SetRitMacDriftRatio(cfg.driftRatio);
+    helper.SetRitMacModuleConfig(MakeModuleConfig(cfg));
+
+    // Parent: RxAlwaysOn = true with an effective BI (preserve original behavior)
+    helper.SetMacRitPeriod(EffectiveParentBeaconInterval(cfg));
+    helper.SetRxAlwaysOn(true);
+    NetDeviceContainer parentDevices = helper.Install(parentNodes);
+
+    // Routers: RxAlwaysOn = false with baseline BI (preserve original behavior)
+    helper.SetMacRitPeriod(MilliSeconds(cfg.beaconIntervalMs));
+    helper.SetRxAlwaysOn(false);
+    NetDeviceContainer routerDevices = helper.Install(routerNodes);
+
+    // ----- Mobility / ranks -----
+    if (cfg.nodePlacement == "edge")
+    {
+        InstallTopologyEdge(cfg, routerNodes, parentNodes);
+    }
+    else if (cfg.nodePlacement == "center")
+    {
+        InstallTopologyCenter(cfg, routerNodes, parentNodes);
+    }
+    else
+    {
+        NS_FATAL_ERROR("Unsupported node placement: " << cfg.nodePlacement);
+    }
+
+    // ----- Parent device metadata -----
+    auto parentDev = DynamicCast<RitWpanNetDevice>(parentDevices.Get(0));
+    parentDev->SetAddress(Mac16Address("00:00"));
+    parentDev->SetRitRank(0);
+
+    // ----- Applications -----
+    InstallApplications(cfg, routerNodes, parentNodes);
+
+    // ----- Traces -----
+    helper.SetScenarioType(scenarioType);
+    helper.EnableAllTracesPerNode(allNodes, cfg.simulationDays, cfg.randomSeed);
+
+    // ----- Run -----
+    PrintRunSummary(cfg, scenarioType);
+    NS_LOG_UNCOND("Simulation starts.");
+    Simulator::Stop(Days(cfg.simulationDays));
+    Simulator::Run();
+    Simulator::Destroy();
+
+    return 0;
+}
diff --git a/src/rit-wpan/examples/rit-wpan-data.cc b/src/rit-wpan/examples/rit-wpan-data.cc
new file mode 100644
index 0000000..a9b8944
--- /dev/null
+++ b/src/rit-wpan/examples/rit-wpan-data.cc
@@ -0,0 +1,147 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+/*
+ * This file provides a minimal test scenario for verifying the basic operation of
+ * the RIT-WPAN MAC implementation, including:
+ *  - RIT (Receiver-Initiated Transmission) operation
+ *
+ * This scenario is intended for functional validation and debugging purposes only.
+ * It is NOT designed for performance evaluation or large-scale simulation studies.
+ */
+
+#include "ns3/rit-wpan-mac.h"
+#include "ns3/rit-wpan-net-device.h"
+#include "ns3/rit-wpan-nwk-header.h"
+
+#include <ns3/core-module.h>
+#include <ns3/lr-wpan-module.h>
+#include <ns3/mobility-module.h>
+#include <ns3/network-module.h>
+#include <ns3/single-model-spectrum-channel.h>
+
+using namespace ns3;
+using namespace ns3::lrwpan;
+
+/*
+ * Data indication callback.
+ * This handler is invoked when a packet is successfully received.
+ * In this test scenario, the callback only logs the reception event.
+ */
+bool
+DataIndication(Ptr<NetDevice> netDevice,
+               Ptr<const Packet> packet,
+               uint16_t x,
+               const Address& addr)
+{
+    NS_LOG_UNCOND("DataIndication: received " << packet->GetSize() << " bytes");
+    return true; // Indicate that the packet has been handled
+}
+
+int
+main(int argc, char** argv)
+{
+    /*
+     * Enable logging output for debugging.
+     */
+    LogComponentEnableAll(LOG_PREFIX_TIME);
+    LogComponentEnable("RitWpanMac", LOG_LEVEL_DEBUG);
+    // LogComponentEnable("LrWpanMac", LOG_LEVEL_DEBUG);
+    // LogComponentEnable("LrWpanPhy", LOG_LEVEL_DEBUG);
+
+    /*
+     * 1. Create nodes.
+     */
+    Ptr<Node> senderNode = CreateObject<Node>();
+    Ptr<Node> receiverNode = CreateObject<Node>();
+
+    /*
+     * 2. Create RIT-WPAN net devices for each node.
+     */
+    Ptr<RitWpanNetDevice> senderDevice = CreateObject<RitWpanNetDevice>();
+    Ptr<RitWpanNetDevice> receiverDevice = CreateObject<RitWpanNetDevice>();
+
+    /*
+     * 3. Configure MAC addresses.
+     */
+    senderDevice->SetAddress(Mac16Address("00:01"));
+    receiverDevice->SetAddress(Mac16Address("00:02"));
+
+    /*
+     * 4. Create a wireless channel and propagation models.
+     */
+    Ptr<SingleModelSpectrumChannel> channel = CreateObject<SingleModelSpectrumChannel>();
+    Ptr<LogDistancePropagationLossModel> propModel =
+        CreateObject<LogDistancePropagationLossModel>();
+    Ptr<ConstantSpeedPropagationDelayModel> delayModel =
+        CreateObject<ConstantSpeedPropagationDelayModel>();
+    channel->AddPropagationLossModel(propModel);
+    channel->SetPropagationDelayModel(delayModel);
+
+    senderDevice->SetChannel(channel);
+    receiverDevice->SetChannel(channel);
+
+    /*
+     * 5. Attach devices to nodes.
+     */
+    senderNode->AddDevice(senderDevice);
+    receiverNode->AddDevice(receiverDevice);
+
+    /*
+     * 6. Register the receive callback on the receiver device.
+     */
+    receiverDevice->SetReceiveCallback(MakeCallback(&DataIndication));
+
+    /*
+     * 7. Enable RIT operation via MLME-SET.
+     *    The RIT period is configured through the MAC PIB attribute.
+     *    Both sender and receiver must be configured consistently.
+     */
+    Ptr<MacPibAttributes> pibAttr = Create<MacPibAttributes>();
+    pibAttr->macRitPeriod = 65; // RIT period (unit depends on MAC design; approx. 1 second)
+    MacPibAttributeIdentifier id = macRitPeriod;
+
+    senderDevice->GetMac()->MlmeSetRequest(id, pibAttr);
+    receiverDevice->GetMac()->MlmeSetRequest(id, pibAttr);
+
+    /*
+     * 8. Prepare a test data packet and MCPS-DATA.request parameters.
+     */
+    Ptr<Packet> packet = Create<Packet>(50); // 50-byte payload
+    McpsDataRequestParams params;
+    params.m_dstAddr = Mac16Address("00:02"); // Destination address
+    params.m_msduHandle = 0;                  // Arbitrary handle
+    params.m_txOptions = 0;                   // No special options
+
+    /*
+     * 9. Attach a simple RIT network header.
+     */
+    RitNwkHeader nwkHdr;
+    nwkHdr.SetDstAddr(Mac16Address("00:02"));
+    nwkHdr.SetRank(1);
+    packet->AddHeader(nwkHdr);
+
+    /*
+     * 10. Schedule a single data transmission after initialization.
+     *     The transmission time is chosen to avoid startup transients.
+     */
+    Simulator::ScheduleWithContext(senderNode->GetId(),
+                                   Seconds(8.0),
+                                   &RitWpanMac::McpsDataRequest,
+                                   senderDevice->GetMac(),
+                                   params,
+                                   packet);
+
+    /*
+     * 11. Run the simulation.
+     */
+    Simulator::Stop(Seconds(10.0));
+    Simulator::Run();
+    Simulator::Destroy();
+    return 0;
+}
diff --git a/src/rit-wpan/helper/periodic-sender-helper.cc b/src/rit-wpan/helper/periodic-sender-helper.cc
new file mode 100644
index 0000000..71ff439
--- /dev/null
+++ b/src/rit-wpan/helper/periodic-sender-helper.cc
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#include "periodic-sender-helper.h"
+
+#include "ns3/double.h"
+#include "ns3/log.h"
+#include "ns3/periodic-sender.h"
+#include "ns3/random-variable-stream.h"
+#include "ns3/rit-wpan-net-device.h"
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+NS_LOG_COMPONENT_DEFINE("PeriodicSenderHelper");
+
+PeriodicSenderHelper::PeriodicSenderHelper()
+    : m_period(Seconds(60)),
+      m_pktSize(20),
+      m_dstAddr(),
+      m_receiveOnly(false)
+{
+    m_factory.SetTypeId("ns3::lrwpan::PeriodicSender");
+
+    m_initialDelay = CreateObject<UniformRandomVariable>();
+    m_initialDelay->SetAttribute("Min", DoubleValue(0.0));
+}
+
+void
+PeriodicSenderHelper::SetAttribute(std::string name, const AttributeValue& value)
+{
+    m_factory.Set(name, value);
+}
+
+ApplicationContainer
+PeriodicSenderHelper::Install(Ptr<Node> node) const
+{
+    return ApplicationContainer(InstallPriv(node));
+}
+
+ApplicationContainer
+PeriodicSenderHelper::Install(NodeContainer c) const
+{
+    ApplicationContainer apps;
+    for (auto i = c.Begin(); i != c.End(); ++i)
+    {
+        apps.Add(InstallPriv(*i));
+    }
+    return apps;
+}
+
+Ptr<Application>
+PeriodicSenderHelper::InstallPriv(Ptr<Node> node) const
+{
+    Ptr<PeriodicSender> app = m_factory.Create<PeriodicSender>();
+    app->SetNode(node);
+
+    // Register receive callback to the first RitWpanNetDevice found on the node
+    for (uint32_t i = 0; i < node->GetNDevices(); ++i)
+    {
+        if (auto dev = DynamicCast<RitWpanNetDevice>(node->GetDevice(i)))
+        {
+            dev->SetReceiveCallback(
+                MakeCallback(&PeriodicSender::ReceivePacket, app));
+            break;
+        }
+    }
+
+    if (m_receiveOnly)
+    {
+        // Receive-only mode: no periodic transmission is scheduled
+        app->SetReceiveOnly(true);
+        node->AddApplication(app);
+        return app;
+    }
+
+    app->SetInterval(m_period);
+    app->SetInitialDelay(
+        Seconds(m_initialDelay->GetValue(0.0, m_period.GetSeconds())));
+    app->SetPacketSize(m_pktSize);
+    app->SetDstAddr(m_dstAddr);
+
+    node->AddApplication(app);
+    return app;
+}
+
+void
+PeriodicSenderHelper::SetPeriod(Time period)
+{
+    m_period = period;
+}
+
+void
+PeriodicSenderHelper::SetPacketSize(uint8_t size)
+{
+    m_pktSize = size;
+}
+
+void
+PeriodicSenderHelper::SetDstAddr(const Address& addr)
+{
+    m_dstAddr = addr;
+}
+
+void
+PeriodicSenderHelper::SetReceiveOnly(bool enable)
+{
+    m_receiveOnly = enable;
+}
+
+} // namespace lrwpan
+} // namespace ns3
diff --git a/src/rit-wpan/helper/periodic-sender-helper.h b/src/rit-wpan/helper/periodic-sender-helper.h
new file mode 100644
index 0000000..dff8dbf
--- /dev/null
+++ b/src/rit-wpan/helper/periodic-sender-helper.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#ifndef PERIODIC_SENDER_HELPER_H
+#define PERIODIC_SENDER_HELPER_H
+
+#include "ns3/application-container.h"
+#include "ns3/attribute.h"
+#include "ns3/node-container.h"
+#include "ns3/object-factory.h"
+
+#include <cstdint>
+#include <string>
+
+namespace ns3
+{
+
+class UniformRandomVariable;
+
+namespace lrwpan
+{
+
+/**
+ * @ingroup lrwpan
+ *
+ * Helper to install PeriodicSender applications on nodes.
+ */
+class PeriodicSenderHelper
+{
+  public:
+    PeriodicSenderHelper();
+    ~PeriodicSenderHelper();
+
+    /**
+     * Set an attribute on the underlying PeriodicSender application.
+     */
+    void SetAttribute(std::string name, const AttributeValue& value);
+
+    ApplicationContainer Install(NodeContainer c) const;
+    ApplicationContainer Install(Ptr<Node> node) const;
+
+    void SetPeriod(Time period);
+    void SetPacketSize(uint8_t size);
+    void SetDstAddr(const Address& addr);
+
+    /**
+     * Enable receive-only mode (no periodic transmission).
+     */
+    void SetReceiveOnly(bool enable);
+
+  private:
+    Ptr<Application> InstallPriv(Ptr<Node> node) const;
+
+    ObjectFactory m_factory;
+
+    Ptr<UniformRandomVariable> m_initialDelay;
+
+    Time m_period;
+    uint8_t m_pktSize;
+    Address m_dstAddr;
+    bool m_receiveOnly;
+};
+
+} // namespace lrwpan
+} // namespace ns3
+
+#endif // PERIODIC_SENDER_HELPER_H
\ No newline at end of file
diff --git a/src/rit-wpan/helper/random-sender-helper.cc b/src/rit-wpan/helper/random-sender-helper.cc
new file mode 100644
index 0000000..a9db51a
--- /dev/null
+++ b/src/rit-wpan/helper/random-sender-helper.cc
@@ -0,0 +1,127 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+ #include "random-sender-helper.h"
+
+#include "ns3/double.h"
+#include "ns3/log.h"
+#include "ns3/random-sender.h"
+#include "ns3/random-variable-stream.h"
+#include "ns3/rit-wpan-net-device.h"
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+NS_LOG_COMPONENT_DEFINE("RandomSenderHelper");
+
+RandomSenderHelper::RandomSenderHelper()
+    : m_minInterval(Seconds(180)),
+      m_maxInterval(Seconds(600)),
+      m_pktSize(20),
+      m_dstAddr(),
+      m_receiveOnly(false)
+{
+    m_factory.SetTypeId("ns3::lrwpan::RandomSender");
+
+    m_initialDelay = CreateObject<UniformRandomVariable>();
+    m_initialDelay->SetAttribute("Min", DoubleValue(0.0));
+}
+
+void
+RandomSenderHelper::SetAttribute(std::string name, const AttributeValue& value)
+{
+    m_factory.Set(name, value);
+}
+
+ApplicationContainer
+RandomSenderHelper::Install(Ptr<Node> node) const
+{
+    return ApplicationContainer(InstallPriv(node));
+}
+
+ApplicationContainer
+RandomSenderHelper::Install(NodeContainer c) const
+{
+    ApplicationContainer apps;
+    for (auto i = c.Begin(); i != c.End(); ++i)
+    {
+        apps.Add(InstallPriv(*i));
+    }
+    return apps;
+}
+
+Ptr<Application>
+RandomSenderHelper::InstallPriv(Ptr<Node> node) const
+{
+    Ptr<RandomSender> app = m_factory.Create<RandomSender>();
+    app->SetNode(node);
+
+    // Register receive callback to the first RitWpanNetDevice found on the node
+    for (uint32_t i = 0; i < node->GetNDevices(); ++i)
+    {
+        if (auto dev = DynamicCast<RitWpanNetDevice>(node->GetDevice(i)))
+        {
+            dev->SetReceiveCallback(
+                MakeCallback(&RandomSender::ReceivePacket, app));
+            break;
+        }
+    }
+
+    if (m_receiveOnly)
+    {
+        // Receive-only mode: no random transmission is scheduled
+        app->SetReceiveOnly(true);
+        node->AddApplication(app);
+        return app;
+    }
+
+    app->SetMinInterval(m_minInterval);
+    app->SetMaxInterval(m_maxInterval);
+    app->SetInitialDelay(
+        Seconds(m_initialDelay->GetValue(0.0, m_maxInterval.GetSeconds())));
+    app->SetPacketSize(m_pktSize);
+    app->SetDstAddr(m_dstAddr);
+
+    node->AddApplication(app);
+    return app;
+}
+
+void
+RandomSenderHelper::SetMinInterval(Time minInterval)
+{
+    m_minInterval = minInterval;
+}
+
+void
+RandomSenderHelper::SetMaxInterval(Time maxInterval)
+{
+    m_maxInterval = maxInterval;
+}
+
+void
+RandomSenderHelper::SetPacketSize(uint8_t size)
+{
+    m_pktSize = size;
+}
+
+void
+RandomSenderHelper::SetDstAddr(const Address& addr)
+{
+    m_dstAddr = addr;
+}
+
+void
+RandomSenderHelper::SetReceiveOnly(bool enable)
+{
+    m_receiveOnly = enable;
+}
+
+} // namespace lrwpan
+} // namespace ns3
diff --git a/src/rit-wpan/helper/random-sender-helper.h b/src/rit-wpan/helper/random-sender-helper.h
new file mode 100644
index 0000000..04a66c5
--- /dev/null
+++ b/src/rit-wpan/helper/random-sender-helper.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#ifndef RANDOM_SENDER_HELPER_H
+#define RANDOM_SENDER_HELPER_H
+
+#include "ns3/address.h"
+#include "ns3/application-container.h"
+#include "ns3/attribute.h"
+#include "ns3/node-container.h"
+#include "ns3/nstime.h"
+#include "ns3/object-factory.h"
+
+#include <cstdint>
+#include <string>
+
+namespace ns3
+{
+
+class UniformRandomVariable;
+
+namespace lrwpan
+{
+
+/**
+ * @ingroup lrwpan
+ *
+ * Helper to install RandomSender applications on nodes.
+ */
+class RandomSenderHelper
+{
+  public:
+    RandomSenderHelper();
+    ~RandomSenderHelper();
+
+    /**
+     * Set an attribute on the underlying RandomSender application.
+     */
+    void SetAttribute(std::string name, const AttributeValue& value);
+
+    ApplicationContainer Install(NodeContainer c) const;
+    ApplicationContainer Install(Ptr<Node> node) const;
+
+    void SetMinInterval(Time minInterval);
+    void SetMaxInterval(Time maxInterval);
+    void SetPacketSize(uint8_t size);
+    void SetDstAddr(const Address& addr);
+
+    /**
+     * Enable receive-only mode (no random transmission).
+     */
+    void SetReceiveOnly(bool enable);
+
+  private:
+    Ptr<Application> InstallPriv(Ptr<Node> node) const;
+
+    ObjectFactory m_factory;
+
+    Time m_minInterval;
+    Time m_maxInterval;
+    uint8_t m_pktSize;
+    Address m_dstAddr;
+    bool m_receiveOnly;
+
+    Ptr<UniformRandomVariable> m_initialDelay;
+};
+
+} // namespace lrwpan
+} // namespace ns3
+
+#endif // RANDOM_SENDER_HELPER_H
diff --git a/src/rit-wpan/helper/rit-rank-helper.cc b/src/rit-wpan/helper/rit-rank-helper.cc
new file mode 100644
index 0000000..af85172
--- /dev/null
+++ b/src/rit-wpan/helper/rit-rank-helper.cc
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#include "rit-rank-helper.h"
+
+#include "ns3/log.h"
+#include "ns3/rit-wpan-net-device.h"
+
+#include <vector>
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+NS_LOG_COMPONENT_DEFINE("RitWpanRankHelper");
+
+namespace
+{
+
+Ptr<RitWpanNetDevice>
+FindRitWpanDevice(Ptr<Node> node)
+{
+    for (uint32_t i = 0; i < node->GetNDevices(); ++i)
+    {
+        if (auto dev = DynamicCast<RitWpanNetDevice>(node->GetDevice(i)))
+        {
+            return dev;
+        }
+    }
+    return nullptr;
+}
+
+bool
+HasNonZeroRank(const std::vector<uint8_t>& ranks)
+{
+    for (auto r : ranks)
+    {
+        if (r != 0)
+        {
+            return true;
+        }
+    }
+    return false;
+}
+
+} // namespace
+
+RitWpanRankHelper::RitWpanRankHelper() = default;
+RitWpanRankHelper::~RitWpanRankHelper() = default;
+
+void
+RitWpanRankHelper::Install(NodeContainer c, uint8_t gridSizeX) const
+{
+    if (gridSizeX == 0)
+    {
+        NS_LOG_WARN("gridSizeX is 0. No ranks will be set.");
+        return;
+    }
+
+    uint16_t nodeId = 1;
+    for (auto i = c.Begin(); i != c.End(); ++i, ++nodeId)
+    {
+        Ptr<Node> node = *i;
+        auto dev = FindRitWpanDevice(node);
+        if (!dev)
+        {
+            NS_LOG_WARN("Node " << nodeId << " has no RitWpanNetDevice. Skipping.");
+            continue;
+        }
+
+        // Rank assignment for grid-like router placement:
+        // rank = floor((nodeId-1)/gridSizeX) + 1
+        const uint8_t rank = static_cast<uint8_t>((nodeId - 1) / gridSizeX + 1);
+        dev->SetRitRank(rank);
+        dev->SetAddress(nodeId);
+    }
+}
+
+void
+RitWpanRankHelper::Install(NodeContainer c, const std::vector<uint8_t>& rankList) const
+{
+    if (rankList.empty())
+    {
+        NS_LOG_WARN("Empty rank list. No ranks will be set.");
+        return;
+    }
+    if (!HasNonZeroRank(rankList))
+    {
+        NS_LOG_WARN("Rank list contains only zeros. No ranks will be set.");
+        return;
+    }
+
+    uint32_t assigned = 0;
+    uint32_t rankIndex = 0;
+    uint16_t nodeId = 1;
+
+    for (auto i = c.Begin(); i != c.End(); ++i, ++nodeId)
+    {
+        Ptr<Node> node = *i;
+        auto dev = FindRitWpanDevice(node);
+        if (!dev)
+        {
+            NS_LOG_WARN("Node " << nodeId << " has no RitWpanNetDevice. Skipping.");
+            continue;
+        }
+
+        // Select the next non-zero rank (cycle through the list if needed)
+        uint8_t rank = 0;
+        for (uint32_t tries = 0; tries < rankList.size(); ++tries)
+        {
+            rank = rankList[rankIndex % rankList.size()];
+            ++rankIndex;
+            if (rank != 0)
+            {
+                break;
+            }
+        }
+
+        if (rank == 0)
+        {
+            NS_LOG_WARN("Failed to select a non-zero rank for node " << nodeId << ". Skipping.");
+            continue;
+        }
+
+        dev->SetRitRank(rank);
+        dev->SetAddress(nodeId);
+        ++assigned;
+    }
+
+    NS_LOG_INFO("Assigned ranks to " << assigned << " nodes (rankList size=" << rankList.size()
+                                     << ").");
+}
+
+} // namespace lrwpan
+} // namespace ns3
diff --git a/src/rit-wpan/helper/rit-rank-helper.h b/src/rit-wpan/helper/rit-rank-helper.h
new file mode 100644
index 0000000..7499c1d
--- /dev/null
+++ b/src/rit-wpan/helper/rit-rank-helper.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#ifndef NS3_RIT_WPAN_RANK_HELPER_H
+#define NS3_RIT_WPAN_RANK_HELPER_H
+
+#ifndef NS3_RIT_WPAN_RANK_HELPER_H
+#define NS3_RIT_WPAN_RANK_HELPER_H
+
+#include "ns3/node-container.h"
+
+#include <cstdint>
+#include <vector>
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+/**
+ * Helper to assign RIT rank values to RitWpanNetDevice instances on nodes.
+ *
+ * Note: This helper assumes ranks are used as routing-layer metadata in experiments.
+ */
+class RitWpanRankHelper
+{
+  public:
+    RitWpanRankHelper();
+    ~RitWpanRankHelper();
+
+    RitWpanRankHelper(const RitWpanRankHelper&) = delete;
+    RitWpanRankHelper& operator=(const RitWpanRankHelper&) = delete;
+
+    /**
+     * Assign ranks assuming router nodes are placed on a grid.
+     *
+     * Rank is computed from the node order in the container:
+     * rank = floor((nodeId-1)/gridSizeX) + 1
+     */
+    void Install(NodeContainer c, uint8_t gridSizeX) const;
+
+    /**
+     * Assign ranks using a user-provided list.
+     * Ranks are assigned in order, cycling through the list if needed.
+     * A rank value of 0 is treated as invalid and skipped.
+     */
+    void Install(NodeContainer c, const std::vector<uint8_t>& rankList) const;
+};
+
+} // namespace lrwpan
+} // namespace ns3
+
+#endif // NS3_RIT_WPAN_RANK_HELPER_H
diff --git a/src/rit-wpan/helper/rit-wpan-helper.cc b/src/rit-wpan/helper/rit-wpan-helper.cc
new file mode 100644
index 0000000..e2de233
--- /dev/null
+++ b/src/rit-wpan/helper/rit-wpan-helper.cc
@@ -0,0 +1,1142 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#include "rit-wpan-helper.h"
+
+#include "periodic-sender-helper.h"
+
+#include "ns3/names.h"
+#include "ns3/periodic-sender.h"
+#include "ns3/random-sender.h"
+#include "ns3/rit-wpan-mac.h"
+#include "ns3/rit-wpan-net-device.h"
+#include "ns3/rit-wpan-nwk-header.h"
+#include <ns3/log.h>
+#include <ns3/lr-wpan-csmaca.h>
+#include <ns3/lr-wpan-error-model.h>
+#include <ns3/lr-wpan-net-device.h>
+#include <ns3/mobility-model.h>
+#include <ns3/multi-model-spectrum-channel.h>
+#include <ns3/propagation-delay-model.h>
+#include <ns3/propagation-loss-model.h>
+#include <ns3/single-model-spectrum-channel.h>
+
+#include <filesystem>
+#include <iostream>
+#include <sstream>
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+NS_LOG_COMPONENT_DEFINE("RitWpanNetHelper");
+
+RitWpanNetHelper::RitWpanNetHelper()
+{
+}
+
+RitWpanNetHelper::~RitWpanNetHelper()
+{
+    m_channel->Dispose();
+    m_channel = nullptr;
+}
+
+void
+RitWpanNetHelper::AddMobility(Ptr<LrWpanPhy> phy, Ptr<MobilityModel> m)
+{
+    phy->SetMobility(m);
+}
+
+// TODO: complete implementation
+NetDeviceContainer
+RitWpanNetHelper::Install(NodeContainer c)
+{
+    if (!m_channel)
+    {
+        m_channel = CreateObject<SingleModelSpectrumChannel>();
+        Ptr<LogDistancePropagationLossModel> propModel =
+            CreateObject<LogDistancePropagationLossModel>();
+        Ptr<ConstantSpeedPropagationDelayModel> delayModel =
+            CreateObject<ConstantSpeedPropagationDelayModel>();
+        m_channel->AddPropagationLossModel(propModel);
+        m_channel->SetPropagationDelayModel(delayModel);
+    }
+
+    NetDeviceContainer devices;
+    for (auto i = c.Begin(); i != c.End(); i++)
+    {
+        Ptr<Node> node = *i;
+
+        Ptr<RitWpanNetDevice> netDevice = CreateObject<RitWpanNetDevice>();
+        netDevice->SetChannel(m_channel);
+
+        Ptr<RitWpanMac> ritMac = DynamicCast<RitWpanMac>(netDevice->GetMac());
+        Ptr<MacPibAttributes> pibAttr = Create<MacPibAttributes>();
+
+        ritMac->SetRxAlwaysOn(m_rxAlwaysOn);
+
+        // RIT parameters
+        // mac RIT data wait duration
+        netDevice->SetMacRitPeriod(m_macRitPeriod);
+        netDevice->SetMacRitDataWaitDuration(m_macRitDataWaitDuration);
+        netDevice->SetMacRitTxWaitDuration(m_macRitTxWaitDuration);
+        netDevice->SetRitModuleConfig(m_moduleConfig);
+
+        node->AddDevice(netDevice);
+        netDevice->SetNode(node);
+        devices.Add(netDevice);
+    }
+    return devices;
+}
+
+Ptr<SpectrumChannel>
+RitWpanNetHelper::GetChannel()
+{
+    return m_channel;
+}
+
+void
+RitWpanNetHelper::SetChannel(Ptr<SpectrumChannel> channel)
+{
+    m_channel = channel;
+}
+
+void
+RitWpanNetHelper::SetChannel(std::string channelName)
+{
+    Ptr<SpectrumChannel> channel = Names::Find<SpectrumChannel>(channelName);
+    m_channel = channel;
+}
+
+void
+RitWpanNetHelper::SetMacRitPeriod(Time macRitPeriod)
+{
+    m_macRitPeriod = macRitPeriod; // Beacon interval
+}
+
+void
+RitWpanNetHelper::SetMacRitDataWaitDuration(Time macRitDataWaitDuration)
+{
+    m_macRitDataWaitDuration = macRitDataWaitDuration; // [Rx] Data wait duration after beacon
+}
+
+void
+RitWpanNetHelper::SetMacRitTxWaitDuration(Time macRitTxWaitDuration)
+{
+    m_macRitTxWaitDuration = macRitTxWaitDuration; // [Tx] Wait duration before data transmission
+}
+
+void
+RitWpanNetHelper::SetRitMacDriftRatio(double riMacDriftRatio)
+{
+    m_riMacDriftRatio = riMacDriftRatio; // Set drift ratio for RIT MAC
+}
+
+void
+RitWpanNetHelper::SetRitMacModuleConfig(const RitWpanMacModuleConfig& config)
+{
+    m_moduleConfig = config; // RIT MAC module configuration
+}
+
+void
+RitWpanNetHelper::SetRxAlwaysOn(bool alwaysOn)
+{
+    m_rxAlwaysOn = alwaysOn; // Set receiver always-on flag
+}
+
+// Hook function for MacState events
+void
+RitWpanNetHelper::AsciiRitWpanMacStateSink(Ptr<OutputStreamWrapper> stream,
+                                           uint32_t nodeId,
+                                           lrwpan::MacState oldState,
+                                           lrwpan::MacState newState)
+{
+    *stream->GetStream() << Simulator::Now().GetSeconds() << "," << newState << std::endl;
+}
+
+// Hook function for energy events
+void
+RitWpanNetHelper::AsciiRitWpanEnergySink(Ptr<OutputStreamWrapper> stream,
+                                         uint32_t nodeId,
+                                         double energy)
+{
+    *stream->GetStream() << Simulator::Now().GetSeconds() << "," << energy << std::endl;
+}
+
+// Hook function for PHY state trace
+void
+RitWpanNetHelper::AsciiRitWpanPhyStateSink(Ptr<OutputStreamWrapper> stream,
+                                           uint32_t nodeId,
+                                           Time time,
+                                           PhyEnumeration oldState,
+                                           PhyEnumeration newState)
+{
+    *stream->GetStream() << time.GetSeconds() << "," << newState << std::endl;
+}
+
+// Automated method to trace MacState only per node
+void
+RitWpanNetHelper::EnableTracePerNode(
+    const NodeContainer& nodes,
+    const std::string& baseDir,
+    const std::string& logName,
+    std::function<void(Ptr<Node>, Ptr<OutputStreamWrapper>)> traceSetupFn)
+{
+    for (uint32_t i = 0; i < nodes.GetN(); ++i)
+    {
+        Ptr<Node> node = nodes.Get(i);
+        uint32_t nodeId = node->GetId();
+        Ptr<OutputStreamWrapper> stream = GetNodeLogStream(baseDir, nodeId, logName);
+        traceSetupFn(node, stream);
+    }
+}
+
+void
+RitWpanNetHelper::EnableMacStateTracePerNode(const NodeContainer& nodes, const std::string& baseDir)
+{
+    EnableTracePerNode(nodes,
+                       baseDir,
+                       "mac-statelog.csv",
+                       [](Ptr<Node> node, Ptr<OutputStreamWrapper> stream) {
+                           uint32_t nodeId = node->GetId();
+                           for (uint32_t j = 0; j < node->GetNDevices(); ++j)
+                           {
+                               Ptr<NetDevice> rawDev = node->GetDevice(j);
+                               Ptr<RitWpanNetDevice> dev = DynamicCast<RitWpanNetDevice>(rawDev);
+                               if (!dev)
+                               {
+                                   continue;
+                               }
+                               Ptr<RitWpanMac> mac = dev->GetMac();
+                               if (!mac)
+                               {
+                                   continue;
+                               }
+                               mac->TraceConnectWithoutContext(
+                                   "MacState",
+                                   MakeBoundCallback(&AsciiRitWpanMacStateSink, stream, nodeId));
+                           }
+                       });
+}
+
+// Automated helper method to trace per-node energy consumption and depletion events
+void
+RitWpanNetHelper::EnableEnergyTracePerNode(const NodeContainer& nodes, const std::string& baseDir)
+{
+    EnableTracePerNode(nodes,
+                       baseDir,
+                       "energy-node.log",
+                       [](Ptr<Node> node, Ptr<OutputStreamWrapper> stream) {
+                           uint32_t nodeId = node->GetId();
+                           for (uint32_t j = 0; j < node->GetNDevices(); ++j)
+                           {
+                               Ptr<RitWpanNetDevice> dev =
+                                   DynamicCast<RitWpanNetDevice>(node->GetDevice(j));
+                               if (!dev)
+                               {
+                                   continue;
+                               }
+                               dev->TraceConnectWithoutContext(
+                                   "EnergyDepletion",
+                                   MakeBoundCallback(&AsciiRitWpanEnergySink, stream, nodeId));
+                           }
+                       });
+}
+
+// Automated helper method to enable per-node PHY state tracing
+void
+RitWpanNetHelper::EnablePhyStateTracePerNode(const NodeContainer& nodes, const std::string& baseDir)
+{
+    NS_LOG_DEBUG("[DEBUG] Enabling PHY state trace for nodes in " << baseDir);
+    EnableTracePerNode(
+        nodes,
+        baseDir,
+        "phy-statelog.csv",
+        [](Ptr<Node> node, Ptr<OutputStreamWrapper> stream) {
+            uint32_t nodeId = node->GetId();
+            for (uint32_t j = 0; j < node->GetNDevices(); ++j)
+            {
+                Ptr<RitWpanNetDevice> dev = DynamicCast<RitWpanNetDevice>(node->GetDevice(j));
+                if (!dev)
+                {
+                    // NS_LOG_DEBUG("[DEBUG] Enabling PHY state trace for nodes in " << baseDir);
+                    NS_LOG_DEBUG("[DEBUG] Device " << j << " is not a RitWpanNetDevice, skipping.");
+                    continue;
+                }
+                Ptr<LrWpanPhy> phy = dev->GetPhy();
+
+                if (!phy)
+                {
+                    NS_LOG_DEBUG("[DEBUG] PHY is not set for device " << j << " in node "
+                                                                      << nodeId);
+                    continue;
+                }
+                phy->TraceConnectWithoutContext(
+                    "TrxState",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanPhyStateSink, stream, nodeId));
+                NS_LOG_DEBUG("[DEBUG] PHY state trace enabled for device " << j << " in node "
+                                                                           << nodeId);
+            }
+        });
+}
+
+// Hook function for NWK-layer TX logging
+void
+RitWpanNetHelper::AsciiRitWpanNwkTxSink(Ptr<OutputStreamWrapper> stream,
+                                        std::string event,
+                                        Ptr<const Packet> pkt)
+{
+    RitNwkHeader hdr;
+    if (!pkt->PeekHeader(hdr))
+    {
+        return;
+    }
+
+    std::ostringstream srcNwkStream;
+    std::ostringstream dstNwkStream;
+
+    srcNwkStream << hdr.GetSrcAddr();
+    dstNwkStream << hdr.GetDstAddr();
+
+    std::string srcNwk = srcNwkStream.str();
+    std::string dstNwk = dstNwkStream.str();
+    NS_LOG_DEBUG("RitWpanNetHelper::AsciiRitWpanNwkTxSink: "
+                 << "time=" << Simulator::Now().GetSeconds() << ", event=" << event
+                 << ", srcNwk=" << srcNwk << ", dstNwk=" << dstNwk);
+    *stream->GetStream() << Simulator::Now().GetSeconds() << "," << event << "," << srcNwk << ","
+                         << dstNwk << "," << pkt->GetUid() << std::endl;
+}
+
+// Hook function for MAC-layer RX logging
+void
+RitWpanNetHelper::AsciiRitWpanNwkRxSink(Ptr<OutputStreamWrapper> stream,
+                                        std::string event,
+                                        Ptr<const Packet> pkt)
+{
+    RitNwkHeader hdr;
+    if (!pkt->PeekHeader(hdr))
+    {
+        return;
+    }
+
+    std::ostringstream srcNwkStream;
+    std::ostringstream dstNwkStream;
+
+    srcNwkStream << hdr.GetSrcAddr();
+    dstNwkStream << hdr.GetDstAddr();
+
+    std::string srcNwk = srcNwkStream.str();
+    std::string dstNwk = dstNwkStream.str();
+    NS_LOG_DEBUG("RitWpanNetHelper::AsciiRitWpanNwkRxSink: "
+                 << "time=" << Simulator::Now().GetSeconds() << ", event=" << event
+                 << ", srcNwk=" << srcNwk << ", dstNwk=" << dstNwk);
+    *stream->GetStream() << Simulator::Now().GetSeconds() << "," << event << "," << srcNwk << ","
+                         << dstNwk << "," << pkt->GetUid() << std::endl;
+}
+
+void
+RitWpanNetHelper::EnableNwkTxTracePerNode(const NodeContainer& nodes, const std::string& baseDir)
+{
+    EnableTracePerNode(
+        nodes,
+        baseDir,
+        "nwk-txlog.csv",
+        [](Ptr<Node> node, Ptr<OutputStreamWrapper> stream) {
+            for (uint32_t j = 0; j < node->GetNDevices(); ++j)
+            {
+                Ptr<RitWpanNetDevice> dev = DynamicCast<RitWpanNetDevice>(node->GetDevice(j));
+                if (!dev)
+                {
+                    continue;
+                }
+                Ptr<RitSimpleRouting> nwk = dev->GetNwk();
+                if (!nwk)
+                {
+                    continue;
+                }
+                nwk->TraceConnectWithoutContext(
+                    "NwkTx",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanNwkTxSink, stream, "Tx"));
+                nwk->TraceConnectWithoutContext(
+                    "NwkTxOk",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanNwkTxSink, stream, "TxOk"));
+                nwk->TraceConnectWithoutContext(
+                    "NwkTxDrop",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanNwkTxSink, stream, "TxDrop"));
+                nwk->TraceConnectWithoutContext(
+                    "NwkReTx",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanNwkTxSink, stream, "ReTx"));
+            }
+        });
+}
+
+void
+RitWpanNetHelper::EnableNwkRxTracePerNode(const NodeContainer& nodes, const std::string& baseDir)
+{
+    EnableTracePerNode(
+        nodes,
+        baseDir,
+        "nwk-rxlog.csv",
+        [](Ptr<Node> node, Ptr<OutputStreamWrapper> stream) {
+            for (uint32_t j = 0; j < node->GetNDevices(); ++j)
+            {
+                Ptr<RitWpanNetDevice> dev = DynamicCast<RitWpanNetDevice>(node->GetDevice(j));
+                if (!dev)
+                {
+                    continue;
+                }
+                Ptr<RitSimpleRouting> nwk = dev->GetNwk();
+                if (!nwk)
+                {
+                    continue;
+                }
+                nwk->TraceConnectWithoutContext(
+                    "NwkRx",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanNwkRxSink, stream, "RxOk"));
+                nwk->TraceConnectWithoutContext(
+                    "NwkRxDrop",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanNwkRxSink, stream, "RxDrop"));
+            }
+        });
+}
+
+// Hook function for MAC-layer TX logging
+void
+RitWpanNetHelper::AsciiRitWpanMacTxSink(Ptr<OutputStreamWrapper> stream,
+                                        std::string event,
+                                        Ptr<const Packet> pkt)
+{
+    LrWpanMacHeader hdr;
+    if (!pkt->PeekHeader(hdr))
+    {
+        return;
+    }
+    std::string frameType;
+    switch (hdr.GetType())
+    {
+    case LrWpanMacHeader::LRWPAN_MAC_BEACON:
+        frameType = "Beacon";
+        break;
+    case LrWpanMacHeader::LRWPAN_MAC_DATA:
+        frameType = "Data";
+        break;
+    case LrWpanMacHeader::LRWPAN_MAC_ACKNOWLEDGMENT:
+        frameType = "Ack";
+        break;
+    case LrWpanMacHeader::LRWPAN_MAC_COMMAND:
+        frameType = "Command";
+        break;
+    case LrWpanMacHeader::LRWPAN_MAC_MULTIPURPOSE:
+        frameType = "Multipurpose";
+        break;
+    default:
+        frameType = "Unknown";
+        break;
+    }
+    std::ostringstream srcMacStream;
+    std::ostringstream dstMacStream;
+    if (hdr.GetSrcAddrMode() == SHORT_ADDR)
+    {
+        srcMacStream << hdr.GetShortSrcAddr();
+    }
+    else if (hdr.GetSrcAddrMode() == EXT_ADDR)
+    {
+        srcMacStream << hdr.GetExtSrcAddr();
+    }
+    else
+    {
+        srcMacStream << "ff:ff";
+    }
+    if (hdr.GetDstAddrMode() == SHORT_ADDR)
+    {
+        dstMacStream << hdr.GetShortDstAddr();
+    }
+    else if (hdr.GetDstAddrMode() == EXT_ADDR)
+    {
+        dstMacStream << hdr.GetExtDstAddr();
+    }
+    else
+    {
+        dstMacStream << "ff:ff";
+    }
+    std::string srcMac = srcMacStream.str();
+    std::string dstMac = dstMacStream.str();
+    NS_LOG_DEBUG("RitWpanNetHelper::AsciiRitWpanMacTxSink: "
+                 << "time=" << Simulator::Now().GetSeconds() << ", event=" << event
+                 << ", frameType=" << frameType << ", srcMac=" << srcMac << ", dstMac=" << dstMac);
+    *stream->GetStream() << Simulator::Now().GetSeconds() << "," << event << "," << frameType << ","
+                         << srcMac << "," << dstMac << std::endl;
+}
+
+// Hook function for MAC-layer RX logging
+void
+RitWpanNetHelper::AsciiRitWpanMacRxSink(Ptr<OutputStreamWrapper> stream,
+                                        std::string event,
+                                        Ptr<const Packet> pkt)
+{
+    LrWpanMacHeader hdr;
+    if (!pkt->PeekHeader(hdr))
+    {
+        return;
+    }
+    std::string frameType;
+    switch (hdr.GetType())
+    {
+    case LrWpanMacHeader::LRWPAN_MAC_BEACON:
+        frameType = "Beacon";
+        break;
+    case LrWpanMacHeader::LRWPAN_MAC_DATA:
+        frameType = "Data";
+        break;
+    case LrWpanMacHeader::LRWPAN_MAC_ACKNOWLEDGMENT:
+        frameType = "Ack";
+        break;
+    case LrWpanMacHeader::LRWPAN_MAC_COMMAND:
+        frameType = "Command";
+        break;
+    case LrWpanMacHeader::LRWPAN_MAC_MULTIPURPOSE:
+        frameType = "Multipurpose";
+        break;
+    default:
+        frameType = "Unknown";
+        break;
+    }
+    std::ostringstream srcMacStream;
+    std::ostringstream dstMacStream;
+    if (hdr.GetSrcAddrMode() == SHORT_ADDR)
+    {
+        srcMacStream << hdr.GetShortSrcAddr();
+    }
+    else if (hdr.GetSrcAddrMode() == EXT_ADDR)
+    {
+        srcMacStream << hdr.GetExtSrcAddr();
+    }
+    else
+    {
+        srcMacStream << "ff:ff";
+    }
+    if (hdr.GetDstAddrMode() == SHORT_ADDR)
+    {
+        dstMacStream << hdr.GetShortDstAddr();
+    }
+    else if (hdr.GetDstAddrMode() == EXT_ADDR)
+    {
+        dstMacStream << hdr.GetExtDstAddr();
+    }
+    else
+    {
+        dstMacStream << "ff:ff";
+    }
+    std::string srcMac = srcMacStream.str();
+    std::string dstMac = dstMacStream.str();
+    *stream->GetStream() << Simulator::Now().GetSeconds() << "," << event << "," << frameType << ","
+                         << srcMac << "," << dstMac << std::endl;
+}
+
+void
+RitWpanNetHelper::EnableMacTxTracePerNode(const NodeContainer& nodes, const std::string& baseDir)
+{
+    EnableTracePerNode(
+        nodes,
+        baseDir,
+        "mac-txlog.csv",
+        [](Ptr<Node> node, Ptr<OutputStreamWrapper> stream) {
+            for (uint32_t j = 0; j < node->GetNDevices(); ++j)
+            {
+                Ptr<RitWpanNetDevice> dev = DynamicCast<RitWpanNetDevice>(node->GetDevice(j));
+                if (!dev)
+                {
+                    continue;
+                }
+                Ptr<RitWpanMac> mac = dev->GetMac();
+                if (!mac)
+                {
+                    continue;
+                }
+                mac->TraceConnectWithoutContext(
+                    "MacTx",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanMacTxSink, stream, "Tx"));
+                mac->TraceConnectWithoutContext(
+                    "MacTxOk",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanMacTxSink, stream, "TxOk"));
+                mac->TraceConnectWithoutContext(
+                    "MacTxDrop",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanMacTxSink, stream, "TxDrop"));
+            }
+        });
+}
+
+void
+RitWpanNetHelper::EnableMacRxTracePerNode(const NodeContainer& nodes, const std::string& baseDir)
+{
+    EnableTracePerNode(
+        nodes,
+        baseDir,
+        "mac-rxlog.csv",
+        [](Ptr<Node> node, Ptr<OutputStreamWrapper> stream) {
+            for (uint32_t j = 0; j < node->GetNDevices(); ++j)
+            {
+                Ptr<RitWpanNetDevice> dev = DynamicCast<RitWpanNetDevice>(node->GetDevice(j));
+                if (!dev)
+                {
+                    continue;
+                }
+                Ptr<RitWpanMac> mac = dev->GetMac();
+                if (!mac)
+                {
+                    continue;
+                }
+                mac->TraceConnectWithoutContext(
+                    "MacRx",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanMacRxSink, stream, "RxOk"));
+                mac->TraceConnectWithoutContext(
+                    "MacRxDrop",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanMacRxSink, stream, "RxDrop"));
+            }
+        });
+}
+
+// Hook function for PHY-layer TX/RX logging
+void
+RitWpanNetHelper::AsciiRitWpanPhyTxSink(Ptr<OutputStreamWrapper> stream,
+                                        std::string event,
+                                        Ptr<const Packet> pkt)
+{
+    LrWpanMacHeader hdr;
+    if (!pkt->PeekHeader(hdr))
+    {
+        return;
+    }
+    std::ostringstream dstMacStream;
+    if (hdr.GetDstAddrMode() == SHORT_ADDR)
+    {
+        dstMacStream << hdr.GetShortDstAddr();
+    }
+    else if (hdr.GetDstAddrMode() == EXT_ADDR)
+    {
+        dstMacStream << hdr.GetExtDstAddr();
+    }
+    else
+    {
+        dstMacStream << "ff:ff";
+    }
+    std::string dstMac = dstMacStream.str();
+    NS_LOG_DEBUG("RitWpanNetHelper::AsciiRitWpanPhyTxSink: "
+                 << "time=" << Simulator::Now().GetSeconds() << ", event=" << event
+                 << ", dstMac=" << dstMac);
+    *stream->GetStream() << Simulator::Now().GetSeconds() << "," << event << "," << dstMac
+                         << std::endl;
+}
+
+// Hook function for PHY-layer RX logging (without SINR)
+void
+RitWpanNetHelper::AsciiRitWpanPhyRxSink(Ptr<OutputStreamWrapper> stream,
+                                        std::string event,
+                                        Ptr<const Packet> pkt)
+{
+    LrWpanMacHeader hdr;
+    std::ostringstream srcMacStream;
+    if (pkt && pkt->PeekHeader(hdr))
+    {
+        if (hdr.GetSrcAddrMode() == SHORT_ADDR)
+        {
+            srcMacStream << hdr.GetShortSrcAddr();
+        }
+        else if (hdr.GetSrcAddrMode() == EXT_ADDR)
+        {
+            srcMacStream << hdr.GetExtSrcAddr();
+        }
+        else
+        {
+            srcMacStream << "ff:ff";
+        }
+    }
+    std::string srcMac = srcMacStream.str();
+    *stream->GetStream() << Simulator::Now().GetSeconds() << "," << event << "," << srcMac
+                         << std::endl;
+}
+
+// Hook function for PHY-layer RX logging (with SINR)
+void
+RitWpanNetHelper::AsciiRitWpanPhyRxSink(Ptr<OutputStreamWrapper> stream,
+                                        std::string event,
+                                        Ptr<const Packet> pkt,
+                                        double sinr)
+{
+    LrWpanMacHeader hdr;
+    std::ostringstream srcMacStream;
+    if (pkt && pkt->PeekHeader(hdr))
+    {
+        if (hdr.GetSrcAddrMode() == SHORT_ADDR)
+        {
+            srcMacStream << hdr.GetShortSrcAddr();
+        }
+        else if (hdr.GetSrcAddrMode() == EXT_ADDR)
+        {
+            srcMacStream << hdr.GetExtSrcAddr();
+        }
+        else
+        {
+            srcMacStream << "ff:ff";
+        }
+    }
+    std::string srcMac = srcMacStream.str();
+    *stream->GetStream() << Simulator::Now().GetSeconds() << "," << event << "," << srcMac << ","
+                        //  << sinr
+                         << std::endl;
+}
+
+void
+RitWpanNetHelper::EnablePhyTxTracePerNode(const NodeContainer& nodes, const std::string& baseDir)
+{
+    EnableTracePerNode(
+        nodes,
+        baseDir,
+        "phy-txlog.csv",
+        [](Ptr<Node> node, Ptr<OutputStreamWrapper> stream) {
+            for (uint32_t j = 0; j < node->GetNDevices(); ++j)
+            {
+                Ptr<RitWpanNetDevice> dev = DynamicCast<RitWpanNetDevice>(node->GetDevice(j));
+                if (!dev)
+                {
+                    continue;
+                }
+                Ptr<LrWpanPhy> phy = dev->GetPhy();
+                if (!phy)
+                {
+                    continue;
+                }
+                phy->TraceConnectWithoutContext(
+                    "PhyTxBegin",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanPhyTxSink, stream, "TxBegin"));
+                phy->TraceConnectWithoutContext(
+                    "PhyTxEnd",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanPhyTxSink, stream, "TxEnd"));
+                phy->TraceConnectWithoutContext(
+                    "PhyTxDrop",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanPhyTxSink, stream, "TxDrop"));
+            }
+        });
+}
+
+void
+RitWpanNetHelper::EnablePhyRxTracePerNode(const NodeContainer& nodes, const std::string& baseDir)
+{
+    EnableTracePerNode(
+        nodes,
+        baseDir,
+        "phy-rxlog.csv",
+        [](Ptr<Node> node, Ptr<OutputStreamWrapper> stream) {
+            for (uint32_t j = 0; j < node->GetNDevices(); ++j)
+            {
+                Ptr<RitWpanNetDevice> dev = DynamicCast<RitWpanNetDevice>(node->GetDevice(j));
+                if (!dev)
+                {
+                    continue;
+                }
+                Ptr<LrWpanPhy> phy = dev->GetPhy();
+                if (!phy)
+                {
+                    continue;
+                }
+                phy->TraceConnectWithoutContext(
+                    "PhyRxBegin",
+                    MakeBoundCallback(
+                        static_cast<
+                            void (*)(Ptr<OutputStreamWrapper>, std::string, Ptr<const Packet>)>(
+                            &RitWpanNetHelper::AsciiRitWpanPhyRxSink),
+                        stream,
+                        "RxBegin"));
+                phy->TraceConnectWithoutContext(
+                    "PhyRxEnd",
+                    MakeBoundCallback(
+                        static_cast<void (*)(Ptr<OutputStreamWrapper>,
+                                             std::string,
+                                             Ptr<const Packet>,
+                                             double)>(&RitWpanNetHelper::AsciiRitWpanPhyRxSink),
+                        stream,
+                        "RxEnd"));
+                phy->TraceConnectWithoutContext(
+                    "PhyRxDrop",
+                    MakeBoundCallback(
+                        static_cast<
+                            void (*)(Ptr<OutputStreamWrapper>, std::string, Ptr<const Packet>)>(
+                            &RitWpanNetHelper::AsciiRitWpanPhyRxSink),
+                        stream,
+                        "RxDrop"));
+            }
+        });
+}
+
+void
+RitWpanNetHelper::SetScenarioType(const std::string& scenarioType)
+{
+    m_scenarioType = scenarioType;
+}
+
+std::string
+RitWpanNetHelper::GetScenarioType() const
+{
+    return m_scenarioType;
+}
+
+std::string
+RitWpanNetHelper::GetLogBaseDir(const std::string& module,
+                                uint32_t macRitPeriod,
+                                uint32_t macRitTxWaitDuration,
+                                uint32_t macRitDataWaitDuration,
+                                uint32_t simulationTime,
+                                uint32_t runNumber) const
+{
+    std::ostringstream oss;
+    oss << "logs/" << m_scenarioType << "/" << module << "/"
+        << "BI" << macRitPeriod << "_TWD" << macRitTxWaitDuration << "_DWD"
+        << macRitDataWaitDuration << "_Days" << simulationTime << "/SEED" << std::setw(2)
+        << std::setfill('0') << runNumber << "/";
+    return oss.str();
+}
+
+// Module name utilities
+std::string
+RitWpanNetHelper::GetModuleShortName(const RitWpanMacModuleConfig& config) const
+{
+    std::vector<std::string> tags;
+    // DATA CSMA/CA module
+    if (config.dataCsmaEnabled && config.dataPreCsEnabled)
+    {
+        tags.emplace_back("csma_precs");
+    }
+    else if (config.dataCsmaEnabled)
+    {
+        tags.emplace_back("csma");
+    }
+    else if (config.dataPreCsEnabled)
+    {
+        tags.emplace_back("precs");
+    }
+    else if (config.dataPreCsBEnabled)
+    {
+        tags.emplace_back("precsb");
+    }
+    else
+    {
+        tags.emplace_back("nocsma");
+    }
+    // Beacon CSMA/CA module
+    if (config.beaconCsmaEnabled && config.beaconPreCsEnabled)
+    {
+        tags.emplace_back("bcsma_bprecs");
+    }
+    else if (config.beaconCsmaEnabled)
+    {
+        tags.emplace_back("bcsma");
+    }
+    else if (config.beaconPreCsEnabled)
+    {
+        tags.emplace_back("bprecs");
+    }
+    else if (config.beaconPreCsBEnabled)
+    {
+        tags.emplace_back("bprecsb");
+    }
+    else
+    {
+        tags.emplace_back("bnocsma");
+    }
+    // others
+    if (config.continuousTxEnabled)
+    {
+        tags.emplace_back("cont");
+    }
+    if (config.beaconRandomizeEnabled)
+    {
+        tags.emplace_back("random");
+    }
+    if (config.compactRitDataRequestEnabled)
+    {
+        tags.emplace_back("compact");
+    }
+    if (config.beaconAckEnabled)
+    {
+        tags.emplace_back("back");
+    }
+    // combine
+    std::ostringstream oss;
+    for (size_t i = 0; i < tags.size(); ++i)
+    {
+        if (i > 0)
+        {
+            oss << "_";
+        }
+        oss << tags[i];
+    }
+    return oss.str();
+}
+
+void
+RitWpanNetHelper::EnableAllTracesPerNode(const NodeContainer& nodes,
+                                         uint32_t simulationTime,
+                                         uint32_t seed)
+{
+    // Retrieve parameters
+    std::string moduleName = GetModuleShortName(m_moduleConfig);
+    NS_LOG_UNCOND(moduleName);
+    uint32_t macRitPeriod = m_macRitPeriod.GetMilliSeconds();
+    uint32_t macRitTxWaitDuration = m_macRitTxWaitDuration.GetMilliSeconds();
+    uint32_t macRitDataWaitDuration = m_macRitDataWaitDuration.GetMilliSeconds();
+    uint32_t simulationDays = simulationTime;
+    uint32_t runNumber = seed;
+    std::string baseDir = GetLogBaseDir(moduleName,
+                                        macRitPeriod,
+                                        macRitTxWaitDuration,
+                                        macRitDataWaitDuration,
+                                        simulationDays,
+                                        runNumber);
+    NS_LOG_DEBUG("[DEBUG] Enabling all traces for nodes in " << baseDir);
+    EnableApplicationTracePerNode(nodes, baseDir);
+    EnableMacStateTracePerNode(nodes, baseDir);
+    EnableMacModeTracePerNode(nodes, baseDir);
+    EnableNwkTxTracePerNode(nodes, baseDir);
+    EnableNwkRxTracePerNode(nodes, baseDir);
+    EnableMacTxTracePerNode(nodes, baseDir);
+    EnableMacRxTracePerNode(nodes, baseDir);
+    EnableMacTimeoutTracePerNode(nodes, baseDir);
+    EnablePhyStateTracePerNode(nodes, baseDir);
+    EnablePhyTxTracePerNode(nodes, baseDir);
+    EnablePhyRxTracePerNode(nodes, baseDir);
+    // EnableEnergyTracePerNode(nodes, baseDir);
+}
+
+std::string
+RitWpanNetHelper::GetNodeLogDir(const std::string& baseDir, uint32_t nodeId) const
+{
+    return baseDir + "node-" + std::to_string(nodeId) + "/";
+}
+
+std::string
+RitWpanNetHelper::GetNodeLogFilePath(const std::string& baseDir,
+                                     uint32_t nodeId,
+                                     const std::string& logName) const
+{
+    std::string nodeDir = GetNodeLogDir(baseDir, nodeId);
+    std::filesystem::create_directories(nodeDir);
+    return nodeDir + logName;
+}
+
+Ptr<OutputStreamWrapper>
+RitWpanNetHelper::GetNodeLogStream(const std::string& baseDir,
+                                   uint32_t nodeId,
+                                   const std::string& logName) const
+{
+    std::string filePath = GetNodeLogFilePath(baseDir, nodeId, logName);
+    return Create<OutputStreamWrapper>(filePath, std::ios::out);
+}
+
+void
+RitWpanNetHelper::AsciiApplicationTxSink(Ptr<OutputStreamWrapper> stream, Ptr<const Packet> pkt)
+{
+    *stream->GetStream() << Simulator::Now().GetSeconds() << "," << pkt->GetUid() << std::endl;
+}
+
+void
+RitWpanNetHelper::AsciiApplicationRxSink(Ptr<OutputStreamWrapper> stream, Ptr<const Packet> pkt)
+{
+    *stream->GetStream() << Simulator::Now().GetSeconds() << "," << pkt->GetUid() << std::endl;
+}
+
+void
+RitWpanNetHelper::EnableApplicationTracePerNode(const NodeContainer& nodes,
+                                                const std::string& baseDir)
+{
+    EnableApplicationTxTracePerNode(nodes, baseDir);
+    EnableApplicationRxTracePerNode(nodes, baseDir);
+}
+
+void
+RitWpanNetHelper::EnableApplicationTxTracePerNode(const NodeContainer& nodes,
+                                                  const std::string& baseDir)
+{
+    EnableTracePerNode(
+        nodes,
+        baseDir,
+        "app-txlog.csv",
+        [](Ptr<Node> node, Ptr<OutputStreamWrapper> stream) {
+            if (node->GetNApplications() == 0)
+            {
+                NS_LOG_DEBUG("No Applications found on node "
+                             << node->GetId() << ". Skipping Application Tx trace setup.");
+                return;
+            }
+            Ptr<Application> app = node->GetApplication(0);
+
+            // Try PeriodicSender first
+            Ptr<PeriodicSender> periodicSender = DynamicCast<PeriodicSender>(app);
+            if (periodicSender)
+            {
+                periodicSender->TraceConnectWithoutContext(
+                    "Tx",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiApplicationTxSink, stream));
+                return;
+            }
+
+            // Try RandomSender
+            Ptr<RandomSender> randomSender = DynamicCast<RandomSender>(app);
+            if (randomSender)
+            {
+                randomSender->TraceConnectWithoutContext(
+                    "Tx",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiApplicationTxSink, stream));
+                return;
+            }
+        });
+}
+
+void
+RitWpanNetHelper::EnableApplicationRxTracePerNode(const NodeContainer& nodes,
+                                                  const std::string& baseDir)
+{
+    EnableTracePerNode(
+        nodes,
+        baseDir,
+        "app-rxlog.csv",
+        [](Ptr<Node> node, Ptr<OutputStreamWrapper> stream) {
+            if (node->GetNApplications() == 0)
+            {
+                NS_LOG_DEBUG("No Applications found on node "
+                             << node->GetId() << ". Skipping Application Rx trace setup.");
+                return;
+            }
+            Ptr<Application> app = node->GetApplication(0);
+
+            // Try PeriodicSender first
+            Ptr<PeriodicSender> periodicSender = DynamicCast<PeriodicSender>(app);
+            if (periodicSender)
+            {
+                periodicSender->TraceConnectWithoutContext(
+                    "Rx",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiApplicationRxSink, stream));
+                return;
+            }
+
+            // Try RandomSender
+            Ptr<RandomSender> randomSender = DynamicCast<RandomSender>(app);
+            if (randomSender)
+            {
+                randomSender->TraceConnectWithoutContext(
+                    "Rx",
+                    MakeBoundCallback(&RitWpanNetHelper::AsciiApplicationRxSink, stream));
+                return;
+            }
+        });
+}
+
+// Hook function for MAC timeout events
+void
+RitWpanNetHelper::AsciiRitWpanMacTimeoutSink(Ptr<OutputStreamWrapper> stream,
+                                             std::string event,
+                                             Time timestamp)
+{
+    *stream->GetStream() << timestamp.GetSeconds() << "," << event << std::endl;
+}
+
+void
+RitWpanNetHelper::EnableMacTimeoutTracePerNode(const NodeContainer& nodes,
+                                               const std::string& baseDir)
+{
+    EnableTracePerNode(
+        nodes,
+        baseDir,
+        "mac-beacon-wait.csv",
+        [](Ptr<Node> node, Ptr<OutputStreamWrapper> stream) {
+            Ptr<NetDevice> netDevice = node->GetDevice(0);
+            Ptr<RitWpanNetDevice> ritDevice = DynamicCast<RitWpanNetDevice>(netDevice);
+            if (ritDevice)
+            {
+                Ptr<RitWpanMac> mac = DynamicCast<RitWpanMac>(ritDevice->GetMac());
+                if (mac)
+                {
+                    mac->TraceConnectWithoutContext(
+                        "BeaconWaitEvent",
+                        MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanMacTimeoutSink, stream));
+                }
+            }
+        });
+
+    EnableTracePerNode(
+        nodes,
+        baseDir,
+        "mac-data-wait.csv",
+        [](Ptr<Node> node, Ptr<OutputStreamWrapper> stream) {
+            Ptr<NetDevice> netDevice = node->GetDevice(0);
+            Ptr<RitWpanNetDevice> ritDevice = DynamicCast<RitWpanNetDevice>(netDevice);
+            if (ritDevice)
+            {
+                Ptr<RitWpanMac> mac = DynamicCast<RitWpanMac>(ritDevice->GetMac());
+                if (mac)
+                {
+                    mac->TraceConnectWithoutContext(
+                        "DataWaitEvent",
+                        MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanMacTimeoutSink, stream));
+                }
+            }
+        });
+}
+
+// Hook function for MAC mode events
+void
+RitWpanNetHelper::AsciiRitWpanMacModeSink(Ptr<OutputStreamWrapper> stream,
+                                          RitMacMode oldMode,
+                                          RitMacMode newMode)
+{
+    std::string macMode;
+    switch (newMode)
+    {
+    case RitMacMode::BOOTSTRAP_MODE:
+        macMode = "Bootstrap";
+        break;
+    case RitMacMode::RECEIVER_MODE:
+        macMode = "Receiver";
+        break;
+    case RitMacMode::SLEEP_MODE:
+        macMode = "Sleep";
+        break;
+    case RitMacMode::SENDER_MODE:
+        macMode = "Sender";
+        break;
+    case RitMacMode::RIT_MODE_DISABLED:
+        macMode = "RIT Disabled";
+        break;
+    }
+    *stream->GetStream() << Simulator::Now().GetSeconds() << "," << macMode << std::endl;
+}
+
+void
+RitWpanNetHelper::EnableMacModeTracePerNode(const NodeContainer& nodes, const std::string& baseDir)
+{
+    EnableTracePerNode(
+        nodes,
+        baseDir,
+        "mac-mode.csv",
+        [](Ptr<Node> node, Ptr<OutputStreamWrapper> stream) {
+            Ptr<NetDevice> netDevice = node->GetDevice(0);
+            Ptr<RitWpanNetDevice> ritDevice = DynamicCast<RitWpanNetDevice>(netDevice);
+            if (ritDevice)
+            {
+                Ptr<RitWpanMac> mac = DynamicCast<RitWpanMac>(ritDevice->GetMac());
+                if (mac)
+                {
+                    mac->TraceConnectWithoutContext(
+                        "MacMode",
+                        MakeBoundCallback(&RitWpanNetHelper::AsciiRitWpanMacModeSink, stream));
+                }
+            }
+        });
+}
+} // namespace lrwpan
+} // namespace ns3
diff --git a/src/rit-wpan/helper/rit-wpan-helper.h b/src/rit-wpan/helper/rit-wpan-helper.h
new file mode 100644
index 0000000..8d856fe
--- /dev/null
+++ b/src/rit-wpan/helper/rit-wpan-helper.h
@@ -0,0 +1,231 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#ifndef RIT_WPAN_HELPER_H
+#define RIT_WPAN_HELPER_H
+
+#include "ns3/net-device-container.h"
+#include "ns3/node-container.h"
+#include "ns3/nstime.h"
+#include "ns3/object.h"
+#include "ns3/output-stream-wrapper.h"
+#include "ns3/ptr.h"
+#include "ns3/spectrum-channel.h"
+
+#include "ns3/rit-wpan-mac.h"        // RitMacMode, MacState, module config
+#include "ns3/rit-wpan-net-device.h" // RitWpanNetDevice
+#include "ns3/lr-wpan-phy.h"         // PhyEnumeration (trace sink signature)
+
+#include <functional>
+#include <string>
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+/**
+ * @ingroup lrwpan
+ *
+ * @brief Helper class to install RitWpanNetDevice instances and enable per-node ASCII traces.
+ *
+ * This helper provides:
+ *  - Device installation with a shared SpectrumChannel
+ *  - RIT MAC parameter configuration
+ *  - Convenience methods to enable per-node trace logging (MAC/NWK/PHY/App/etc.)
+ *
+ * Note: This helper is primarily intended for research scenarios and trace collection.
+ */
+class RitWpanNetHelper
+{
+  public:
+    RitWpanNetHelper();
+    ~RitWpanNetHelper();
+
+    RitWpanNetHelper(const RitWpanNetHelper&) = delete;
+    RitWpanNetHelper& operator=(const RitWpanNetHelper&) = delete;
+
+    /** @brief Get the channel used by this helper. */
+    Ptr<SpectrumChannel> GetChannel();
+
+    /** @brief Set the channel used by this helper. */
+    void SetChannel(Ptr<SpectrumChannel> channel);
+
+    /** @brief Set the channel by name (Names::Find<SpectrumChannel>). */
+    void SetChannel(std::string channelName);
+
+    /** @brief Set RIT beacon interval. */
+    void SetMacRitPeriod(Time macRitPeriod);
+
+    /** @brief Set receiver-side data wait duration after beacon. */
+    void SetMacRitDataWaitDuration(Time macRitDataWaitDuration);
+
+    /** @brief Set sender-side wait duration before data transmission. */
+    void SetMacRitTxWaitDuration(Time macRitTxWaitDuration);
+
+    /** @brief Set MAC drift ratio (stored; application to MAC depends on implementation). */
+    void SetRitMacDriftRatio(double riMacDriftRatio);
+
+    /** @brief Set receiver always-on behavior for installed devices. */
+    void SetRxAlwaysOn(bool alwaysOn);
+
+    /**
+     * @brief Attach mobility model to a PHY instance.
+     * @param phy PHY object
+     * @param m Mobility model
+     */
+    void AddMobility(Ptr<LrWpanPhy> phy, Ptr<MobilityModel> m);
+
+    /**
+     * @brief Install RitWpanNetDevice on each node in the container.
+     * @param c Nodes to install devices on
+     * @return Container of installed devices
+     */
+    NetDeviceContainer Install(NodeContainer c);
+
+    /**
+     * @brief Set extended addresses for devices (reserved for future use / compatibility).
+     * @param c NetDeviceContainer
+     */
+    void SetExtendedAddresses(NetDeviceContainer c) {}
+
+    /** @brief Set RIT MAC module configuration. */
+    void SetRitMacModuleConfig(const RitWpanMacModuleConfig& config);
+
+    /**
+     * @brief Generic helper: enable a per-node trace and write to a per-node log file.
+     *
+     * @param nodes Target nodes
+     * @param baseDir Base directory
+     * @param logName Log file name (e.g., "mac-txlog.csv")
+     * @param traceSetupFn Callback that connects trace sources on the node
+     */
+    void EnableTracePerNode(const NodeContainer& nodes,
+                            const std::string& baseDir,
+                            const std::string& logName,
+                            std::function<void(Ptr<Node>, Ptr<OutputStreamWrapper>)> traceSetupFn);
+
+    // Convenience wrappers built on EnableTracePerNode()
+    void EnableMacStateTracePerNode(const NodeContainer& nodes, const std::string& baseDir);
+    void EnableEnergyTracePerNode(const NodeContainer& nodes, const std::string& baseDir);
+    void EnableNwkTxTracePerNode(const NodeContainer& nodes, const std::string& baseDir);
+    void EnableNwkRxTracePerNode(const NodeContainer& nodes, const std::string& baseDir);
+    void EnableMacTxTracePerNode(const NodeContainer& nodes, const std::string& baseDir);
+    void EnableMacRxTracePerNode(const NodeContainer& nodes, const std::string& baseDir);
+    void EnablePhyStateTracePerNode(const NodeContainer& nodes, const std::string& baseDir);
+    void EnableMacTimeoutTracePerNode(const NodeContainer& nodes, const std::string& baseDir);
+    void EnableMacModeTracePerNode(const NodeContainer& nodes, const std::string& baseDir);
+
+    /**
+     * @brief Enable all traces using a precomputed base directory.
+     *
+     * @param nodes Target nodes
+     * @param baseDir Base directory to write logs into
+     * @param seed Run identifier
+     */
+    void EnableAllTracesPerNode(const NodeContainer& nodes, const std::string& baseDir, uint32_t seed);
+
+    /** @brief Build log base directory path from parameters. */
+    std::string GetLogBaseDir(const std::string& module,
+                              uint32_t macRitPeriod,
+                              uint32_t macRitTxWaitDuration,
+                              uint32_t macRitDataWaitDuration,
+                              uint32_t simulationTime,
+                              uint32_t runNumber) const;
+
+    /** @brief Build short module name tag from module configuration. */
+    std::string GetModuleShortName(const RitWpanMacModuleConfig& config) const;
+
+    /** @brief Enable all traces with base directory automatically derived from current settings. */
+    void EnableAllTracesPerNode(const NodeContainer& nodes, uint32_t simulationTime, uint32_t seed);
+
+    // PHY Tx/Rx trace sinks (ASCII)
+    static void AsciiRitWpanPhyTxSink(Ptr<OutputStreamWrapper> stream,
+                                      std::string event,
+                                      Ptr<const Packet> pkt);
+    static void AsciiRitWpanPhyRxSink(Ptr<OutputStreamWrapper> stream,
+                                      std::string event,
+                                      Ptr<const Packet> pkt);
+    static void AsciiRitWpanPhyRxSink(Ptr<OutputStreamWrapper> stream,
+                                      std::string event,
+                                      Ptr<const Packet> pkt,
+                                      double sinr);
+
+    // PHY Tx/Rx trace enablers
+    void EnablePhyTxTracePerNode(const NodeContainer& nodes, const std::string& baseDir);
+    void EnablePhyRxTracePerNode(const NodeContainer& nodes, const std::string& baseDir);
+
+    // Application trace logging (PeriodicSender / RandomSender)
+    void EnableApplicationTxTracePerNode(const NodeContainer& nodes, const std::string& baseDir);
+    void EnableApplicationRxTracePerNode(const NodeContainer& nodes, const std::string& baseDir);
+    static void AsciiApplicationTxSink(Ptr<OutputStreamWrapper> stream, Ptr<const Packet> pkt);
+    static void AsciiApplicationRxSink(Ptr<OutputStreamWrapper> stream, Ptr<const Packet> pkt);
+    void EnableApplicationTracePerNode(const NodeContainer& nodes, const std::string& baseDir);
+
+    /** @brief Set scenario type label used for log directory path. */
+    void SetScenarioType(const std::string& scenarioType);
+
+    /** @brief Get scenario type label used for log directory path. */
+    std::string GetScenarioType() const;
+
+  private:
+    // MAC state sink
+    static void AsciiRitWpanMacStateSink(Ptr<OutputStreamWrapper> stream,
+                                         uint32_t nodeId,
+                                         lrwpan::MacState oldState,
+                                         lrwpan::MacState newState);
+
+    // Energy sink
+    static void AsciiRitWpanEnergySink(Ptr<OutputStreamWrapper> stream, uint32_t nodeId, double energy);
+
+    // NWK sinks
+    static void AsciiRitWpanNwkRxSink(Ptr<OutputStreamWrapper> stream, std::string event, Ptr<const Packet> pkt);
+    static void AsciiRitWpanNwkTxSink(Ptr<OutputStreamWrapper> stream, std::string event, Ptr<const Packet> pkt);
+
+    // MAC sinks
+    static void AsciiRitWpanMacTxSink(Ptr<OutputStreamWrapper> stream, std::string event, Ptr<const Packet> pkt);
+    static void AsciiRitWpanMacRxSink(Ptr<OutputStreamWrapper> stream, std::string event, Ptr<const Packet> pkt);
+
+    // PHY state sink
+    static void AsciiRitWpanPhyStateSink(Ptr<OutputStreamWrapper> stream,
+                                         uint32_t nodeId,
+                                         Time time,
+                                         PhyEnumeration oldState,
+                                         PhyEnumeration newState);
+
+    // MAC timeout sink
+    static void AsciiRitWpanMacTimeoutSink(Ptr<OutputStreamWrapper> stream, std::string event, Time timestamp);
+
+    // MAC mode sink
+    static void AsciiRitWpanMacModeSink(Ptr<OutputStreamWrapper> stream, RitMacMode oldMode, RitMacMode newMode);
+
+    // Per-node log helpers
+    std::string GetNodeLogDir(const std::string& baseDir, uint32_t nodeId) const;
+    std::string GetNodeLogFilePath(const std::string& baseDir,
+                                   uint32_t nodeId,
+                                   const std::string& logName) const;
+    Ptr<OutputStreamWrapper> GetNodeLogStream(const std::string& baseDir,
+                                              uint32_t nodeId,
+                                              const std::string& logName) const;
+
+    Ptr<SpectrumChannel> m_channel;
+    Time m_macRitPeriod;
+    Time m_macRitDataWaitDuration;
+    Time m_macRitTxWaitDuration;
+    double m_riMacDriftRatio = 0.0;
+    bool m_rxAlwaysOn = false;
+    RitWpanMacModuleConfig m_moduleConfig;
+
+    std::string m_baseLogDirectory;
+    std::string m_scenarioType = "default";
+};
+
+} // namespace lrwpan
+} // namespace ns3
+
+#endif // RIT_WPAN_HELPER_H
diff --git a/src/rit-wpan/model/clock-drift-applier.cc b/src/rit-wpan/model/clock-drift-applier.cc
new file mode 100644
index 0000000..deab98f
--- /dev/null
+++ b/src/rit-wpan/model/clock-drift-applier.cc
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#include "clock-drift-applier.h"
+
+#include <ns3/double.h>
+#include <ns3/log.h>
+
+namespace ns3
+{
+
+NS_LOG_COMPONENT_DEFINE("ClockDriftApplier");
+
+ClockDriftApplier::ClockDriftApplier()
+    : m_skew(0.0),
+      m_K(1e-9), // noise coefficient K (unit: s)
+      m_noiseGen(CreateObject<NormalRandomVariable>()),
+      m_minSkewPpm(-250.0),
+      m_maxSkewPpm(250.0)
+{
+}
+
+void
+ClockDriftApplier::SetSkewRange(double minPpm, double maxPpm)
+{
+    m_minSkewPpm = minPpm;
+    m_maxSkewPpm = maxPpm;
+}
+
+void
+ClockDriftApplier::Initialize(uint32_t nodeId, uint32_t runId)
+{
+    Ptr<UniformRandomVariable> skewGen = CreateObject<UniformRandomVariable>();
+    skewGen->SetStream(1000 + nodeId);
+
+    double ppm = skewGen->GetValue(m_minSkewPpm, m_maxSkewPpm);
+    m_skew = ppm / 1e6; // Convert ppm to a ratio
+
+    m_noiseGen->SetStream(2000 + runId);
+
+    NS_LOG_INFO("Initialized ClockDriftApplier with skew = " << ppm << " ppm (" << m_skew
+                                                             << "), stream = " << (2000 + runId));
+}
+
+void
+ClockDriftApplier::SetSkewPpm(double ppm)
+{
+    m_skew = ppm / 1e6;
+}
+
+void
+ClockDriftApplier::SetK(double k)
+{
+    m_K = k;
+}
+
+double
+ClockDriftApplier::ComputeAdjustedSeconds(double t) const
+{
+    double stddev = std::sqrt(m_K * t);
+    double noise = m_noiseGen->GetValue() * stddev; // epsilon ~ N(0, K*t)
+
+    // Correction formula: T = t * (1 + ) + 
+    double delay = t * (1.0 + m_skew) + noise;
+
+    // Safety: truncate negative delay to 0 seconds
+    delay = std::max(0.0, delay);
+
+    NS_LOG_DEBUG("inputSeconds = " << t << ", skew = " << m_skew << ", noise = " << noise
+                                   << ", adjusted = " << delay);
+    return delay;
+}
+
+double
+ClockDriftApplier::GetAdjustedDelay(double t) const
+{
+    return ComputeAdjustedSeconds(t);
+}
+
+Time
+ClockDriftApplier::Apply(Time t) const
+{
+    return Seconds(ComputeAdjustedSeconds(t.GetSeconds()));
+}
+
+} // namespace ns3
diff --git a/src/rit-wpan/model/clock-drift-applier.h b/src/rit-wpan/model/clock-drift-applier.h
new file mode 100644
index 0000000..fbc0286
--- /dev/null
+++ b/src/rit-wpan/model/clock-drift-applier.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#ifndef CLOCK_DRIFT_APPLIER_H
+#define CLOCK_DRIFT_APPLIER_H
+
+#include <ns3/core-module.h>
+#include <ns3/nstime.h>
+#include <ns3/random-variable-stream.h>
+
+namespace ns3
+{
+
+class ClockDriftApplier : public Object
+{
+  public:
+    ClockDriftApplier();
+
+    /**
+     * Initialize: set skew and noise based on node ID and run ID
+     */
+    void Initialize(uint32_t nodeId, uint32_t runId);
+
+    /**
+     * Return the global time difference corresponding to n seconds in local time (double version)
+     */
+    double GetAdjustedDelay(double nSeconds) const;
+
+    /**
+     * Return the global time difference corresponding to inputTime seconds in local time (Time version)
+     */
+    Time Apply(Time inputTime) const;
+
+    /**
+     * Explicitly set skew (ppm) from outside (if omitted, uniform random in 20 ppm)
+     */
+    void SetSkewPpm(double ppm);
+
+    void SetSkewRange(double minPpm, double maxPpm);
+
+    /**
+     * Set the intensity K of the random-walk noise from outside
+     */
+    void SetK(double k);
+
+  private:
+    /**
+     * Common logic: return adjusted seconds
+     */
+    double ComputeAdjustedSeconds(double inputSeconds) const;
+
+    double m_skew;                        // Ratio (ppm / 1e6)
+    double m_K;                           // Random-walk intensity (linear coefficient of variance)
+    Ptr<NormalRandomVariable> m_noiseGen; // N(0,1) random number generator
+
+    double m_minSkewPpm = -20.0;
+    double m_maxSkewPpm = 20.0;
+};
+
+} // namespace ns3
+
+#endif // CLOCK_DRIFT_APPLIER_H
diff --git a/src/rit-wpan/model/rit-sub-header.cc b/src/rit-wpan/model/rit-sub-header.cc
new file mode 100644
index 0000000..163cd70
--- /dev/null
+++ b/src/rit-wpan/model/rit-sub-header.cc
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+/*
+ * NOTE [EXPERIMENTAL / CURRENTLY UNUSED]:
+ *
+ * This sub-header was introduced for experimental extensions of the RIT MAC,
+ * such as signaling continuous transmission or other control hints between nodes.
+ *
+ * In the current public evaluation scenarios, this sub-header is NOT actively used,
+ * and its insertion/removal is disabled to keep the packet format minimal and stable.
+ *
+ * The implementation is intentionally preserved to:
+ *  - document the design space explored during early experiments, and
+ *  - serve as a foundation for future experimental extensions.
+ *
+ * As a result, this file may appear unused in the default simulation workflow,
+ * but it is kept by design.
+ */
+
+#include "rit-sub-header.h"
+
+#include <ostream>
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+namespace
+{
+constexpr uint8_t kFlagContinuous = 0x01; // bit0: CONTINUOUS
+} // namespace
+
+void
+RitSubHeader::SetContinuous(bool enabled)
+{
+    if (enabled)
+    {
+        m_flags |= kFlagContinuous;
+    }
+    else
+    {
+        m_flags &= ~kFlagContinuous;
+    }
+}
+
+bool
+RitSubHeader::isContinuous() const
+{
+    return (m_flags & kFlagContinuous) != 0;
+}
+
+void
+RitSubHeader::SetSubHeaderFrameControl(uint8_t flags)
+{
+    m_flags = flags;
+}
+
+uint8_t
+RitSubHeader::GetSubHeaderFrameControl() const
+{
+    return m_flags;
+}
+
+TypeId
+RitSubHeader::GetTypeId()
+{
+    static TypeId tid = TypeId("ns3::lrwpan::RitSubHeader")
+                            .SetParent<Header>()
+                            .SetGroupName("LrWpan")
+                            .AddConstructor<RitSubHeader>();
+    return tid;
+}
+
+TypeId
+RitSubHeader::GetInstanceTypeId() const
+{
+    return GetTypeId();
+}
+
+void
+RitSubHeader::Serialize(Buffer::Iterator start) const
+{
+    start.WriteU8(m_flags);
+}
+
+uint32_t
+RitSubHeader::Deserialize(Buffer::Iterator start)
+{
+    Buffer::Iterator i = start;
+    m_flags = i.ReadU8();
+    return i.GetDistanceFrom(start);
+}
+
+uint32_t
+RitSubHeader::GetSerializedSize() const
+{
+    return 1;
+}
+
+void
+RitSubHeader::Print(std::ostream& os) const
+{
+    os << "RitSubHeader: CONTINUOUS=" << (isContinuous() ? "1" : "0");
+}
+
+} // namespace lrwpan
+} // namespace ns3
diff --git a/src/rit-wpan/model/rit-sub-header.h b/src/rit-wpan/model/rit-sub-header.h
new file mode 100644
index 0000000..30bb6ca
--- /dev/null
+++ b/src/rit-wpan/model/rit-sub-header.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#ifndef NS3_LRWPAN_RIT_SUB_HEADER_H
+#define NS3_LRWPAN_RIT_SUB_HEADER_H
+
+#include "ns3/header.h"
+
+#include <cstdint>
+#include <ostream>
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+/**
+ * @ingroup lrwpan
+ *
+ * @brief Experimental sub-header for RIT frame extensions.
+ *
+ * This header provides a compact flag field for experimental control signaling
+ * (e.g., continuous transmission indication). It serializes into 1 byte.
+ *
+ * Layout (m_flags):
+ *  - bit0: CONTINUOUS
+ *  - bit1-7: reserved for future use
+ */
+class RitSubHeader : public Header
+{
+  public:
+    RitSubHeader() = default;
+    ~RitSubHeader() override = default;
+
+    /**
+     * @brief Set/clear the CONTINUOUS flag (bit0).
+     */
+    void SetContinuous(bool enabled);
+
+    /**
+     * @brief Return true if the CONTINUOUS flag (bit0) is set.
+     */
+    bool isContinuous() const;
+
+    /**
+     * @brief Set raw flags (all bits preserved as-is).
+     */
+    void SetSubHeaderFrameControl(uint8_t flags);
+
+    /**
+     * @brief Get raw flags (all bits preserved as-is).
+     */
+    uint8_t GetSubHeaderFrameControl() const;
+
+    // ns-3 Header API
+    static TypeId GetTypeId();
+    TypeId GetInstanceTypeId() const override;
+    void Serialize(Buffer::Iterator start) const override;
+    uint32_t Deserialize(Buffer::Iterator start) override;
+    uint32_t GetSerializedSize() const override;
+    void Print(std::ostream& os) const override;
+
+  private:
+    uint8_t m_flags{0}; //!< bit0: CONTINUOUS, bit1-7: reserved
+};
+
+} // namespace lrwpan
+} // namespace ns3
+
+#endif // NS3_LRWPAN_RIT_SUB_HEADER_H
diff --git a/src/rit-wpan/model/rit-wpan-mac.cc b/src/rit-wpan/model/rit-wpan-mac.cc
new file mode 100644
index 0000000..cc959f5
--- /dev/null
+++ b/src/rit-wpan/model/rit-wpan-mac.cc
@@ -0,0 +1,1923 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#include "rit-wpan-mac.h"
+
+#include "rit-sub-header.h"
+#include "rit-wpan-precs.h"
+#include "rit-wpan-precsb.h"
+
+#include "ns3/lr-wpan-constants.h"
+#include "ns3/lr-wpan-csmaca.h"
+#include "ns3/lr-wpan-mac-header.h"
+#include "ns3/lr-wpan-mac-pl-headers.h"
+#include "ns3/lr-wpan-mac-trailer.h"
+#include "ns3/node.h"
+#include "ns3/simulator.h"
+
+#include <cstdint>
+
+#undef NS_LOG_APPEND_CONTEXT
+#define NS_LOG_APPEND_CONTEXT                                                                     \
+    std::clog << "[" << m_shortAddress << "|"                                                     \
+            << m_macRitPeriodTime.Get().GetSeconds() << "s|"                                      \
+            << m_macRitTxWaitDurationTime.Get().GetMilliSeconds() << "ms|"                        \
+            << m_ritMacMode << "|Qs:" << static_cast<uint32_t>(m_txQueue.size()) << "|"           \
+            << m_macState << "|" << m_periodicRitDataRequestEvent.IsPending() << "] ";
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+NS_LOG_COMPONENT_DEFINE("RitWpanMac");
+NS_OBJECT_ENSURE_REGISTERED(RitWpanMac);
+
+std::ostream&
+operator<<(std::ostream& os, const RitMacMode& ritMode)
+{
+    switch (ritMode)
+    {
+    case RIT_MODE_DISABLED:
+        os << "RIT_MODE_DISABLED";
+        break;
+    case SENDER_MODE:
+        os << "SENDER";
+        break;
+    case RECEIVER_MODE:
+        os << "RECEIVER";
+        break;
+    case SLEEP_MODE:
+        os << "SLEEP";
+        break;
+    case BOOTSTRAP_MODE:
+        os << "BOOTSTRAP";
+        break;
+    }
+    return os;
+}
+
+TypeId
+RitWpanMac::GetTypeId()
+{
+    static TypeId tid =
+        TypeId("ns3::RitWpanMac")
+            .SetParent<LrWpanMac>()
+            .SetGroupName("LrWpan")
+            .AddConstructor<RitWpanMac>()
+            .AddAttribute("macRitPeriod",
+                          "RIT interval (0x000000 ~ 0xFFFFFF)",
+                          UintegerValue(0),
+                          MakeUintegerAccessor(&RitWpanMac::m_macRitPeriod),
+                          MakeUintegerChecker<uint32_t>())
+            .AddAttribute("macRitDataWaitDuration",
+                          "Reception waiting time after RIT (0x00 ~ 0xFF)",
+                          UintegerValue(1),
+                          MakeUintegerAccessor(&RitWpanMac::m_macRitDataWaitDuration),
+                          MakeUintegerChecker<uint8_t>())
+            .AddAttribute("macRitTxWaitDuration",
+                          "Beacon waiting time (macRitPeriod or more, up to 0xFFFFFF)",
+                          UintegerValue(65),
+                          MakeUintegerAccessor(&RitWpanMac::m_macRitTxWaitDuration),
+                          MakeUintegerChecker<uint32_t>())
+            .AddTraceSource("MacMode",
+                            "Current RIT MAC mode",
+                            MakeTraceSourceAccessor(&RitWpanMac::m_ritMacMode),
+                            "ns3::lrwpan::RitMacMode")
+            .AddTraceSource("MacRitPeriod",
+                            "Trace of macRitPeriod changes",
+                            MakeTraceSourceAccessor(&RitWpanMac::m_macRitPeriod),
+                            "ns3::TracedValueCallback::Uint32")
+            .AddTraceSource("MacRitDataWaitDuration",
+                            "Trace of macRitDataWaitDuration changes",
+                            MakeTraceSourceAccessor(&RitWpanMac::m_macRitDataWaitDuration),
+                            "ns3::TracedValueCallback::Uint8")
+            .AddTraceSource("MacRitTxWaitDuration",
+                            "Trace of macRitTxWaitDuration changes",
+                            MakeTraceSourceAccessor(&RitWpanMac::m_macRitTxWaitDuration),
+                            "ns3::TracedValueCallback::Uint32")
+            .AddTraceSource("BeaconWaitEvent",
+                            "Beacon wait events (start, end, timeout) with timestamps",
+                            MakeTraceSourceAccessor(&RitWpanMac::m_beaconWaitTrace),
+                            "ns3::TracedCallback::StringTime")
+            .AddTraceSource("DataWaitEvent",
+                            "Data wait events (start, end, timeout) with timestamps",
+                            MakeTraceSourceAccessor(&RitWpanMac::m_dataWaitTrace),
+                            "ns3::TracedCallback::StringTime");
+    return tid;
+}
+
+RitWpanMac::RitWpanMac()
+{
+    NS_LOG_FUNCTION(this);
+    // Initialize RIT-specific parameters
+    ChangeRitMacMode(RIT_MODE_DISABLED);
+    m_timeDriftApplier = CreateObject<TimeDriftApplier>();
+    m_timeDriftApplier->SetDriftRatio(10); // Set a default drift ratio of 10%
+    m_clockDriftApplier = CreateObject<ClockDriftApplier>();
+    m_rxAlwaysOn = false; // Default to false, can be set later
+
+    m_macRitPeriodTime = Seconds(5);
+    m_macRitDataWaitDurationTime = MilliSeconds(10);
+    m_macRitTxWaitDurationTime = MilliSeconds(5000);
+
+    SetMacMaxFrameRetries(0);
+}
+
+RitWpanMac::~RitWpanMac()
+{
+}
+
+void
+RitWpanMac::DoInitialize()
+{
+    NS_LOG_FUNCTION(this);
+    ChangeRitMacMode(SLEEP_MODE); // Initial mode at initialization (before starting RIT cycle)
+    m_clockDriftApplier->Initialize(m_shortAddress.ConvertToInt(), 1);
+    LrWpanMac::DoInitialize();
+}
+
+void
+RitWpanMac::DoDispose()
+{
+    NS_LOG_FUNCTION(this);
+    // Cancel any scheduled events
+    m_ritDataWaitTimeout.Cancel();
+    m_ritTxWaitTimeout.Cancel();
+    m_periodicRitDataRequestEvent.Cancel();
+
+    // Chain up to the parent class
+    LrWpanMac::DoDispose();
+}
+
+void
+RitWpanMac::McpsDataRequest(McpsDataRequestParams params, Ptr<Packet> p)
+{
+    NS_LOG_FUNCTION(this << p);
+
+    if (!IsRitModeEnabled())
+    {
+        LrWpanMac::McpsDataRequest(params, p);
+        return;
+    }
+
+    McpsDataConfirmParams confirmParams;
+    confirmParams.m_msduHandle = params.m_msduHandle;
+
+    LrWpanMacHeader macHdr(LrWpanMacHeader::LRWPAN_MAC_DATA, m_macDsn.GetValue());
+    m_macDsn++;
+
+    if (p->GetSize() > lrwpan::aMaxPhyPacketSize - lrwpan::aMinMPDUOverhead)
+    {
+        NS_LOG_ERROR(this << " packet too big: " << p->GetSize());
+        confirmParams.m_status = MacStatus::FRAME_TOO_LONG;
+        if (!m_mcpsDataConfirmCallback.IsNull())
+        {
+            m_mcpsDataConfirmCallback(confirmParams);
+        }
+        return;
+    }
+
+    if ((params.m_srcAddrMode == NO_PANID_ADDR) && (params.m_dstAddrMode == NO_PANID_ADDR))
+    {
+        NS_LOG_ERROR(this << " Can not send packet with no Address field");
+        confirmParams.m_status = MacStatus::INVALID_ADDRESS;
+        if (!m_mcpsDataConfirmCallback.IsNull())
+        {
+            m_mcpsDataConfirmCallback(confirmParams);
+        }
+        return;
+    }
+    switch (params.m_srcAddrMode)
+    {
+    case NO_PANID_ADDR:
+        macHdr.SetSrcAddrMode(params.m_srcAddrMode);
+        macHdr.SetNoPanIdComp();
+        break;
+    case ADDR_MODE_RESERVED:
+        NS_ABORT_MSG("Can not set source address type to ADDR_MODE_RESERVED. Aborting.");
+        break;
+    case SHORT_ADDR:
+        macHdr.SetSrcAddrMode(params.m_srcAddrMode);
+        macHdr.SetSrcAddrFields(GetPanId(), GetShortAddress());
+        break;
+    case EXT_ADDR:
+        macHdr.SetSrcAddrMode(params.m_srcAddrMode);
+        macHdr.SetSrcAddrFields(GetPanId(), GetExtendedAddress());
+        break;
+    default:
+        NS_LOG_ERROR(this << " Can not send packet with incorrect Source Address mode = "
+                          << params.m_srcAddrMode);
+        confirmParams.m_status = MacStatus::INVALID_ADDRESS;
+        if (!m_mcpsDataConfirmCallback.IsNull())
+        {
+            m_mcpsDataConfirmCallback(confirmParams);
+        }
+        return;
+    }
+    switch (params.m_dstAddrMode)
+    {
+    case NO_PANID_ADDR:
+        macHdr.SetDstAddrMode(params.m_dstAddrMode);
+        macHdr.SetNoPanIdComp();
+        break;
+    case ADDR_MODE_RESERVED:
+        NS_ABORT_MSG("Can not set destination address type to ADDR_MODE_RESERVED. Aborting.");
+        break;
+    case SHORT_ADDR:
+        macHdr.SetDstAddrMode(params.m_dstAddrMode);
+        macHdr.SetDstAddrFields(params.m_dstPanId, params.m_dstAddr);
+        break;
+    case EXT_ADDR:
+        macHdr.SetDstAddrMode(params.m_dstAddrMode);
+        macHdr.SetDstAddrFields(params.m_dstPanId, params.m_dstExtAddr);
+        break;
+    default:
+        NS_LOG_ERROR(this << " Can not send packet with incorrect Destination Address mode = "
+                          << params.m_dstAddrMode);
+        confirmParams.m_status = MacStatus::INVALID_ADDRESS;
+        if (!m_mcpsDataConfirmCallback.IsNull())
+        {
+            m_mcpsDataConfirmCallback(confirmParams);
+        }
+        return;
+    }
+
+    // IEEE 802.15.4-2006 (7.5.6.1)
+    // Src & Dst PANs are identical, PAN compression is ON
+    // only the dst PAN is serialized making the MAC header 2 bytes smaller
+    if ((params.m_dstAddrMode != NO_PANID_ADDR && params.m_srcAddrMode != NO_PANID_ADDR) &&
+        (macHdr.GetDstPanId() == macHdr.GetSrcPanId()))
+    {
+        macHdr.SetPanIdComp();
+    }
+
+    macHdr.SetSecDisable();
+    // extract the first 3 bits in TxOptions
+    int b0 = params.m_txOptions & TX_OPTION_ACK;
+    int b1 = params.m_txOptions & TX_OPTION_GTS;
+    int b2 = params.m_txOptions & TX_OPTION_INDIRECT;
+
+    if (b0 == TX_OPTION_ACK)
+    {
+        // Set AckReq bit only if the destination is not the broadcast address.
+        if (macHdr.GetDstAddrMode() == SHORT_ADDR)
+        {
+            // short address and ACK requested.
+            Mac16Address shortAddr = macHdr.GetShortDstAddr();
+            if (shortAddr.IsBroadcast() || shortAddr.IsMulticast())
+            {
+                NS_LOG_LOGIC("LrWpanMac::McpsDataRequest: requested an ACK on broadcast or "
+                             "multicast destination ("
+                             << shortAddr << ") - forcefully removing it.");
+                macHdr.SetNoAckReq();
+                params.m_txOptions &= ~uint8_t(TX_OPTION_ACK);
+            }
+            else
+            {
+                macHdr.SetAckReq();
+            }
+        }
+        else
+        {
+            // other address (not short) and ACK requested
+            macHdr.SetAckReq();
+        }
+    }
+    else
+    {
+        macHdr.SetNoAckReq();
+    }
+
+    // NOTE: RIT mode does not support GTS or INDIRECT transmission.
+    if (b1 == TX_OPTION_GTS || b2 == TX_OPTION_INDIRECT)
+    {
+        NS_LOG_ERROR(this << " GTS or INDIRECT transmission not supported in RIT mode");
+
+        confirmParams.m_status = MacStatus::INVALID_PARAMETER;
+        if (!m_mcpsDataConfirmCallback.IsNull())
+        {
+            m_mcpsDataConfirmCallback(confirmParams);
+        }
+        return;
+    }
+
+    /*
+    * NOTE [EXPERIMENTAL / DISABLED]:
+    * The RIT sub-header was experimentally used to carry control flags
+    * (e.g., continuous transmission indication).
+    * It is currently disabled to keep the packet format minimal and
+    * preserve backward compatibility with existing evaluation scripts.
+    * This block is intentionally kept for future experimental extensions.
+    */
+    // RitSubHeader ritSubHdr;
+    // if (m_moduleConfig.continuousTxEnabled && m_txQueue.size() > 1)
+    // {
+    //     ritSubHdr.SetContinuous(true);
+    // }
+    // else
+    // {
+    //     ritSubHdr.SetContinuous(false);
+    // }
+    // p->AddHeader(ritSubHdr);
+
+    // RIT Direct Tx
+    // RIT direct transmission:
+    // In RIT mode, packets are enqueued and transmitted only after receiving a valid
+    // RIT Data Request (beacon) from the intended receiver.
+    // RIT does not rely on beacon-enabled synchronization and is expected to use
+    // unslotted CSMA/CA or module-specific channel access logic.
+    p->AddHeader(macHdr);
+
+    LrWpanMacTrailer macTrailer;
+    // Calculate FCS if the global attribute ChecksumEnabled is set.
+    if (Node::ChecksumEnabled())
+    {
+        macTrailer.EnableFcs(true);
+        macTrailer.SetFcs(p);
+    }
+    p->AddTrailer(macTrailer);
+
+    // *Just enqueue the packet, DO NOT send immediately*
+    Ptr<TxQueueElement> txQElement = Create<TxQueueElement>();
+    txQElement->txQMsduHandle = params.m_msduHandle;
+    txQElement->txQPkt = p;
+    EnqueueTxQElement(txQElement);
+
+    if (m_ritMacMode == SLEEP_MODE)
+    {
+        CheckTxAndStartSender();
+    }
+}
+
+void
+RitWpanMac::PdDataIndication(uint32_t psduLength, Ptr<Packet> p, uint8_t lqi)
+{
+    NS_ASSERT(m_macState == MAC_IDLE || m_macState == MAC_ACK_PENDING || m_macState == MAC_CSMA);
+    NS_LOG_FUNCTION(this << psduLength << p << (uint16_t)lqi);
+
+    if (!IsRitModeEnabled())
+    {
+        LrWpanMac::PdDataIndication(psduLength, p, lqi);
+        return;
+    }
+
+    bool acceptFrame;
+    Ptr<Packet> originalPkt = p->Copy(); // because we will strip headers
+
+    LrWpanMacTrailer receivedMacTrailer;
+    p->RemoveTrailer(receivedMacTrailer);
+
+    if (Node::ChecksumEnabled())
+    {
+        receivedMacTrailer.EnableFcs(true);
+    }
+
+    LrWpanMacHeader receivedMacHdr;
+    p->RemoveHeader(receivedMacHdr);
+
+    // From section 7.5.6.2 Reception and rejection, IEEE 802.15.4-2006
+    // - Level 1 filtering: Test FCS field and reject if frame fails.
+    // - Level 2 filtering: If promiscuous mode pass frame to higher layer
+    //   otherwise perform Level 3 filtering.
+    // - Level 3 filtering: Accept frame if Frame type and version is not reserved, and if
+    //   there is a dstPanId then dstPanId=m_macPanId or broadcastPanId, and if there is a
+    //   shortDstAddr then shortDstAddr=shortMacAddr or broadcastAddr, and if beacon frame then
+    //   srcPanId = m_macPanId if only srcAddr field in Data or Command frame,accept frame if
+    //   srcPanId=m_macPanId.
+
+    // Level 1 filtering: FCS check
+    if (!receivedMacTrailer.CheckFcs(p))
+    {
+        m_macRxDropTrace(originalPkt);
+        return;
+    }
+
+    // Level 2 filtering: Promiscuous mode
+    if (m_macPromiscuousMode)
+    {
+        // NOTE: Promiscuous trace is disabled in RIT for performance, enable if needed
+        // PrintPacket(originalPkt);
+        // ReceiveInPromiscuousMode(lqi, originalPkt);
+        return;
+    }
+
+    // Level 3 filtering: RIT-specific reception logic
+    acceptFrame = (receivedMacHdr.GetType() != LrWpanMacHeader::LRWPAN_MAC_RESERVED);
+
+    // TODO: Support newer RIT frame versions (e.g., Frame Version 2).
+    if (acceptFrame)
+    {
+        acceptFrame = (receivedMacHdr.GetFrameVer() <= 1);
+    }
+
+    if (acceptFrame && (receivedMacHdr.GetDstAddrMode() > 1))
+    {
+        // Accept frame if one of the following is true:
+
+        // 1) Have the same macPanId
+        // 2) Is Message to all PANs
+        // 3) Is a command frame and the macPanId is not present
+        acceptFrame = (receivedMacHdr.GetDstPanId() == m_macPanId ||
+                       receivedMacHdr.GetDstPanId() == 0xffff) ||
+                      (m_macPanId == 0xffff && receivedMacHdr.IsCommand());
+    }
+
+    if (acceptFrame && (receivedMacHdr.GetDstAddrMode() == SHORT_ADDR))
+    {
+        if (receivedMacHdr.GetShortDstAddr() == m_shortAddress)
+        {
+            // unicast, for me
+            acceptFrame = true;
+        }
+        else if ((receivedMacHdr.GetShortDstAddr().IsBroadcast() ||
+                  receivedMacHdr.GetShortDstAddr().IsMulticast()) &&
+                 receivedMacHdr.IsCommand())
+        {
+            // Broadcast or multicast only command frame.
+            // Discard broadcast/multicast with the ACK bit set.
+            acceptFrame = !receivedMacHdr.IsAckReq();
+        }
+        else
+        {
+            acceptFrame = false;
+        }
+    }
+
+    if (acceptFrame && (receivedMacHdr.GetDstAddrMode() == EXT_ADDR))
+    {
+        acceptFrame = (receivedMacHdr.GetExtDstAddr() == m_macExtendedAddress);
+    }
+
+    // Check for Association Request Command in beacon-enabled CAP-based operation.
+    // This logic is NOT applicable to RIT mode, but ACK-required RIT commands may be added in
+    // the future.
+    if (acceptFrame && receivedMacHdr.IsCommand() && receivedMacHdr.IsAckReq())
+    {
+        // TODO: Handle ACK-required RIT commands (if supported in the future).
+        NS_LOG_ERROR("RIT mode does not support Association Request Command or ACK-required "
+                    "commands in beacon-enabled CAP-based operation.");
+    }
+
+    if (!acceptFrame)
+    {
+        NS_LOG_DEBUG("Frame not accepted: " << "Type=" << receivedMacHdr.GetType()
+                                            << ", SrcAddr=" << receivedMacHdr.GetShortSrcAddr()
+                                            << ", DstAddr=" << receivedMacHdr.GetShortDstAddr());
+        m_macRxDropTrace(originalPkt);
+        return;
+    }
+
+    m_macRxTrace(originalPkt);
+    if (receivedMacHdr.IsCommand())
+    {
+        ReceiveCommand(lqi, originalPkt); // Process RIT Data Request command
+    }
+    else if (receivedMacHdr.IsData() && m_ritMacMode == RECEIVER_MODE)
+    {
+        // Trace data wait end event
+        m_dataWaitTrace("end", Simulator::Now());
+
+        ReceiveData(lqi, originalPkt);
+
+        if (receivedMacHdr.IsAckReq())
+        {
+            // If this is a data or mac command frame, which is not a broadcast or
+            // multicast, with ack req set, generate and send an ack frame. If there is a
+            // CSMA medium access in progress we cancel the medium access for sending the
+            // ACK frame. A new transmission attempt will be started after the ACK was send.
+            if (m_macState == MAC_ACK_PENDING)
+            {
+                m_ackWaitTimeout.Cancel();
+                PrepareRetransmission();
+            }
+            else if (m_macState == MAC_CSMA)
+            {
+                // \todo: If we receive a packet while doing CSMA/CA, should  we drop the
+                // packet because of channel busy,
+                //        or should we restart CSMA/CA for the packet after sending the ACK?
+                // Currently we simply restart CSMA/CA after sending the ACK.
+                NS_LOG_DEBUG("Received a packet with ACK required while in CSMA. Cancel "
+                             "current CSMA-CA");
+                m_preCsB->Cancel();
+                m_preCs->Cancel();
+                m_csmaCa->Cancel();
+            }
+            // Cancel any pending MAC state change, ACKs have higher priority.
+            m_setMacState.Cancel();
+            ChangeMacState(MAC_IDLE);
+
+            // save received packet and LQI to process the appropriate indication/response
+            // after sending ACK (PD-DATA.confirm)
+            m_rxPkt = originalPkt->Copy();
+            m_lastRxFrameLqi = lqi;
+
+            /*
+            * NOTE [EXPERIMENTAL / DISABLED]:
+            * Reception-side handling of the RIT sub-header was experimentally implemented
+            * to inspect control flags such as continuous transmission indication.
+            *
+            * This logic is currently disabled to keep the receive path aligned with
+            * the minimal packet format used in the evaluation.
+            * The code is preserved for future experimental extensions and debugging.
+            */
+            // RitSubHeader ritSubHdr;
+            // p->RemoveHeader(ritSubHdr);
+            // if (ritSubHdr.isContinuous())
+            // {
+            //     m_continuousRxEnabled = true; // Enable continuous reception
+            // }
+
+            m_setMacState =
+                Simulator::ScheduleNow(&LrWpanMac::SendAck, this, receivedMacHdr.GetSeqNum());
+
+            // extend Receiver Timeout
+            m_ritDataWaitTimeout.Cancel();
+            m_ritDataWaitTimeout = Simulator::Schedule(GetRitDataWaitDurationTime(),
+                                                       &RitWpanMac::ReceiverCycleTimeout,
+                                                       this);
+            return;
+        }
+        // else if (m_continuousRxEnabled)
+        // {
+        //     return;
+        // }
+        else
+        {
+            EndReceiverCycle(); // Set the MAC state to sleep mode after data reception
+        }
+    }
+    else if (receivedMacHdr.IsMultipurpose())
+    {
+        NS_ASSERT(m_moduleConfig.beaconAckEnabled);
+        if (m_ritMacMode == RECEIVER_MODE)
+        {
+            NS_LOG_DEBUG("Received multipurpose frame, extend the data wait time.");
+            m_ritDataWaitTimeout.Cancel(); // Cancel the current data wait timeout
+            // TODO M: set current extend data wait time
+            m_ritDataWaitTimeout = Simulator::Schedule(GetContinuousTxTimeoutTime(),
+                                                       &RitWpanMac::ReceiverCycleTimeout,
+                                                       this);
+        }
+    }
+    else if (receivedMacHdr.IsAcknowledgment() && m_txPkt && m_macState == MAC_ACK_PENDING)
+    {
+        LrWpanMacHeader peekedMacHdr;
+        m_txPkt->PeekHeader(peekedMacHdr);
+        // If it is an ACK with the expected sequence number, finish the transmission
+        if (receivedMacHdr.GetSeqNum() == peekedMacHdr.GetSeqNum())
+        {
+            NS_LOG_DEBUG("Ack received");
+            m_ritSending = false;      // Clear the sending flag
+            m_ackWaitTimeout.Cancel(); // Cancel the ACK wait timeout
+            m_macTxOkTrace(m_txPkt);
+
+            if (!m_mcpsDataConfirmCallback.IsNull())
+            {
+                // Notify the upper layer about the successful data transmission
+                McpsDataConfirmParams confirmParams;
+                confirmParams.m_status = MacStatus::SUCCESS;
+                confirmParams.m_msduHandle = m_txQueue.front()->txQMsduHandle;
+                m_mcpsDataConfirmCallback(confirmParams);
+            }
+
+            m_setMacState.Cancel();
+            m_setMacState = Simulator::ScheduleNow(&LrWpanMac::SetLrWpanMacState, this, MAC_IDLE);
+            // if (m_moduleConfig.continuousTxEnabled && m_txQueue.size() > 0)
+            // {
+            //     // TODO: Consider IFS handling before sending the next packet.
+            //     NS_LOG_DEBUG("RIT continuous transmission enabled, waiting for next packet.");
+            //     DoSendRitData();
+            //     return;
+            // }
+            RemoveFirstTxQElement();
+            EndSenderCycle();
+        }
+        else
+        {
+            // TODO: check mac sequence
+            // WARN: i don't care about mac sequence is correct or not.
+            // LrWpanMac::PdDataIndication(psduLength, originalPkt, lqi);
+        }
+    }
+}
+
+void
+RitWpanMac::PdDataConfirm(PhyEnumeration status)
+{
+    NS_ASSERT(m_macState == MAC_SENDING);
+    NS_LOG_FUNCTION(this << status);
+
+    if (!IsRitModeEnabled())
+    {
+        LrWpanMac::PdDataConfirm(status);
+        return;
+    }
+
+    LrWpanMacHeader macHdr;
+    Time ifsWaitTime;
+
+    // NOTE: symbolRate can be used to compute IFS durations if needed.
+    // symbolRate = m_phy->GetDataOrSymbolRate(false); // symbols per second
+
+    m_txPkt->PeekHeader(macHdr);
+
+    if (status == IEEE_802_15_4_PHY_SUCCESS)
+    {
+        if (!macHdr.IsAcknowledgment())
+        {
+            if (macHdr.IsCommand())
+            {
+                Ptr<Packet> txOriginalPkt = m_txPkt->Copy();
+                LrWpanMacHeader txMacHdr;
+                txOriginalPkt->RemoveHeader(txMacHdr);
+                CommandPayloadHeader txMacPayload;
+                txOriginalPkt->RemoveHeader(txMacPayload);
+
+                if (txMacPayload.GetCommandFrameType() == CommandPayloadHeader::RIT_DATA_REQ)
+                {
+                    // NS_ASSERT(m_csmaCa->IsUnSlottedCsmaCa());
+                    NS_LOG_DEBUG("RIT request command transmitted successfully.");
+
+                    // Trace data wait start event.
+                    m_dataWaitTrace("start", Simulator::Now());
+
+                    // TODO: Adjust behavior depending on whether RIT-LE is used.
+                    StartRitDataWaitPeriod(); // Start the RIT data wait period.
+                    m_lastDataTxStartTime = Simulator::Now();
+                }
+                else
+                {
+                    NS_LOG_DEBUG(
+                        "error! RIT request command not sent, but PdDataConfirm called with "
+                        "status SUCCESS."
+                        << txMacPayload.GetCommandFrameType());
+                }
+            }
+            else if (macHdr.IsData())
+            {
+                // Handle successful data transmission.
+                if (macHdr.IsAckReq())
+                {
+                    NS_LOG_DEBUG("RIT data transmission completed successfully, waiting for ACK.");
+                    Time waitTime = Seconds(static_cast<double>(GetMacAckWaitDuration()) /
+                                            m_phy->GetDataOrSymbolRate(false));
+                    NS_ASSERT(m_ackWaitTimeout.IsExpired());
+                    m_ackWaitTimeout =
+                        Simulator::Schedule(waitTime, &RitWpanMac::AckWaitTimeout, this);
+                    m_setMacState.Cancel();
+                    m_setMacState = Simulator::ScheduleNow(&LrWpanMac::SetLrWpanMacState,
+                                                           this,
+                                                           MAC_ACK_PENDING);
+                    NS_LOG_DEBUG("end ack wait timeout scheduled");
+                    return;
+                }
+                else
+                {
+                    NS_LOG_DEBUG("RIT data transmission completed successfully (no ACK required).");
+                    m_ritSending = false; // Clear the sending flag.
+                    m_macTxOkTrace(m_txPkt);
+
+                    if (!m_mcpsDataConfirmCallback.IsNull())
+                    {
+                        // Notify the upper layer about the successful data transmission.
+                        McpsDataConfirmParams confirmParams;
+                        confirmParams.m_status = MacStatus::SUCCESS;
+                        confirmParams.m_msduHandle = m_txQueue.front()->txQMsduHandle;
+                        m_mcpsDataConfirmCallback(confirmParams);
+                    }
+
+                    if (m_moduleConfig.continuousTxEnabled && m_txQueue.size() > 0)
+                    {
+                        NS_LOG_DEBUG(
+                            "RIT continuous transmission enabled, waiting for next packet.");
+                        // TODO: Consider IFS handling before sending the next packet.
+                        DoSendRitData();
+                        return;
+                    }
+
+                    // Handle RIT data transmission completion.
+                    NS_ASSERT(m_ritTxWaitTimeout.IsExpired());
+                    RemoveFirstTxQElement(); // Remove the first element from the Tx queue.
+                    EndSenderCycle();
+                }
+            }
+            else if (macHdr.IsMultipurpose())
+            {
+                NS_ASSERT(m_ritMacMode == SENDER_MODE && m_moduleConfig.beaconAckEnabled);
+                // NOTE: Placeholder IFS wait time for multipurpose frames.
+                ifsWaitTime = NanoSeconds(1);
+            }
+            else
+            {
+                NS_LOG_ERROR(
+                    "Received unexpected frame type in PdDataConfirm: " << macHdr.GetType());
+            }
+        }
+        else
+        {
+            // Handle ACK transmission success.
+            // Clear the packet buffer for the ACK packet sent.
+            m_txPkt = nullptr;
+
+            // RIT module: continuous transmission handling.
+            if (m_moduleConfig.continuousTxEnabled && m_continuousRxEnabled)
+            {
+                m_ritDataWaitTimeout = Simulator::Schedule(GetContinuousTxTimeoutTime(),
+                                                           &RitWpanMac::ReceiverCycleTimeout,
+                                                           this);
+                return;
+            }
+
+            // End the receiver cycle after successfully transmitting an ACK.
+            EndReceiverCycle();
+        }
+    }
+    else
+    {
+        NS_LOG_DEBUG("RIT data transmission failed with status: " << status);
+        m_macTxDropTrace(m_txPkt);
+        m_txPkt = nullptr; // Clear the packet buffer.
+    }
+
+    if (!ifsWaitTime.IsZero())
+    {
+        m_ifsEvent =
+            Simulator::Schedule(ifsWaitTime, &RitWpanMac::IfsWaitTimeout, this, ifsWaitTime);
+    }
+
+    m_setMacState.Cancel();
+    m_setMacState = Simulator::ScheduleNow(&LrWpanMac::SetLrWpanMacState, this, MAC_IDLE);
+}
+
+void
+RitWpanMac::PlmeSetTRXStateConfirm(PhyEnumeration status)
+{
+    NS_LOG_FUNCTION(this << status);
+
+    if (!IsRitModeEnabled())
+    {
+        LrWpanMac::PlmeSetTRXStateConfirm(status);
+        return;
+    }
+
+    // Handle RIT-specific PLME-SET-TRX-STATE.confirm.
+    NS_LOG_DEBUG("RIT mode is enabled, handling PlmeSetTRXStateConfirm in RitWpanMac.");
+
+    if (m_macState == MAC_IDLE &&
+        (status == IEEE_802_15_4_PHY_RX_ON || status == IEEE_802_15_4_PHY_SUCCESS))
+    {
+        // NOTE: No action is required here in the current RIT implementation.
+        // CheckQueue();
+        return;
+    }
+    else if (m_macState == MAC_CSMA &&
+             (status == IEEE_802_15_4_PHY_RX_ON || status == IEEE_802_15_4_PHY_SUCCESS))
+    {
+        // Start CSMA-related processing as soon as the receiver is enabled.
+        LrWpanMacHeader macHdr;
+        m_txPkt->PeekHeader(macHdr);
+
+        if ((macHdr.IsCommand() && m_moduleConfig.beaconPreCsEnabled) ||
+            (macHdr.IsData() && m_moduleConfig.dataPreCsEnabled))
+        {
+            NS_LOG_DEBUG("Start Pre-CS");
+            m_preCs->Start();
+            return;
+        }
+    }
+
+    // Fall back to the base LrWpanMac implementation.
+    LrWpanMac::PlmeSetTRXStateConfirm(status);
+}
+
+/**
+ * Handle MLME-SET.request for RIT-specific PIB-like attributes.
+ *
+ * RIT-specific parameters are exposed as PIB-like attributes so that they can
+ * be configured through the standard MLME-SET interface used by ns-3
+ * LrWpanMac, preserving consistency with IEEE 802.15.4 MAC management.
+ *
+ * Attributes in the experimental/vendor-specific range (id >= 0xF0) are
+ * interpreted as RIT parameters and handled locally. Other attributes are
+ * forwarded to the base LrWpanMac implementation.
+ *
+ * NOTE:
+ * Although a separate convenience API may be provided for fast parameter
+ * configuration in experimental code, this MLME-based path is intentionally
+ * kept to maintain standard-compliant control, reproducibility, and
+ * compatibility with existing ns-3 MAC configuration workflows.
+ */
+void
+RitWpanMac::MlmeSetRequest(MacPibAttributeIdentifier id, Ptr<MacPibAttributes> attribute)
+{
+    MlmeSetConfirmParams confirmParams;
+    confirmParams.m_status = MacStatus::SUCCESS;
+
+    // RIT-specific attributes are assigned in a vendor/experimental range (id >= 0xF0).
+    // Only handle RIT PIB-like attributes.
+    if (id >= 0xF0)
+    {
+        if (id == static_cast<MacPibAttributeIdentifier>(macRitPeriod))
+        {
+            // Apply the new value first, then start/stop the RIT cycle accordingly.
+            m_macRitPeriod = attribute->macRitPeriod;
+
+            if (m_macRitPeriod == 0u)
+            {
+                StopRitCycle();
+            }
+            else if (m_ritMacMode == RIT_MODE_DISABLED)
+            {
+                StartRitCycle();
+            }
+        }
+        else if (id == static_cast<MacPibAttributeIdentifier>(macRitDataWaitDuration))
+        {
+            m_macRitDataWaitDuration = attribute->macRitDataWaitDuration;
+        }
+        else if (id == static_cast<MacPibAttributeIdentifier>(macRitTxWaitDuration))
+        {
+            m_macRitTxWaitDuration = attribute->macRitTxWaitDuration;
+        }
+        else if (id == static_cast<MacPibAttributeIdentifier>(macRitRequestPayload))
+        {
+            m_macRitRequestPayload = attribute->macRitRequestPayload;
+        }
+        else if (id == static_cast<MacPibAttributeIdentifier>(macRitPeriodTime))
+        {
+            // Apply the new value first, then start/stop the RIT cycle accordingly.
+            m_macRitPeriodTime = attribute->macRitPeriodTime;
+
+            if (m_macRitPeriodTime.Get().IsZero())
+            {
+                NS_LOG_DEBUG("RIT period time set to zero, stopping RIT cycle.");
+                StopRitCycle();
+            }
+            else if (m_ritMacMode == RIT_MODE_DISABLED)
+            {
+                StartRitCycle();
+            }
+        }
+        else if (id == static_cast<MacPibAttributeIdentifier>(macRitDataWaitDurationTime))
+        {
+            m_macRitDataWaitDurationTime = attribute->macRitDataWaitDurationTime;
+        }
+        else if (id == static_cast<MacPibAttributeIdentifier>(macRitTxWaitDurationTime))
+        {
+            m_macRitTxWaitDurationTime = attribute->macRitTxWaitDurationTime;
+        }
+        else
+        {
+            confirmParams.m_status = MacStatus::UNSUPPORTED_ATTRIBUTE;
+        }
+
+        if (!m_mlmeSetConfirmCallback.IsNull())
+        {
+            confirmParams.id = id;
+            m_mlmeSetConfirmCallback(confirmParams);
+        }
+    }
+    else
+    {
+        LrWpanMac::MlmeSetRequest(id, attribute);
+    }
+}
+
+/**
+ * Handle MLME-GET.request for RIT-specific PIB-like attributes.
+ *
+ * This method exposes internal RIT parameters through the standard MLME-GET
+ * interface used by ns-3 LrWpanMac, in order to keep the configuration and
+ * inspection path consistent with IEEE 802.15.4-style MAC management.
+ *
+ * RIT-related attributes are assigned to a vendor/experimental identifier
+ * range (id >= 0xF0) and are handled locally. All other attributes are
+ * delegated to the base LrWpanMac implementation.
+ *
+ * Note:
+ * For experimental use, higher-level or convenience configuration APIs may
+ * exist, but this function is intentionally kept for standard-compliant access
+ * and debugging purposes.
+ */
+void
+RitWpanMac::MlmeGetRequest(MacPibAttributeIdentifier id)
+{
+    NS_LOG_FUNCTION(this << id);
+    MacStatus status = MacStatus::SUCCESS;
+    Ptr<MacPibAttributes> attribute = Create<MacPibAttributes>();
+
+    // Only handle RIT-specific PIB-like attributes.
+    if (id >= 0xF0)
+    {
+        if (id == static_cast<MacPibAttributeIdentifier>(macRitPeriod))
+        {
+            attribute->macRitPeriod = m_macRitPeriod;
+        }
+        else if (id == static_cast<MacPibAttributeIdentifier>(macRitDataWaitDuration))
+        {
+            attribute->macRitDataWaitDuration = m_macRitDataWaitDuration;
+        }
+        else if (id == static_cast<MacPibAttributeIdentifier>(macRitTxWaitDuration))
+        {
+            attribute->macRitTxWaitDuration = m_macRitTxWaitDuration;
+        }
+        else if (id == static_cast<MacPibAttributeIdentifier>(macRitRequestPayload))
+        {
+            attribute->macRitRequestPayload = m_macRitRequestPayload;
+        }
+        else
+        {
+            status = MacStatus::UNSUPPORTED_ATTRIBUTE;
+        }
+
+        if (!m_mlmeGetConfirmCallback.IsNull())
+        {
+            m_mlmeGetConfirmCallback(status, id, attribute);
+        }
+    }
+    else
+    {
+        // Delegate non-RIT attributes to the base LrWpanMac implementation.
+        LrWpanMac::MlmeGetRequest(id);
+        return;
+    }
+}
+
+void
+RitWpanMac::IfsWaitTimeout(Time ifsTime)
+{
+    // TODO: Introduce RIT-specific IFS handling if protocol extensions require it.
+    NS_LOG_FUNCTION(this << ifsTime);
+
+    if (!IsRitModeEnabled())
+    {
+        LrWpanMac::IfsWaitTimeout(ifsTime);
+    }
+
+    auto symbolRate = (uint64_t)m_phy->GetDataOrSymbolRate(false);
+    Time lifsTime = Seconds((double)m_macLIFSPeriod / symbolRate);
+    Time sifsTime = Seconds((double)m_macSIFSPeriod / symbolRate);
+
+    if (ifsTime == lifsTime)
+    {
+        NS_LOG_DEBUG("LIFS of " << m_macLIFSPeriod << " symbols (" << ifsTime.As(Time::S)
+                                << ") completed ");
+    }
+    else if (ifsTime == sifsTime)
+    {
+        NS_LOG_DEBUG("SIFS of " << m_macSIFSPeriod << " symbols (" << ifsTime.As(Time::S)
+                                << ") completed ");
+    }
+    else
+    {
+        NS_LOG_DEBUG("Unknown IFS size (" << ifsTime.As(Time::S) << ") completed ");
+    }
+
+    m_macIfsEndTrace(ifsTime);
+
+    if (m_ritMacMode == SENDER_MODE)
+    {
+        NS_LOG_DEBUG("RIT continuous transmission or beacon ACK enabled; sending next packet.");
+        NS_ASSERT((m_moduleConfig.continuousTxEnabled || m_moduleConfig.beaconAckEnabled) &&
+                  m_txQueue.size() > 0);
+        DoSendRitData(); // Immediately transmit the next RIT data frame
+        return;
+    }
+    else if (m_ritMacMode == SLEEP_MODE)
+    {
+        // Opportunistically start sender mode if packets are queued.
+        CheckTxAndStartSender();
+        return;
+    }
+
+    // Fall back to the base LrWpanMac behavior for non-RIT cases.
+    LrWpanMac::IfsWaitTimeout(ifsTime);
+}
+
+void
+RitWpanMac::SetLrWpanMacState(MacState macState)
+{
+    NS_LOG_FUNCTION(this << macState);
+
+    if (!IsRitModeEnabled())
+    {
+        // Fall back to LrWpanMac if RIT mode is not enabled.
+        LrWpanMac::SetLrWpanMacState(macState);
+        return;
+    }
+
+    if (m_macState == MAC_CSMA && macState == CHANNEL_ACCESS_FAILURE)
+    {
+        NS_ASSERT(m_txPkt);
+
+        // A clear channel could not be found; drop the current packet and perform
+        // RIT-specific recovery depending on the frame type.
+        NS_LOG_DEBUG(this << " cannot find clear channel");
+
+        m_macTxDropTrace(m_txPkt);
+
+        Ptr<Packet> pkt = m_txPkt->Copy();
+        LrWpanMacHeader macHdr;
+        pkt->RemoveHeader(macHdr);
+
+        if (macHdr.IsData())
+        {
+            NS_LOG_DEBUG("RIT data packet dropped due to channel access failure.");
+
+            if (!m_mcpsDataConfirmCallback.IsNull())
+            {
+                McpsDataConfirmParams confirmParams;
+                confirmParams.m_msduHandle = m_txQueue.front()->txQMsduHandle;
+                confirmParams.m_status = MacStatus::CHANNEL_ACCESS_FAILURE;
+                m_mcpsDataConfirmCallback(confirmParams);
+            }
+
+            // Remove the queued packet corresponding to the failed transmission.
+            RemoveFirstTxQElement();
+
+            // End the sender cycle after data transmission failure.
+            EndSenderCycle();
+        }
+        else if (macHdr.IsCommand())
+        {
+            CommandPayloadHeader cmdPayload;
+            pkt->RemoveHeader(cmdPayload);
+
+            switch (cmdPayload.GetCommandFrameType())
+            {
+            case CommandPayloadHeader::RIT_DATA_REQ:
+                NS_LOG_DEBUG("RIT Beacon CSMA failed, End Receiver Cycle.");
+                EndReceiverCycle();
+                break;
+
+            case CommandPayloadHeader::RIT_DATA_RES:
+                // TODO: Handle RIT Data Response command on channel access failure.
+                NS_LOG_DEBUG("RIT Data Response command received, but not implemented yet.");
+                break;
+
+            default:
+                NS_LOG_ERROR("Unknown command frame type in RitWpanMac::SetLrWpanMacState: "
+                             << static_cast<int>(cmdPayload.GetCommandFrameType()));
+                break;
+            }
+        }
+    }
+    else
+    {
+        // Fall back to LrWpanMac for other state transitions.
+        LrWpanMac::SetLrWpanMacState(macState);
+    }
+}
+
+// ------------------------------------------------------------
+// Here begin the RIT-specific processing functions.
+// ------------------------------------------------------------
+
+void
+RitWpanMac::PeriodicRitDataRequest()
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT(IsRitModeEnabled());
+    NS_ASSERT(!m_periodicRitDataRequestEvent.IsPending());
+    NS_LOG_DEBUG("Periodic RIT data request initiated.");
+
+    // Schedule the next beacon transmission
+    Time ritPeriodTime = GetRitPeriodTime();
+    ritPeriodTime = m_clockDriftApplier->Apply(ritPeriodTime); // Apply clock drift correction
+
+    // *module* RI-MAC beacon interval randomization (x0.5 ~ x1.5)
+    if (m_timeDriftApplier && m_moduleConfig.beaconRandomizeEnabled)
+    {
+        ritPeriodTime = m_timeDriftApplier->ApplyByRatio(ritPeriodTime, 50.0);
+        NS_LOG_DEBUG("[RIT Module] Beacon interval randomized: "
+                     << ritPeriodTime.As(Time::S) << " seconds.");
+    }
+
+    m_periodicRitDataRequestEvent =
+        Simulator::Schedule(ritPeriodTime, &RitWpanMac::PeriodicRitDataRequest, this);
+
+    // Skip beacon transmission while operating in sender mode
+    if (m_ritMacMode == SENDER_MODE)
+    {
+        NS_LOG_DEBUG("Currently in SENDER MODE, skipping RIT data request.");
+    }
+    else
+    {
+        if (CheckTxAndStartSender())
+        {
+            // If a packet is queued, switch to sender mode instead of transmitting a beacon
+            return;
+        }
+
+        // In receiver mode, transmit the RIT data request as usual
+        ChangeRitMacMode(RECEIVER_MODE);
+        DoSendRitDataRequest();
+    }
+}
+
+void
+RitWpanMac::DoSendRitDataRequest()
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT(IsRitModeEnabled());
+    NS_ASSERT_MSG(m_macState == MAC_IDLE,
+                  "RIT Data Request can only be sent when MAC is in IDLE state. Now macState is "
+                      << m_macState);
+
+    // Build the packet for the RIT Data Request command.
+    // If no payload is configured, transmit an empty command payload.
+    Ptr<Packet> ritDataRequestPacket = Create<Packet>();
+    if (m_macRitRequestPayload.empty())
+    {
+        ritDataRequestPacket = Create<Packet>();
+    }
+    else
+    {
+        ritDataRequestPacket =
+            Create<Packet>(m_macRitRequestPayload.data(), m_macRitRequestPayload.size());
+    }
+
+    // Build the MAC header for the RIT Data Request command.
+    LrWpanMacHeader macHdr(LrWpanMacHeader::LRWPAN_MAC_COMMAND, m_macDsn.GetValue());
+    m_macDsn++;
+    macHdr.SetFrameVer(1);
+
+    // *module* Compact RIT Data Request:
+    // Use a minimized header (source only) to reduce overhead.
+    if (m_moduleConfig.compactRitDataRequestEnabled)
+    {
+        // Compact header for RIT Data Request (source address only).
+        macHdr.SetSrcAddrMode(SHORT_ADDR);
+        macHdr.SetSrcAddrFields(GetPanId(), GetShortAddress());
+        macHdr.SetDstAddrMode(NO_PANID_ADDR);
+        macHdr.SetPanIdComp();
+        macHdr.SetSecDisable();
+    }
+    else
+    {
+        // Standard header for RIT Data Request (broadcast destination).
+        macHdr.SetSrcAddrMode(SHORT_ADDR);
+        macHdr.SetSrcAddrFields(GetPanId(), GetShortAddress());
+        macHdr.SetDstAddrMode(SHORT_ADDR);
+        macHdr.SetDstAddrFields(GetPanId(), Mac16Address("FF:FF"));
+        macHdr.SetNoPanIdComp();
+        macHdr.SetSecDisable();
+    }
+
+    // Beacon ACK is handled as a separate multipurpose frame in this implementation.
+    // Therefore, the RIT Data Request command itself does not request an ACK.
+    macHdr.SetNoAckReq();
+
+    CommandPayloadHeader ritCmdHdr(CommandPayloadHeader::RIT_DATA_REQ);
+    ritDataRequestPacket->AddHeader(ritCmdHdr);
+    ritDataRequestPacket->AddHeader(macHdr);
+
+    // Append FCS if ChecksumEnabled is set globally.
+    LrWpanMacTrailer macTrailer;
+    if (Node::ChecksumEnabled())
+    {
+        macTrailer.EnableFcs(true);
+        macTrailer.SetFcs(ritDataRequestPacket);
+    }
+    ritDataRequestPacket->AddTrailer(macTrailer);
+
+    // Transmit the beacon either with CSMA/CA (or Pre-CS variants), or directly.
+    if (m_moduleConfig.beaconCsmaEnabled || m_moduleConfig.beaconPreCsEnabled ||
+        m_moduleConfig.beaconPreCsBEnabled)
+    {
+        NS_LOG_DEBUG("RIT beacon transmission with Unslotted CSMA/CA");
+
+        if (m_macState == MAC_IDLE && !m_setMacState.IsPending())
+        {
+            NS_ASSERT(m_csmaCa->IsUnSlottedCsmaCa());
+            if (!m_ifsEvent.IsPending())
+            {
+                m_txPkt = ritDataRequestPacket;
+                m_setMacState =
+                    Simulator::ScheduleNow(&LrWpanMac::SetLrWpanMacState, this, MAC_CSMA);
+            }
+        }
+    }
+    else
+    {
+        NS_LOG_DEBUG("RIT beacon transmission NO CSMA/CA");
+        m_txPkt = ritDataRequestPacket;
+        ChangeMacState(MAC_SENDING);
+        m_phy->PlmeSetTRXStateRequest(IEEE_802_15_4_PHY_TX_ON);
+    }
+}
+
+void
+RitWpanMac::SendRitData()
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT(IsRitModeEnabled() && m_ritMacMode == SENDER_MODE);
+    NS_ASSERT(m_txQueue.size() > 0);
+
+    if (m_macState == MAC_IDLE)
+    {
+        // Trace: beacon-wait period ended (a valid trigger to attempt transmission).
+        m_beaconWaitTrace("end", Simulator::Now());
+        m_ritSending = true;
+
+        if (m_moduleConfig.beaconAckEnabled)
+        {
+            NS_LOG_DEBUG("RIT beacon ACK enabled; sending Beacon ACK (multipurpose frame) first.");
+            DoSendRitBeaconAck();
+            return;
+        }
+
+        // Transmit the queued data frame (destination is set based on the last received RIT request).
+        DoSendRitData();
+    }
+    else
+    {
+        NS_LOG_DEBUG("RIT MAC is busy; cannot send RIT data now. macState=" << m_macState);
+        // Trace: send attempt skipped due to MAC busy.
+        m_beaconWaitTrace("skip", Simulator::Now());
+    }
+}
+
+void
+RitWpanMac::DoSendRitData()
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT(IsRitModeEnabled() && m_ritMacMode == SENDER_MODE);
+    NS_ASSERT(m_txQueue.size() > 0);
+
+    // Update the destination address of the head-of-line data frame to the sender of the
+    // most recently received RIT Data Request (i.e., the current intended receiver).
+    Ptr<TxQueueElement> txQElement = m_txQueue.front();
+    Ptr<Packet> pkt = txQElement->txQPkt->Copy();
+
+    LrWpanMacHeader macHdr;
+    pkt->RemoveHeader(macHdr);
+    macHdr.SetDstAddrMode(SHORT_ADDR);
+    macHdr.SetDstAddrFields(GetPanId(), m_lastRxRitReqFrameSrcAddr);
+    pkt->AddHeader(macHdr);
+
+    txQElement->txQPkt = pkt;
+
+    NS_LOG_DEBUG("RIT data request command from " << m_lastRxRitReqFrameSrcAddr);
+    NS_LOG_DEBUG("DoSendRitData: payload size=" << txQElement->txQPkt->GetSize() << " bytes | "
+                                               << "src=" << macHdr.GetShortSrcAddr() << " | "
+                                               << "dst=" << macHdr.GetShortDstAddr());
+
+    // Transmit the data either with CSMA/CA (or Pre-CS variants), or directly.
+    if (m_moduleConfig.dataCsmaEnabled || m_moduleConfig.dataPreCsEnabled ||
+        m_moduleConfig.dataPreCsBEnabled)
+    {
+        NS_ASSERT_MSG(
+            !(m_moduleConfig.dataCsmaEnabled && m_moduleConfig.dataPreCsEnabled),
+            "Only one of dataCsmaEnabled or dataPreCsEnabled can be true at the same time.");
+
+        NS_LOG_DEBUG("RIT data transmission with Unslotted CSMA/CA");
+        CheckQueue();
+    }
+    else
+    {
+        NS_LOG_DEBUG("RIT data transmission NO CSMA/CA");
+        m_txPkt = txQElement->txQPkt;
+        ChangeMacState(MAC_SENDING);
+        m_phy->PlmeSetTRXStateRequest(IEEE_802_15_4_PHY_TX_ON);
+    }
+}
+
+void
+RitWpanMac::DoSendRitBeaconAck()
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT(IsRitModeEnabled());
+    NS_ASSERT_MSG(m_macState == MAC_IDLE,
+                  "RIT Beacon ACK can only be sent when MAC is in IDLE state. Now macState is "
+                      << m_macState);
+
+    // Create an empty packet for the Beacon ACK (multipurpose frame).
+    Ptr<Packet> ritBeaconAckPacket = Create<Packet>();
+
+    // Build the MAC header for the Beacon ACK (multipurpose frame).
+    LrWpanMacHeader macHdr(LrWpanMacHeader::LRWPAN_MAC_MULTIPURPOSE, m_macDsn.GetValue());
+    m_macDsn++;
+    macHdr.SetFrameVer(1);
+
+    // Use a compact header:
+    // - no source PAN/address field
+    // - unicast destination set to the sender of the last RIT Data Request
+    macHdr.SetSrcAddrMode(NO_PANID_ADDR);
+    macHdr.SetDstAddrMode(SHORT_ADDR);
+    macHdr.SetDstAddrFields(GetPanId(), m_lastRxRitReqFrameSrcAddr);
+    macHdr.SetPanIdComp();
+    macHdr.SetSecDisable();
+
+    // Beacon ACK itself does not request an ACK.
+    macHdr.SetNoAckReq();
+    ritBeaconAckPacket->AddHeader(macHdr);
+
+    // Append FCS if ChecksumEnabled is set globally.
+    LrWpanMacTrailer macTrailer;
+    if (Node::ChecksumEnabled())
+    {
+        macTrailer.EnableFcs(true);
+        macTrailer.SetFcs(ritBeaconAckPacket);
+    }
+    ritBeaconAckPacket->AddTrailer(macTrailer);
+
+    NS_LOG_DEBUG("RIT beacon ACK transmission without CSMA/CA");
+
+    m_txPkt = ritBeaconAckPacket;
+    ChangeMacState(MAC_SENDING);
+    m_phy->PlmeSetTRXStateRequest(IEEE_802_15_4_PHY_TX_ON);
+}
+
+void
+RitWpanMac::ReceiveCommand(uint8_t lqi, Ptr<Packet> p)
+{
+    NS_LOG_FUNCTION(this << lqi << p);
+
+    NS_LOG_DEBUG("RIT command frame received; processing...");
+    LrWpanMacHeader receivedMacHdr;
+    p->RemoveHeader(receivedMacHdr);
+
+    // Peek the command type first, then strip it only when we actually handle it.
+    CommandPayloadHeader peekedPayload;
+    p->PeekHeader(peekedPayload);
+
+    switch (peekedPayload.GetCommandFrameType())
+    {
+    case CommandPayloadHeader::RIT_DATA_REQ:
+    {
+        if (m_ritMacMode == SENDER_MODE)
+        {
+            // Ignore a new request while we are already in the middle of sending.
+            if (m_ritSending)
+            {
+                NS_LOG_DEBUG("RIT_DATA_REQ received in SENDER_MODE, but already sending; ignored.");
+                break;
+            }
+
+            // A valid RIT request arrived: cancel the sender wait timeout and prepare for data TX.
+            m_ritTxWaitTimeout.Cancel();
+
+            CommandPayloadHeader receivedRitPayload;
+            p->RemoveHeader(receivedRitPayload);
+
+            MlmeRitRequestIndicationParams ritReqParams;
+
+            ritReqParams.m_srcAddrMode = receivedMacHdr.GetSrcAddrMode();
+            ritReqParams.m_srcPanId = receivedMacHdr.GetSrcPanId();
+            ritReqParams.m_srcAddr = receivedMacHdr.GetShortSrcAddr();
+            ritReqParams.m_srcExtAddr = receivedMacHdr.GetExtSrcAddr();
+
+            // Used by DoSendRitData() to set the unicast destination.
+            m_lastRxRitReqFrameSrcAddr = receivedMacHdr.GetShortSrcAddr();
+
+            ritReqParams.m_dstAddrMode = receivedMacHdr.GetDstAddrMode();
+            ritReqParams.m_dstPanId = receivedMacHdr.GetDstPanId();
+            ritReqParams.m_dstAddr = receivedMacHdr.GetShortDstAddr();
+            ritReqParams.m_dstExtAddr = receivedMacHdr.GetExtDstAddr();
+
+            std::vector<uint8_t> payload(p->GetSize());
+            p->CopyData(payload.data(), payload.size());
+            ritReqParams.m_ritRequestPayload = payload;
+
+            ritReqParams.m_linkQuality = lqi;
+            ritReqParams.m_dsn = receivedMacHdr.GetSeqNum();
+
+            // Timestamp is exported in symbols (16 us per symbol at 2.4 GHz O-QPSK).
+            ritReqParams.m_timestamp = Simulator::Now().GetMicroSeconds() / 16;
+
+            // Security-related fields are currently not populated for RIT extensions.
+            // TODO: Fill ritReqParams with security information if/when enabled.
+
+            if (!m_mlmeRitRequestIndicationCallback.IsNull())
+            {
+                NS_LOG_DEBUG("Invoking MLME-RIT-REQ.indication callback.");
+                m_mlmeRitRequestIndicationCallback(ritReqParams);
+            }
+            else
+            {
+                NS_LOG_DEBUG("MLME-RIT-REQ.indication callback is not set; request ignored.");
+            }
+        }
+        else if (m_ritMacMode == RECEIVER_MODE)
+        {
+            // Receiving RIT_DATA_REQ while being a receiver is unexpected in this implementation.
+            NS_LOG_DEBUG("RIT_DATA_REQ received in RECEIVER_MODE; not handled (unexpected).");
+        }
+        else if (m_ritMacMode == BOOTSTRAP_MODE)
+        {
+            // TODO: Define bootstrap behavior for RIT commands if needed.
+        }
+        else
+        {
+            NS_LOG_ERROR("RIT_DATA_REQ received in an invalid RIT mode: "
+                         << static_cast<int>(m_ritMacMode));
+        }
+        break;
+    }
+
+    case CommandPayloadHeader::RIT_DATA_RES:
+    {
+        // TODO: Handle RIT data response command if/when implemented.
+        NS_LOG_DEBUG("RIT_DATA_RES received, but not implemented yet.");
+        break;
+    }
+
+    default:
+        break;
+    }
+}
+
+void
+RitWpanMac::ReceiveData(uint8_t lqi, Ptr<Packet> p)
+{
+    NS_LOG_FUNCTION(this << lqi << p);
+
+    LrWpanMacTrailer receivedMacTrailer;
+    p->RemoveTrailer(receivedMacTrailer);
+
+    LrWpanMacHeader receivedMacHdr;
+    p->RemoveHeader(receivedMacHdr);
+
+    /*
+     * NOTE [EXPERIMENTAL / DISABLED]:
+     * Reception-side handling of the RIT sub-header was experimentally implemented
+     * to inspect control flags (e.g., continuous transmission indication).
+     *
+     * This logic is currently disabled to keep the receive path aligned with the
+     * minimal packet format used in the evaluation.
+     * The code is preserved for future experimental extensions and debugging.
+     */
+    // RitSubHeader ritSubHdr;
+    // p->RemoveHeader(ritSubHdr);
+
+    NS_LOG_DEBUG("Data packet for this node; forwarding up. dst="
+                 << receivedMacHdr.GetShortDstAddr() << " self=" << m_shortAddress
+                 << " src=" << receivedMacHdr.GetShortSrcAddr());
+
+    if (m_ritMacMode == SENDER_MODE)
+    {
+        NS_LOG_WARN("Data received in SENDER_MODE; ignoring (possible fast mode switch).");
+        return;
+    }
+
+    if (!m_mcpsDataIndicationCallback.IsNull())
+    {
+        McpsDataIndicationParams params;
+        params.m_dsn = receivedMacHdr.GetSeqNum();
+        params.m_mpduLinkQuality = lqi;
+
+        params.m_srcPanId = receivedMacHdr.GetSrcPanId();
+        params.m_srcAddrMode = receivedMacHdr.GetSrcAddrMode();
+        switch (params.m_srcAddrMode)
+        {
+        case SHORT_ADDR:
+            params.m_srcAddr = receivedMacHdr.GetShortSrcAddr();
+            break;
+        case EXT_ADDR:
+            params.m_srcExtAddr = receivedMacHdr.GetExtSrcAddr();
+            break;
+        default:
+            break;
+        }
+
+        params.m_dstPanId = receivedMacHdr.GetDstPanId();
+        params.m_dstAddrMode = receivedMacHdr.GetDstAddrMode();
+        switch (params.m_dstAddrMode)
+        {
+        case SHORT_ADDR:
+            params.m_dstAddr = receivedMacHdr.GetShortDstAddr();
+            break;
+        case EXT_ADDR:
+            params.m_dstExtAddr = receivedMacHdr.GetExtDstAddr();
+            break;
+        default:
+            break;
+        }
+
+        m_mcpsDataIndicationCallback(params, p);
+    }
+}
+
+void
+RitWpanMac::StartRitDataWaitPeriod()
+{
+    NS_ASSERT(IsRitModeEnabled() && m_ritMacMode == RECEIVER_MODE);
+    NS_LOG_FUNCTION(this);
+
+    // Keep the receiver on during the data-wait window after transmitting the RIT request.
+    // The MAC is forced to IDLE so that incoming frames can be processed immediately.
+    SetRxOnWhenIdle(true);
+    SetLrWpanMacState(MAC_IDLE);
+
+    const bool hasValidWait =
+        (m_useTimeBasedRitParams && (m_macRitDataWaitDurationTime > Seconds(0))) ||
+        (!m_useTimeBasedRitParams && (m_macRitDataWaitDuration > 0));
+
+    if (!hasValidWait)
+    {
+        NS_LOG_ERROR("Invalid RIT data wait duration; cannot start data wait period. "
+                     "useTimeBased=" << m_useTimeBasedRitParams << " waitTime="
+                     << (m_useTimeBasedRitParams
+                             ? m_macRitDataWaitDurationTime.Get().GetSeconds()
+                             : static_cast<double>(m_macRitDataWaitDuration)));
+        return;
+    }
+
+    const Time dataWaitTime = GetRitDataWaitDurationTime();
+    NS_ASSERT(m_ritDataWaitTimeout.IsExpired());
+    m_ritDataWaitTimeout =
+        Simulator::Schedule(dataWaitTime, &RitWpanMac::ReceiverCycleTimeout, this);
+}
+
+void
+RitWpanMac::StartRitTxWaitPeriod()
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT(IsRitModeEnabled() && m_ritMacMode == SENDER_MODE);
+
+    // Mark the start of the sender-side beacon-wait phase.
+    // This trace records when the sender enters a wait window in which RX is kept on.
+    m_beaconWaitTrace("start", Simulator::Now());
+
+    SetRxOnWhenIdle(true);
+    SetLrWpanMacState(MAC_IDLE);
+
+    const bool hasValidWait =
+        (m_useTimeBasedRitParams && (m_macRitTxWaitDurationTime > Seconds(0))) ||
+        (!m_useTimeBasedRitParams && (m_macRitTxWaitDuration > 0u));
+
+    if (!hasValidWait)
+    {
+        // Keep behavior: do not schedule a timeout when the duration is invalid/zero.
+        // (This matches the original control flow.)
+        return;
+    }
+
+    const Time txWaitTime = GetRitTxWaitDurationTime();
+    NS_ASSERT(m_ritTxWaitTimeout.IsExpired());
+    m_ritTxWaitTimeout =
+        Simulator::Schedule(txWaitTime, &RitWpanMac::SenderCycleTimeout, this);
+}
+
+void
+RitWpanMac::SenderCycleTimeout()
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT(IsRitModeEnabled() && m_ritMacMode == SENDER_MODE);
+
+    // Record that the sender-side beacon-wait window has timed out.
+    m_beaconWaitTrace("timeout", Simulator::Now());
+
+    // End the current sender cycle (cleanup + transition to sleep).
+    EndSenderCycle();
+}
+
+void
+RitWpanMac::EndSenderCycle()
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT(IsRitModeEnabled());
+    NS_ASSERT(m_ritMacMode == SENDER_MODE);
+
+    // Cancel any remaining sender-side wait timer (if still pending).
+    if (!m_ritTxWaitTimeout.IsExpired())
+    {
+        m_ritTxWaitTimeout.Cancel();
+    }
+
+    // Clear the "currently sending" guard for the sender cycle.
+    m_ritSending = false;
+
+    // Transition to sleep (PHY forced off unless rxAlwaysOn is enabled).
+    SetSleep();
+}
+
+
+void
+RitWpanMac::ReceiverCycleTimeout()
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT(IsRitModeEnabled() && m_ritMacMode == RECEIVER_MODE);
+    m_dataWaitTrace("timeout", Simulator::Now());
+    EndReceiverCycle(); // End the receiver cycle if the timeout occurs
+}
+
+void
+RitWpanMac::EndReceiverCycle()
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT(IsRitModeEnabled());
+    NS_ASSERT_MSG(m_ritMacMode == RECEIVER_MODE,
+                  "RIT MAC mode must be RECEIVER_MODE to end the receiver cycle. Now mode is "
+                      << m_ritMacMode << this);
+
+    // Cancel the receiver-side data wait timer if it is still pending.
+    if (m_ritDataWaitTimeout.IsPending())
+    {
+        NS_LOG_DEBUG("End Rx Data, end RIT receiver cycle.");
+        m_ritDataWaitTimeout.Cancel();
+    }
+
+    // Transition to sleep (PHY forced off unless rxAlwaysOn is enabled).
+    SetSleep();
+}
+
+void
+RitWpanMac::AckWaitTimeout()
+{
+    NS_LOG_FUNCTION(this);
+
+    if (!IsRitModeEnabled())
+    {
+        LrWpanMac::AckWaitTimeout();
+        return;
+    }
+
+    // In RIT mode, ACK wait timeout ends the sender cycle (the pending packet is handled
+    // by the base MAC timeout path, then we switch back to sleep).
+    NS_LOG_DEBUG("ACK wait timeout, ending RIT sender cycle.");
+
+    if (m_ritMacMode != SENDER_MODE)
+    {
+        NS_LOG_ERROR("ACK wait timeout occurred in an invalid RIT mode: " << m_ritMacMode);
+        return;
+    }
+
+    // Clear the sender-cycle guard before leaving the cycle.
+    m_ritSending = false;
+
+    // Delegate base-class ACK timeout handling (e.g., traces/state cleanup).
+    LrWpanMac::AckWaitTimeout();
+
+    // Finally, end the sender cycle and go to sleep.
+    EndSenderCycle();
+}
+
+void
+RitWpanMac::StartRitCycle()
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT(IsRitModeEnabled());
+
+    // Sanity check: the RIT period must be >= the receiver-side data wait duration.
+    // Use the effective values (time-based or duration-based), not the raw time members.
+    const Time period = GetRitPeriodTime();
+    const Time dataWait = GetRitDataWaitDurationTime();
+    NS_ASSERT_MSG(period >= dataWait,
+                  "RIT period time must be greater than or equal to RIT data wait duration time. "
+                      << period.GetSeconds() << " >= " << dataWait.GetSeconds());
+
+    NS_LOG_DEBUG("Starting RIT cycle with period: " << period.As(Time::S) << " seconds.");
+
+    // Only start scheduling when the base MAC is idle; otherwise defer (future work).
+    if (m_macState != MAC_IDLE)
+    {
+        // TODO: Defer starting the RIT cycle until ongoing operations settle.
+        return;
+    }
+
+    // Start the periodic RIT Data Request (beacon) scheduler.
+    NS_ASSERT(!m_periodicRitDataRequestEvent.IsPending());
+
+    // Enter sleep between periodic wakeups (unless rxAlwaysOn is enabled elsewhere).
+    ChangeRitMacMode(SLEEP_MODE);
+    SetRxOnWhenIdle(false);
+
+    // Randomize the initial phase to avoid starting all nodes at the same instant.
+    Ptr<UniformRandomVariable> initialDelay = CreateObject<UniformRandomVariable>();
+    const double delaySec = initialDelay->GetValue(0.0, period.GetSeconds());
+
+    m_periodicRitDataRequestEvent =
+        Simulator::Schedule(Seconds(delaySec), &RitWpanMac::PeriodicRitDataRequest, this);
+}
+
+void
+RitWpanMac::StopRitCycle()
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT(IsRitModeEnabled());
+    NS_LOG_DEBUG("Stopping RIT cycle.");
+
+    // Stop periodic scheduling and any ongoing sender/receiver wait windows.
+    // This is the symmetric counterpart of StartRitCycle(), and it forcefully returns
+    // the RIT MAC to the disabled state.
+    m_periodicRitDataRequestEvent.Cancel();
+    m_ritDataWaitTimeout.Cancel();
+    m_ritTxWaitTimeout.Cancel();
+
+    // Clear RIT mode and leave the base MAC in a safe idle state.
+    ChangeRitMacMode(RIT_MODE_DISABLED);
+    SetLrWpanMacState(MAC_IDLE);
+
+    // TODO: If StopRitCycle() is called while the MAC is busy, you may want to defer stopping
+    // until ongoing operations settle. For now, we stop immediately to match the user's intent.
+}
+
+void
+RitWpanMac::SetSleep()
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT(IsRitModeEnabled());
+
+    // RIT sleep transition should occur only when there is no active sender/receiver wait window.
+    NS_ASSERT(m_ritDataWaitTimeout.IsExpired() && m_ritTxWaitTimeout.IsExpired());
+
+    // Keep the base MAC state consistent before touching the PHY.
+    ChangeMacState(MAC_IDLE);
+
+    // If the user requested always-on RX, do not power down the radio.
+    if (m_rxAlwaysOn)
+    {
+        NS_LOG_DEBUG("RX always-on is enabled; skipping PHY sleep transition.");
+        return;
+    }
+
+    // Enter the RIT sleep mode and force the transceiver off.
+    ChangeRitMacMode(SLEEP_MODE);
+    m_phy->PlmeSetTRXStateRequest(IEEE_802_15_4_PHY_FORCE_TRX_OFF);
+    SetRxOnWhenIdle(false);
+}
+
+bool
+RitWpanMac::CheckTxAndStartSender()
+{
+    NS_LOG_FUNCTION(this);
+    NS_ASSERT(IsRitModeEnabled());
+
+    if (m_txQueue.empty())
+    {
+        return false; // No packets to transmit.
+    }
+
+    // If there is at least one packet queued, switch to sender mode and open
+    // the sender-side TX wait window (beacon wait window).
+    NS_ASSERT(m_ritMacMode != SENDER_MODE);
+    NS_LOG_DEBUG("tx queue size: " << static_cast<int>(m_txQueue.size()));
+
+    ChangeRitMacMode(SENDER_MODE);
+    StartRitTxWaitPeriod();
+    return true;
+}
+
+void
+RitWpanMac::ChangeRitMacMode(RitMacMode newMode)
+{
+    // Avoid redundant state transitions. This also prevents duplicate logs/traces
+    // when the mode is already set to the requested value.
+    if (m_ritMacMode == newMode)
+    {
+        NS_LOG_LOGIC(this << " RIT MAC mode unchanged: " << m_ritMacMode);
+        return;
+    }
+
+    NS_LOG_LOGIC(this << " change RIT MAC mode from " << m_ritMacMode << " to " << newMode);
+    m_ritMacMode = newMode;
+}
+
+Time
+RitWpanMac::DurationToTime(uint64_t duration) const
+{
+    // Convert a RIT "duration" value (in units of aBaseSuperframeDuration) into a Time.
+    // This path is valid only when the PIB parameters are used.
+    NS_ASSERT(!m_useTimeBasedRitParams);
+
+    const uint64_t symbols = duration * aBaseSuperframeDuration;
+    const double symbolRate = m_phy->GetDataOrSymbolRate(false); // symbols per second
+    return Seconds(static_cast<double>(symbols) / symbolRate);
+}
+
+bool
+RitWpanMac::IsRitModeEnabled() const
+{
+    // RIT is considered enabled when the configured period is positive.
+    // - Time-based mode: enabled iff macRitPeriodTime > 0
+    // - PIB mode : enabled iff macRitPeriod > 0
+    if (m_useTimeBasedRitParams)
+    {
+        return m_macRitPeriodTime.Get().IsPositive();
+    }
+    return m_macRitPeriod > 0u;
+}
+
+void
+RitWpanMac::SetPreCs(Ptr<RitWpanPreCs> preCs)
+{
+    // Inject the Pre-CS module implementation.
+    // The actual start/cancel decision is made in the TX path depending on the module flags.
+    NS_LOG_FUNCTION(this << preCs);
+    m_preCs = preCs;
+}
+
+void
+RitWpanMac::SetRxAlwaysOn(bool alwaysOn)
+{
+    NS_LOG_FUNCTION(this << alwaysOn);
+    // Configure whether the receiver should stay enabled even when the MAC is idle.
+    m_rxAlwaysOn = alwaysOn;
+}
+
+// Return the effective RIT period as a Time value.
+// Depending on the configuration, this is either taken directly from the
+// time-based parameter or converted from the legacy duration-based value.
+Time
+RitWpanMac::GetRitPeriodTime() const
+{
+    if (m_useTimeBasedRitParams)
+    {
+        return m_macRitPeriodTime;
+    }
+    else
+    {
+        return DurationToTime(m_macRitPeriod);
+    }
+}
+
+Time
+RitWpanMac::GetRitDataWaitDurationTime() const
+{
+    Time dataWaitDurationTime;
+
+    if (m_useTimeBasedRitParams)
+    {
+        dataWaitDurationTime = m_macRitDataWaitDurationTime.Get();
+    }
+    else
+    {
+        dataWaitDurationTime = DurationToTime(m_macRitDataWaitDuration);
+    }
+
+    // TODO: Consider dynamic adjustment of the receiver-side data wait duration.
+    return dataWaitDurationTime;
+}
+
+Time
+RitWpanMac::GetRitTxWaitDurationTime() const
+{
+    Time txWaitDurationTime;
+
+    if (m_useTimeBasedRitParams)
+    {
+        txWaitDurationTime = m_macRitTxWaitDurationTime;
+    }
+    else
+    {
+        txWaitDurationTime = DurationToTime(m_macRitTxWaitDuration);
+    }
+
+    // TODO: Consider dynamic adjustment of the sender-side beacon wait duration.
+    return txWaitDurationTime;
+}
+
+Time
+RitWpanMac::GetContinuousTxTimeoutTime() const
+{
+    // TODO: Accurately derive the extended data-reception wait time for continuous transmission.
+    //       This may depend on the last data TX duration or PHY parameters.
+    // return m_lastDataTxDuration;
+    return MilliSeconds(10);
+}
+
+void
+RitWpanMac::SetModuleConfig(const RitWpanMacModuleConfig& config)
+{
+    // Apply the RIT MAC module configuration (feature flags and behavior switches).
+    m_moduleConfig = config;
+}
+
+RitWpanMacModuleConfig
+RitWpanMac::GetModuleConfig() const
+{
+    // Return the current RIT MAC module configuration.
+    return m_moduleConfig;
+}
+
+void
+RitWpanMac::SetMlmeRitRequestIndicationCallback(MlmeRitRequestIndicationCallback cb)
+{
+    NS_LOG_FUNCTION(this << &cb);
+    // Register the MLME-RIT-REQ.indication callback.
+    // This callback is invoked when a valid RIT Data Request command is received.
+    m_mlmeRitRequestIndicationCallback = cb;
+}
+
+void
+RitWpanMac::SetRitModuleConfig(const RitWpanMacModuleConfig& config)
+{
+    NS_LOG_FUNCTION(this);
+    // Set the RIT MAC module configuration (feature flags and behavior options).
+    // This overwrites the current configuration without changing ongoing state.
+    m_moduleConfig = config;
+}
+
+
+} // namespace lrwpan
+} // namespace ns3
diff --git a/src/rit-wpan/model/rit-wpan-mac.h b/src/rit-wpan/model/rit-wpan-mac.h
new file mode 100644
index 0000000..5ef74c5
--- /dev/null
+++ b/src/rit-wpan/model/rit-wpan-mac.h
@@ -0,0 +1,393 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#ifndef RIT_WPAN_MAC_H
+#define RIT_WPAN_MAC_H
+
+#include "ns3/clock-drift-applier.h"
+#include "ns3/lr-wpan-mac-header.h"
+#include "ns3/lr-wpan-mac.h"
+#include "ns3/time-drift-applier.h"
+
+#include <cstdint>
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+class RitWpanPreCs;
+class RitWpanPreCsB;
+
+/**
+ * @brief Enum representing the MAC operation mode.
+ */
+enum RitMacMode
+{
+    RIT_MODE_DISABLED,
+    SENDER_MODE,
+    RECEIVER_MODE,
+    SLEEP_MODE,
+    BOOTSTRAP_MODE
+};
+
+/**
+ * @ingroup lr-wpan
+ *
+ * MLME-RIT-REQ.indication parameters.
+ * See IEEE 802.15.4-2020 8.2.25.1.
+ */
+struct MlmeRitRequestIndicationParams
+{
+    uint8_t m_srcAddrMode{0};   //!< Source address mode (NONE=0, SHORT=2, EXTENDED=3)
+    uint16_t m_srcPanId{0};     //!< Source PAN ID
+    Mac16Address m_srcAddr;     //!< Source short address (if applicable)
+    Mac64Address m_srcExtAddr;  //!< Source extended address (if applicable)
+
+    uint8_t m_dstAddrMode{0};   //!< Destination address mode (NONE=0, SHORT=2, EXTENDED=3)
+    uint16_t m_dstPanId{0};     //!< Destination PAN ID
+    Mac16Address m_dstAddr;     //!< Destination short address (if applicable)
+    Mac64Address m_dstExtAddr;  //!< Destination extended address (if applicable)
+
+    std::vector<uint8_t> m_ritRequestPayload; //!< RIT Request Payload field (octet stream)
+    // std::vector<HeaderIe> m_headerIeList;   //!< List of header IEs (excluding Termination IE)
+    // std::vector<PayloadIe> m_payloadIeList; //!< List of payload IEs (excluding Termination IE)
+
+    uint8_t m_linkQuality{0};   //!< LQI value (0x00 to 0xff)
+    uint8_t m_dsn{0};           //!< DSN of the received RIT Data Request command
+    uint32_t m_timestamp{0};    //!< Symbol-period timestamp of reception (accurate to 16 symbols)
+
+    uint8_t m_securityLevel{0}; //!< Security level (0x00 to 0x07)
+    uint8_t m_keyIdMode{0};     //!< Key ID mode (0x00 to 0x03)
+    uint64_t m_keySource{0};    //!< Key source (as in KeyIdMode)
+    uint8_t m_keyIndex{0};      //!< Key index
+};
+
+/**
+ * @ingroup lr-wpan
+ *
+ * MLME-RIT-REQ.response request parameters.
+ * See IEEE 802.15.4-2020 8.2.25.2.
+ */
+struct MlmeRitResponseRequestParams
+{
+    uint8_t m_srcAddrMode{0};   //!< Source address mode (NONE=0, SHORT=2, EXTENDED=3)
+    uint16_t m_srcPanId{0};     //!< Source PAN ID
+    Mac16Address m_srcAddr;     //!< Source short address (if applicable)
+    Mac64Address m_srcExtAddr;  //!< Source extended address (if applicable)
+
+    uint8_t m_dstAddrMode{0};   //!< Destination address mode (NONE=0, SHORT=2, EXTENDED=3)
+    uint16_t m_dstPanId{0};     //!< Destination PAN ID
+    Mac16Address m_dstAddr;     //!< Destination short address (if applicable)
+    Mac64Address m_dstExtAddr;  //!< Destination extended address (if applicable)
+
+    std::vector<uint8_t> m_ritResponsePayload; //!< RIT Response Payload field (octet stream)
+    // std::vector<HeaderIe> m_headerIeList;   //!< List of header IEs (excluding Termination IE)
+    // std::vector<PayloadIe> m_payloadIeList; //!< List of payload IEs (excluding Termination IE)
+
+    uint8_t m_linkQuality{0};   //!< LQI value (0x00 to 0xff)
+    uint8_t m_dsn{0};           //!< DSN of the received RIT Data Request command
+    uint32_t m_timestamp{0};    //!< Symbol-period timestamp of reception (accurate to 16 symbols)
+
+    uint8_t m_securityLevel{0}; //!< Security level (0x00 to 0x07)
+    uint8_t m_keyIdMode{0};     //!< Key ID mode (0x00 to 0x03)
+    uint64_t m_keySource{0};    //!< Key source (as in KeyIdMode)
+    uint8_t m_keyIndex{0};      //!< Key index
+};
+
+/**
+ * @ingroup lr-wpan
+ *
+ * MLME-RIT-RES.indication parameters.
+ * See IEEE 802.15.4-2020 8.2.25.3.
+ */
+struct MlmeRitResponseIndicationParams
+{
+    uint8_t m_srcAddrMode{0};   //!< Source address mode (NONE=0, SHORT=2, EXTENDED=3)
+    uint16_t m_srcPanId{0};     //!< Source PAN ID
+    Mac16Address m_srcAddr;     //!< Source short address (if applicable)
+    Mac64Address m_srcExtAddr;  //!< Source extended address (if applicable)
+
+    uint8_t m_dstAddrMode{0};   //!< Destination address mode (NONE=0, SHORT=2, EXTENDED=3)
+    uint16_t m_dstPanId{0};     //!< Destination PAN ID
+    Mac16Address m_dstAddr;     //!< Destination short address (if applicable)
+    Mac64Address m_dstExtAddr;  //!< Destination extended address (if applicable)
+
+    std::vector<uint8_t> m_ritResponsePayload; //!< RIT Response Payload field (octet stream)
+    // std::vector<HeaderIe> m_headerIeList;   //!< List of header IEs (excluding Termination IE)
+    // std::vector<PayloadIe> m_payloadIeList; //!< List of payload IEs (excluding Termination IE)
+
+    uint8_t m_linkQuality{0};   //!< LQI value (0x00 to 0xff)
+    uint8_t m_dsn{0};           //!< DSN of the received RIT Data Request command
+    uint32_t m_timestamp{0};    //!< Symbol-period timestamp of reception (accurate to 16 symbols)
+
+    uint8_t m_securityLevel{0}; //!< Security level (0x00 to 0x07)
+    uint8_t m_keyIdMode{0};     //!< Key ID mode (0x00 to 0x03)
+    uint64_t m_keySource{0};    //!< Key source (as in KeyIdMode)
+    uint8_t m_keyIndex{0};      //!< Key index
+};
+
+/**
+ * @ingroup lr-wpan
+ *
+ * MLME-RIT-RES.confirm parameters.
+ * See IEEE 802.15.4-2020 8.2.25.4.
+ */
+struct MlmeRitResponseConfirmParams
+{
+    MacStatus m_status{MacStatus::INVALID_PARAMETER};
+};
+
+using MlmeRitRequestIndicationCallback =
+    Callback<void, MlmeRitRequestIndicationParams>; //!< Callback for MLME-RIT-REQ.indication
+
+using MlmeRitRequestConfirmCallback =
+    Callback<void, MacStatus>; //!< Callback for MLME-RIT-REQ.confirm
+
+using MlmeRitResponseIndicationCallback =
+    Callback<void, MlmeRitResponseIndicationParams>; //!< Callback for MLME-RIT-RES.indication
+
+using MlmeRitResponseConfirmCallback =
+    Callback<void, MacStatus>; //!< Callback for MLME-RIT-RES.confirm
+
+/**
+ * @ingroup lr-wpan
+ *
+ * @brief Configuration flags for RitWpanMac.
+ *
+ * This structure enables/disables optional MAC mechanisms used in the evaluation.
+ */
+struct RitWpanMacModuleConfig
+{
+    // Data transmission options
+    bool dataCsmaEnabled = false;
+    bool dataPreCsEnabled = false;
+    bool dataPreCsBEnabled = false; //!< Enable Pre-CSB for data transmission
+
+    // Beacon transmission options
+    bool beaconCsmaEnabled = false;
+    bool beaconPreCsEnabled = false;
+    bool beaconPreCsBEnabled = false; //!< Enable Pre-CSB for beacon transmission
+
+    // Additional mechanisms
+    bool continuousTxEnabled = false;
+    bool beaconRandomizeEnabled = false;
+    bool compactRitDataRequestEnabled = false;
+    bool beaconAckEnabled = false;
+};
+
+class RitWpanMac : public LrWpanMac
+{
+  public:
+    static TypeId GetTypeId();
+    RitWpanMac();
+    ~RitWpanMac() override;
+
+    /**
+     * @brief MCPS-DATA.request from upper layer.
+     *
+     * The packet is enqueued and is not transmitted immediately.
+     */
+    void McpsDataRequest(McpsDataRequestParams params, Ptr<Packet> p) override;
+
+    /**
+     * @brief MLME-SET.request (PIB attribute update) from upper layer.
+     * @param id Attribute identifier
+     * @param attribute Attribute value
+     */
+    void MlmeSetRequest(MacPibAttributeIdentifier id, Ptr<MacPibAttributes> attribute) override;
+
+    /**
+     * @brief MLME-GET.request from upper layer.
+     * @param id Attribute identifier
+     */
+    void MlmeGetRequest(MacPibAttributeIdentifier id) override;
+
+    /**
+     * @brief PLME-SET-TRX-STATE.confirm callback from PHY layer.
+     */
+    void PlmeSetTRXStateConfirm(PhyEnumeration status) override;
+
+    /**
+     * @brief Set the MAC state.
+     */
+    void SetLrWpanMacState(MacState macState) override;
+
+    /**
+     * @brief Set callback for MLME-RIT-REQ.indication.
+     */
+    void SetMlmeRitRequestIndicationCallback(MlmeRitRequestIndicationCallback c);
+
+    /**
+     * @brief PD-DATA.indication callback from PHY layer.
+     */
+    void PdDataIndication(uint32_t psduLength, Ptr<Packet> p, uint8_t lqi) override;
+
+    /**
+     * @brief PD-DATA.confirm callback from PHY layer.
+     */
+    void PdDataConfirm(PhyEnumeration status) override;
+
+    /**
+     * @brief IFS wait timeout handler.
+     */
+    void IfsWaitTimeout(Time ifsTime) override;
+
+    void SetModuleConfig(const RitWpanMacModuleConfig& config);
+    RitWpanMacModuleConfig GetModuleConfig() const;
+
+    /**
+     * @brief Set RIT module configuration (alias for SetModuleConfig).
+     */
+    void SetRitModuleConfig(const RitWpanMacModuleConfig& config);
+
+    void SetPreCs(Ptr<RitWpanPreCs> preCs);
+
+    /**
+     * @brief Trigger RIT data transmission (sender-side).
+     */
+    void SendRitData();
+
+    /**
+     * @brief Set receiver always-on behavior (e.g., for a parent node).
+     */
+    void SetRxAlwaysOn(bool alwaysOn);
+
+    // Time-based parameter getters
+    Time GetRitPeriodTime() const;
+    Time GetRitDataWaitDurationTime() const;
+    Time GetRitTxWaitDurationTime() const;
+
+    /**
+     * @brief Duration of the last data transmission round-trip.
+     *
+     * Used for continuous transmission timeout calculation.
+     */
+    Time m_lastDataTxDuration;
+
+    /**
+     * @brief Start time of the last data transmission.
+     */
+    Time m_lastDataTxStartTime;
+
+  private:
+    void DoInitialize() override;
+    void DoDispose() override;
+
+    void Sleep();
+    void Bootstrap();
+    void RelayRequest(Ptr<Packet> relayPkt);
+
+    void ChangeRitMacMode(RitMacMode ritMacMode);
+
+    void PeriodicRitDataRequest(); //!< Periodic RIT data request in sender mode
+    void DoSendRitData();          //!< Process RIT data transmission
+    void DoSendRitDataRequest();   //!< Send RIT Data Request command
+    void DoSendRitBeaconAck();     //!< Send RIT Beacon Acknowledgment command
+
+    void ReceiveCommand(uint8_t lqi, Ptr<Packet> p);
+    void ReceiveData(uint8_t lqi, Ptr<Packet> p);
+
+    void StartRitDataWaitPeriod();
+    void StartRitTxWaitPeriod();
+
+    /**
+     * @brief Start the RIT cycle (request, waiting, etc.).
+     */
+    void StartRitCycle();
+
+    /**
+     * @brief Stop the RIT cycle.
+     */
+    void StopRitCycle();
+
+    void SenderCycleTimeout();   //!< Timeout for sender cycle
+    void EndSenderCycle();       //!< End sender cycle after transmission
+    void ReceiverCycleTimeout(); //!< Timeout for receiver cycle
+    void EndReceiverCycle();     //!< End receiver cycle after reception
+
+    /**
+     * @brief ACK wait timeout handler.
+     */
+    void AckWaitTimeout() override;
+
+    void SetWakeUp(); //!< Set MAC into wake-up state
+    void SetSleep();  //!< Set MAC into sleep state
+
+    bool CheckTxAndStartSender();
+    bool IsRitModeEnabled() const;
+    Time DurationToTime(uint64_t duration) const;
+
+    /**
+     * @brief Get timeout duration for continuous transmission mode.
+     *
+     * The timeout can be adjusted using module configuration and internal state.
+     */
+    Time GetContinuousTxTimeoutTime() const;
+
+    /* Member variables */
+
+    // Behavior flags
+    bool m_rxAlwaysOn;            //!< Receiver always-on flag (e.g., for a parent device)
+    bool m_continuousRxEnabled;   //!< Continuous reception enable flag
+
+    bool m_useTimeBasedRitParams = true; //!< Use time-based RIT parameters
+    bool m_ritSending = false;           //!< Whether RIT data is currently being sent
+
+    // RIT parameters (IEEE 802.15.4-2020)
+    TracedValue<uint32_t> m_macRitPeriod; //!< RIT interval (0x000000 ~ 0xFFFFFF)
+    TracedValue<uint8_t> m_macRitDataWaitDuration; //!< RX wait after RIT (0x00 ~ 0xFF)
+    TracedValue<uint32_t> m_macRitTxWaitDuration; //!< Beacon wait (>= macRitPeriod, up to 0xFFFFFF)
+    std::vector<uint8_t> m_macRitRequestPayload; //!< Payload for RIT command transmission
+
+    // Time-based RIT parameters
+    TracedValue<Time> m_macRitPeriodTime;           //!< RIT period time
+    TracedValue<Time> m_macRitDataWaitDurationTime; //!< RIT data wait duration time
+    TracedValue<Time> m_macRitTxWaitDurationTime;   //!< RIT transmission wait duration time
+
+    // RIT mode
+    TracedValue<RitMacMode> m_ritMacMode; //!< Current RIT MAC mode
+
+    // RIT events
+    EventId m_ritDataWaitTimeout;          //!< Data wait timeout event
+    EventId m_ritTxWaitTimeout;            //!< TX wait timeout event
+    EventId m_periodicRitDataRequestEvent; //!< Periodic data request event
+
+    MlmeRitRequestIndicationCallback m_mlmeRitRequestIndicationCallback; //!< MLME-RIT-REQ.indication
+
+    Mac16Address m_lastRxRitReqFrameSrcAddr; //!< Source address of last received RIT request frame
+
+    Ptr<TimeDriftApplier> m_timeDriftApplier;   //!< Used for beacon interval randomization
+    Ptr<ClockDriftApplier> m_clockDriftApplier; //!< Used for clock drift correction
+
+    Ptr<RitWpanPreCs> m_preCs;     //!< Pre-CS implementation
+    Ptr<RitWpanPreCsB> m_preCsB;   //!< Pre-CSB implementation
+
+    RitWpanMacModuleConfig m_moduleConfig;
+
+    // Trace: MAC timeout events
+    TracedCallback<Time, std::string> m_macTimeoutEventTrace;
+
+    // Trace values for timeout durations
+    TracedValue<Time> m_beaconWaitTimeoutTime;
+    TracedValue<Time> m_dataWaitTimeoutTime;
+
+    // Measurement: start times for waiting
+    Time m_beaconWaitStartTime;
+    Time m_dataWaitStartTime;
+
+    // Trace: measured waiting durations
+    TracedCallback<std::string, Time> m_beaconWaitTrace;
+    TracedCallback<std::string, Time> m_dataWaitTrace;
+};
+
+} // namespace lrwpan
+} // namespace ns3
+
+#endif /* RIT_WPAN_MAC_H */
diff --git a/src/rit-wpan/model/rit-wpan-net-device.cc b/src/rit-wpan/model/rit-wpan-net-device.cc
new file mode 100644
index 0000000..b7949e7
--- /dev/null
+++ b/src/rit-wpan/model/rit-wpan-net-device.cc
@@ -0,0 +1,465 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#include "rit-wpan-net-device.h"
+
+#include "ns3/abort.h"
+#include "ns3/log.h"
+#include "ns3/lr-wpan-error-model.h"
+#include "ns3/node.h"
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+NS_LOG_COMPONENT_DEFINE("RitWpanNetDevice");
+NS_OBJECT_ENSURE_REGISTERED(RitWpanNetDevice);
+
+TypeId
+RitWpanNetDevice::GetTypeId()
+{
+    static TypeId tid =
+        TypeId("ns3::RitWpanNetDevice")
+            .SetParent<NetDevice>()
+            .SetGroupName("LrWpan")
+            .AddConstructor<RitWpanNetDevice>()
+            .AddAttribute("Channel",
+                          "The channel attached to this device",
+                          PointerValue(),
+                          MakePointerAccessor(&RitWpanNetDevice::DoGetChannel),
+                          MakePointerChecker<SpectrumChannel>())
+            .AddAttribute("Phy",
+                          "The PHY layer attached to this device.",
+                          PointerValue(),
+                          MakePointerAccessor(&RitWpanNetDevice::GetPhy, &RitWpanNetDevice::SetPhy),
+                          MakePointerChecker<LrWpanPhy>())
+            .AddAttribute("Mac",
+                          "The MAC layer attached to this device.",
+                          PointerValue(),
+                          MakePointerAccessor(&RitWpanNetDevice::GetMac, &RitWpanNetDevice::SetMac),
+                          MakePointerChecker<RitWpanMac>())
+            .AddAttribute("Nwk",
+                          "The NWK layer attached to this device.",
+                          PointerValue(),
+                          MakePointerAccessor(&RitWpanNetDevice::GetNwk, &RitWpanNetDevice::SetNwk),
+                          MakePointerChecker<RitSimpleRouting>());
+    return tid;
+}
+
+RitWpanNetDevice::RitWpanNetDevice()
+{
+    NS_LOG_FUNCTION_NOARGS();
+
+    m_rank = 0;
+    m_configComplete = false;
+    m_receiveCallback.Nullify();
+
+    // Construct stack objects (default).
+    m_phy = CreateObject<LrWpanPhy>();
+    m_mac = CreateObject<RitWpanMac>();
+    m_nwk = CreateObject<RitSimpleRouting>();
+
+    m_csmaca = CreateObject<LrWpanCsmaCa>();
+    m_precs = CreateObject<RitWpanPreCs>();
+    m_precsb = CreateObject<RitWpanPreCsB>();
+
+    m_channel = nullptr;
+    m_node = nullptr;
+}
+
+RitWpanNetDevice::~RitWpanNetDevice()
+{
+    NS_LOG_FUNCTION_NOARGS();
+}
+
+void
+RitWpanNetDevice::DoDispose()
+{
+    NS_LOG_FUNCTION_NOARGS();
+
+    m_phy->Dispose();
+    m_mac->Dispose();
+    m_nwk->Dispose();
+    m_csmaca->Dispose();
+    m_precs->Dispose();
+    m_precsb->Dispose();
+
+    m_phy = nullptr;
+    m_mac = nullptr;
+    m_nwk = nullptr;
+    m_csmaca = nullptr;
+    m_precs = nullptr;
+    m_precsb = nullptr;
+
+    m_channel = nullptr;
+    m_node = nullptr;
+
+    NetDevice::DoDispose();
+}
+
+void
+RitWpanNetDevice::DoInitialize()
+{
+    NS_LOG_FUNCTION_NOARGS();
+
+    m_phy->Initialize();
+    m_mac->Initialize();
+
+    CompleteConfig();
+
+    NetDevice::DoInitialize();
+}
+
+void
+RitWpanNetDevice::CompleteConfig()
+{
+    NS_LOG_FUNCTION_NOARGS();
+
+    // Apply wiring only once, and only after all components exist.
+    if (m_configComplete)
+    {
+        return;
+    }
+    if (!m_node || !m_phy || !m_mac || !m_nwk || !m_csmaca || !m_precs || !m_precsb)
+    {
+        return;
+    }
+
+    // --- Layer registration / wiring ---
+    m_nwk->SetMac(m_mac);
+
+    m_mac->SetPhy(m_phy);
+    m_mac->SetCsmaCa(m_csmaca);
+    m_mac->SetPreCs(m_precs);
+    m_mac->SetPreCsB(m_precsb);
+
+    m_csmaca->SetMac(m_mac);
+    m_precs->SetMac(m_mac);
+    m_precsb->SetMac(m_mac);
+
+    // PHY error model + device back-pointer.
+    Ptr<LrWpanErrorModel> model = CreateObject<LrWpanErrorModel>();
+    m_phy->SetErrorModel(model);
+    m_phy->SetDevice(this);
+
+    // Rank propagation (NetDevice -> NWK).
+    m_nwk->SetRank(m_rank);
+
+    // --- Callback wiring ---
+    // NWK -> NetDevice -> upper layer.
+    m_nwk->SetNwkRxCallback(MakeCallback(&RitWpanNetDevice::OnNwkReceive, this));
+
+    // MAC callbacks to NWK.
+    m_mac->SetMlmeRitRequestIndicationCallback(
+        MakeCallback(&RitSimpleRouting::MlmeRitRequestIndication, m_nwk));
+    m_mac->SetMcpsDataIndicationCallback(
+        MakeCallback(&RitSimpleRouting::McpsDataIndication, m_nwk));
+    m_mac->SetMcpsDataConfirmCallback(MakeCallback(&RitSimpleRouting::McpsDataConfirm, m_nwk));
+
+    // PHY callbacks to MAC.
+    m_phy->SetPdDataIndicationCallback(MakeCallback(&RitWpanMac::PdDataIndication, m_mac));
+    m_phy->SetPdDataConfirmCallback(MakeCallback(&RitWpanMac::PdDataConfirm, m_mac));
+    m_phy->SetPlmeGetAttributeConfirmCallback(
+        MakeCallback(&RitWpanMac::PlmeGetAttributeConfirm, m_mac));
+    m_phy->SetPlmeSetTRXStateConfirmCallback(
+        MakeCallback(&RitWpanMac::PlmeSetTRXStateConfirm, m_mac));
+    m_phy->SetPlmeSetAttributeConfirmCallback(
+        MakeCallback(&RitWpanMac::PlmeSetAttributeConfirm, m_mac));
+
+    // Carrier sense chain (PreCsB -> PreCs -> CSMA/CA).
+    m_phy->SetPlmeCcaConfirmCallback(MakeCallback(&RitWpanPreCsB::PlmeCcaConfirm, m_precsb));
+    m_precsb->SetFallbackCcaConfirmCallback(MakeCallback(&RitWpanPreCs::PlmeCcaConfirm, m_precs));
+    m_precs->SetFallbackCcaConfirmCallback(MakeCallback(&LrWpanCsmaCa::PlmeCcaConfirm, m_csmaca));
+
+    // State callbacks back to MAC.
+    m_csmaca->SetLrWpanMacStateCallback(MakeCallback(&RitWpanMac::SetLrWpanMacState, m_mac));
+    m_precs->SetLrWpanMacStateCallback(MakeCallback(&RitWpanMac::SetLrWpanMacState, m_mac));
+    m_precsb->SetLrWpanMacStateCallback(MakeCallback(&RitWpanMac::SetLrWpanMacState, m_mac));
+
+    // --- Apply RIT PIB parameters (stored in this NetDevice) ---
+    Ptr<MacPibAttributes> pibAttr = Create<MacPibAttributes>();
+
+    pibAttr->macRitDataWaitDurationTime = m_macRitDataWaitDuration;
+    m_mac->MlmeSetRequest(macRitDataWaitDurationTime, pibAttr);
+
+    pibAttr->macRitTxWaitDurationTime = m_macRitTxWaitDuration;
+    m_mac->MlmeSetRequest(macRitTxWaitDurationTime, pibAttr);
+
+    pibAttr->macRitPeriodTime = m_macRitPeriod;
+    m_mac->MlmeSetRequest(macRitPeriodTime, pibAttr);
+
+    // Module config (CSMA / Pre-CS / Pre-CSB / ACK / Randomization / etc.)
+    m_mac->SetModuleConfig(m_moduleConfig);
+
+    m_configComplete = true;
+}
+
+void
+RitWpanNetDevice::SetNwk(Ptr<RitSimpleRouting> nwk)
+{
+    NS_LOG_FUNCTION(this);
+    m_nwk = nwk;
+    CompleteConfig();
+}
+
+void
+RitWpanNetDevice::SetMac(Ptr<RitWpanMac> mac)
+{
+    NS_LOG_FUNCTION(this);
+    m_mac = mac;
+    CompleteConfig();
+}
+
+void
+RitWpanNetDevice::SetPhy(Ptr<LrWpanPhy> phy)
+{
+    NS_LOG_FUNCTION(this);
+    m_phy = phy;
+    CompleteConfig();
+}
+
+void
+RitWpanNetDevice::SetCsmaCa(Ptr<LrWpanCsmaCa> csmaca)
+{
+    NS_LOG_FUNCTION(this);
+    m_csmaca = csmaca;
+    CompleteConfig();
+}
+
+void
+RitWpanNetDevice::SetChannel(Ptr<SpectrumChannel> channel)
+{
+    NS_LOG_FUNCTION(this);
+    m_channel = channel;
+    m_phy->SetChannel(channel);
+    channel->AddRx(m_phy);
+}
+
+void
+RitWpanNetDevice::SetRitRank(uint8_t rank)
+{
+    NS_LOG_FUNCTION(this);
+    m_rank = rank;
+
+    if (m_nwk)
+    {
+        m_nwk->SetRank(rank);
+    }
+    else
+    {
+        // (should not happen with default construction)
+        NS_LOG_WARN("SetRitRank called before NWK is available; rank will be applied later.");
+    }
+}
+
+uint8_t
+RitWpanNetDevice::GetRitRank() const
+{
+    return m_rank;
+}
+
+void
+RitWpanNetDevice::SetMacRitPeriod(Time macRitPeriod)
+{
+    m_macRitPeriod = macRitPeriod;
+}
+
+void
+RitWpanNetDevice::SetMacRitDataWaitDuration(Time macRitDataWaitDuration)
+{
+    m_macRitDataWaitDuration = macRitDataWaitDuration;
+}
+
+void
+RitWpanNetDevice::SetMacRitTxWaitDuration(Time macRitTxWaitDuration)
+{
+    m_macRitTxWaitDuration = macRitTxWaitDuration;
+}
+
+void
+RitWpanNetDevice::SetRitModuleConfig(const RitWpanMacModuleConfig& config)
+{
+    NS_LOG_FUNCTION(this);
+
+    // Mutual exclusion checks (same as your original intent).
+    int dataTxModes = 0;
+    dataTxModes += config.dataCsmaEnabled ? 1 : 0;
+    dataTxModes += config.dataPreCsEnabled ? 1 : 0;
+    dataTxModes += config.dataPreCsBEnabled ? 1 : 0;
+    if (dataTxModes > 1)
+    {
+        NS_FATAL_ERROR("Invalid module config: only one of dataCsmaEnabled, dataPreCsEnabled, "
+                       "or dataPreCsBEnabled can be true.");
+    }
+
+    int beaconTxModes = 0;
+    beaconTxModes += config.beaconCsmaEnabled ? 1 : 0;
+    beaconTxModes += config.beaconPreCsEnabled ? 1 : 0;
+    beaconTxModes += config.beaconPreCsBEnabled ? 1 : 0;
+    if (beaconTxModes > 1)
+    {
+        NS_FATAL_ERROR("Invalid module config: only one of beaconCsmaEnabled, beaconPreCsEnabled, "
+                       "or beaconPreCsBEnabled can be true.");
+    }
+
+    m_moduleConfig = config;
+
+    // If MAC already exists, propagate immediately.
+    if (m_mac)
+    {
+        m_mac->SetModuleConfig(config);
+    }
+}
+
+Ptr<RitSimpleRouting>
+RitWpanNetDevice::GetNwk() const
+{
+    NS_LOG_FUNCTION(this);
+    return m_nwk;
+}
+
+Ptr<RitWpanMac>
+RitWpanNetDevice::GetMac() const
+{
+    NS_LOG_FUNCTION(this);
+    return m_mac;
+}
+
+Ptr<LrWpanPhy>
+RitWpanNetDevice::GetPhy() const
+{
+    NS_LOG_FUNCTION(this);
+    return m_phy;
+}
+
+Ptr<LrWpanCsmaCa>
+RitWpanNetDevice::GetCsmaCa() const
+{
+    NS_LOG_FUNCTION(this);
+    return m_csmaca;
+}
+
+Ptr<Channel>
+RitWpanNetDevice::GetChannel() const
+{
+    NS_LOG_FUNCTION(this);
+    return m_phy->GetChannel();
+}
+
+Ptr<SpectrumChannel>
+RitWpanNetDevice::DoGetChannel() const
+{
+    NS_LOG_FUNCTION(this);
+    return m_phy->GetChannel();
+}
+
+void
+RitWpanNetDevice::Send(Ptr<Packet> packet, Mac16Address m16DstAddr)
+{
+    NS_LOG_FUNCTION(this << packet);
+
+    // Non-IP: delegate to NWK layer.
+    m_nwk->SendRequest(packet, m16DstAddr);
+}
+
+bool
+RitWpanNetDevice::Send(Ptr<Packet> packet, const Address& dest, uint16_t protocolNumber)
+{
+    (void)protocolNumber; // unused for non-IP device
+    Send(packet, Mac16Address::ConvertFrom(dest));
+    return true;
+}
+
+void
+RitWpanNetDevice::SetReceiveCallback(ReceiveCallback cb)
+{
+    NS_LOG_FUNCTION_NOARGS();
+    m_receiveCallback = cb;
+}
+
+void
+RitWpanNetDevice::SetNode(Ptr<Node> node)
+{
+    m_node = node;
+    CompleteConfig();
+}
+
+Ptr<Node>
+RitWpanNetDevice::GetNode() const
+{
+    return m_node;
+}
+
+void
+RitWpanNetDevice::SetAddress(Address address)
+{
+    NS_LOG_FUNCTION(this);
+    if (Mac16Address::IsMatchingType(address))
+    {
+        const auto a = Mac16Address::ConvertFrom(address);
+        m_mac->SetShortAddress(a);
+        m_nwk->SetShortAddress(a);
+    }
+}
+
+Address
+RitWpanNetDevice::GetAddress() const
+{
+    NS_LOG_FUNCTION(this);
+    // Your original returns empty Address(). Keep it to preserve behavior.
+    return Address();
+}
+
+void
+RitWpanNetDevice::SetIfIndex(const uint32_t index)
+{
+    NS_LOG_FUNCTION(this << index);
+    (void)index; // non-IP device: keep no ifIndex state (same behavior)
+}
+
+uint32_t
+RitWpanNetDevice::GetIfIndex() const
+{
+    NS_LOG_FUNCTION(this);
+    // Your original returns 0. Keep it to preserve behavior.
+    return 0;
+}
+
+bool
+RitWpanNetDevice::IsLinkUp() const
+{
+    NS_LOG_FUNCTION(this);
+    return m_phy != nullptr;
+}
+
+void
+RitWpanNetDevice::McpsDataIndication(McpsDataIndicationParams params, Ptr<Packet> pkt)
+{
+    NS_LOG_FUNCTION_NOARGS();
+
+    // This path is not used by your current wiring (NWK handles it),
+    // but keep it as-is for compatibility.
+    if (params.m_dstAddrMode == SHORT_ADDR)
+    {
+        m_receiveCallback(this, pkt, 0, params.m_srcAddr);
+    }
+}
+
+void
+RitWpanNetDevice::OnNwkReceive(Ptr<Packet> packet, const Mac16Address& srcAddr)
+{
+    NS_LOG_FUNCTION(this << packet << srcAddr);
+    NS_LOG_DEBUG("[RIT-NWK] Received packet from " << srcAddr);
+
+    // Forward to upper layer (Application's ReceiveCallback is installed on NetDevice).
+    m_receiveCallback(this, packet, 0, srcAddr);
+}
+
+} // namespace lrwpan
+} // namespace ns3
diff --git a/src/rit-wpan/model/rit-wpan-net-device.h b/src/rit-wpan/model/rit-wpan-net-device.h
new file mode 100644
index 0000000..ad0214e
--- /dev/null
+++ b/src/rit-wpan/model/rit-wpan-net-device.h
@@ -0,0 +1,154 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#ifndef RIT_WPAN_NET_DEVICE_H
+#define RIT_WPAN_NET_DEVICE_H
+
+#include "rit-wpan-mac.h"
+#include "rit-wpan-nwk.h"
+#include "rit-wpan-precs.h"
+#include "rit-wpan-precsb.h"
+
+#include <ns3/lr-wpan-csmaca.h>
+#include <ns3/lr-wpan-phy.h>
+#include <ns3/net-device.h>
+#include <ns3/simulator.h>
+#include <ns3/spectrum-channel.h>
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+/**
+ * \ingroup ri-pan
+ *
+ * \brief NetDevice implementation for RIT-based IEEE 802.15.4 networks.
+ *
+ * RitWpanNetDevice integrates PHY, RIT-MAC, and a lightweight
+ * rank-based network layer into a single NetDevice abstraction.
+ *
+ * This device is designed for experimental evaluation of
+ * receiver-initiated (RIT) MAC protocols and simple
+ * rank-based data collection routing in low-power wireless sensor networks.
+ *
+ * \note This NetDevice does not support IP, ARP, or SendFrom().
+ */
+class RitWpanNetDevice : public NetDevice
+{
+  public:
+    static TypeId GetTypeId();
+
+    RitWpanNetDevice();
+    ~RitWpanNetDevice() override;
+
+    /* ---- Layer setters ---- */
+    void SetNwk(Ptr<RitSimpleRouting> nwk);
+    void SetMac(Ptr<RitWpanMac> mac);
+    void SetPhy(Ptr<LrWpanPhy> phy);
+    void SetCsmaCa(Ptr<LrWpanCsmaCa> csmaca);
+    void SetChannel(Ptr<SpectrumChannel> channel);
+
+    /* ---- RIT-specific configuration ---- */
+    void SetRitRank(uint8_t rank);
+    void SetMacRitPeriod(Time macRitPeriod);
+    void SetMacRitDataWaitDuration(Time macRitDataWaitDuration);
+    void SetMacRitTxWaitDuration(Time macRitTxWaitDuration);
+    void SetRitModuleConfig(const RitWpanMacModuleConfig& config);
+
+    /* ---- Layer getters ---- */
+    Ptr<RitSimpleRouting> GetNwk() const;
+    Ptr<RitWpanMac> GetMac() const;
+    Ptr<LrWpanPhy> GetPhy() const;
+    Ptr<LrWpanCsmaCa> GetCsmaCa() const;
+
+    Ptr<Channel> GetChannel() const override;
+    uint8_t GetRitRank() const;
+
+    /* ---- Packet transmission ---- */
+    void Send(Ptr<Packet> packet, Mac16Address dst);
+    bool Send(Ptr<Packet> packet, const Address& dest, uint16_t protocolNumber) override;
+
+    /* ---- NetDevice API (used) ---- */
+    void SetReceiveCallback(ReceiveCallback cb) override;
+    void SetNode(Ptr<Node> node) override;
+    Ptr<Node> GetNode() const override;
+    void SetAddress(Address address) override;
+    void SetAddress(uint32_t address);
+    Address GetAddress() const override;
+
+    bool IsLinkUp() const override;
+
+    /* ---- NetDevice API (not supported) ---- */
+    void SetIfIndex(uint32_t index) override {}
+    uint32_t GetIfIndex() const override { return 0; }
+
+    bool SetMtu(uint16_t mtu) override { return false; }
+    uint16_t GetMtu() const override { return 0; }
+
+    void AddLinkChangeCallback(Callback<void>) override {}
+    bool IsBroadcast() const override { return true; }
+    Address GetBroadcast() const override { return Address(); }
+
+    bool IsMulticast() const override { return true; }
+    Address GetMulticast(Ipv4Address) const override { return Address(); }
+    Address GetMulticast(Ipv6Address) const override { return Address(); }
+
+    bool IsBridge() const override { return false; }
+    bool IsPointToPoint() const override { return false; }
+
+    bool SendFrom(Ptr<Packet>, const Address&, const Address&, uint16_t) override
+    {
+        return false;
+    }
+
+    bool NeedsArp() const override { return false; }
+    void SetPromiscReceiveCallback(PromiscReceiveCallback) override {}
+    bool SupportsSendFrom() const override { return false; }
+
+    /* ---- MAC  NetDevice entry point ---- */
+    void McpsDataIndication(McpsDataIndicationParams params, Ptr<Packet> pkt);
+
+  protected:
+    void ForwardUp(Ptr<Packet>, Mac48Address, Mac48Address) override {}
+
+  private:
+    void DoDispose() override;
+    void DoInitialize() override;
+
+    Ptr<SpectrumChannel> DoGetChannel() const;
+    void CompleteConfig();
+    void OnNwkReceive(Ptr<Packet> packet, const Mac16Address& srcAddr);
+
+    /* ---- Core components ---- */
+    Ptr<Node> m_node;
+    Ptr<LrWpanPhy> m_phy;
+    Ptr<RitWpanMac> m_mac;
+    Ptr<RitSimpleRouting> m_nwk;
+    Ptr<LrWpanCsmaCa> m_csmaca;
+    Ptr<RitWpanPreCs> m_precs;
+    Ptr<RitWpanPreCsB> m_precsb;
+
+    uint8_t m_rank;
+    bool m_configComplete;
+
+    /* ---- RIT timing parameters ---- */
+    Time m_macRitPeriod;
+    Time m_macRitDataWaitDuration;
+    Time m_macRitTxWaitDuration;
+
+    RitWpanMacModuleConfig m_moduleConfig;
+
+    ReceiveCallback m_receiveCallback;
+};
+
+} // namespace lrwpan
+} // namespace ns3
+
+#endif // RIT_WPAN_NET_DEVICE_H
diff --git a/src/rit-wpan/model/rit-wpan-nwk-header.cc b/src/rit-wpan/model/rit-wpan-nwk-header.cc
new file mode 100644
index 0000000..1036d23
--- /dev/null
+++ b/src/rit-wpan/model/rit-wpan-nwk-header.cc
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+/*
+ * NOTE [EXPERIMENTAL / SIMPLIFIED NETWORK HEADER]:
+ *
+ * This header defines a minimal network-layer header used by the
+ * simplified rank-based routing mechanism for RIT-WPAN evaluation.
+ *
+ * The header carries only the essential information required for
+ * rank-based forwarding:
+ *  - Node rank
+ *  - Source short address
+ *  - Destination short address
+ *
+ * It is intentionally compact and does not aim to be compatible
+ * with any standardized NWK-layer format.
+ */
+
+
+#include "rit-wpan-nwk-header.h"
+
+#include "ns3/address-utils.h"
+
+#include <cstdint>
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+RitNwkHeader::RitNwkHeader()
+{
+    // Default rank initialization
+    SetRank(0);
+}
+
+RitNwkHeader::~RitNwkHeader()
+{
+}
+
+void
+RitNwkHeader::SetRank(uint16_t rank)
+{
+    m_rank = rank;
+}
+
+uint16_t
+RitNwkHeader::GetRank() const
+{
+    return m_rank;
+}
+
+void
+RitNwkHeader::SetSrcAddr(Mac16Address addr)
+{
+    m_srcAddr = addr;
+}
+
+Mac16Address
+RitNwkHeader::GetSrcAddr() const
+{
+    return m_srcAddr;
+}
+
+void
+RitNwkHeader::SetDstAddr(Mac16Address addr)
+{
+    m_dstAddr = addr;
+}
+
+Mac16Address
+RitNwkHeader::GetDstAddr() const
+{
+    return m_dstAddr;
+}
+
+void
+RitNwkHeader::Serialize(Buffer::Iterator start) const
+{
+    Buffer::Iterator i = start;
+
+    // Serialize fields in fixed order:
+    // 1) Rank
+    // 2) Source short address
+    // 3) Destination short address
+    i.WriteU16(m_rank);
+    WriteTo(i, m_srcAddr);
+    WriteTo(i, m_dstAddr);
+}
+
+uint32_t
+RitNwkHeader::Deserialize(Buffer::Iterator start)
+{
+    Buffer::Iterator i = start;
+
+    // Deserialize fields in the same order as serialization
+    m_rank = i.ReadU16();
+    ReadFrom(i, m_srcAddr);
+    ReadFrom(i, m_dstAddr);
+
+    return i.GetDistanceFrom(start);
+}
+
+uint32_t
+RitNwkHeader::GetSerializedSize() const
+{
+    // Rank: 2 bytes
+    // Source address: 2 bytes
+    // Destination address: 2 bytes
+    return 6;
+}
+
+TypeId
+RitNwkHeader::GetTypeId()
+{
+    static TypeId tid =
+        TypeId("ns3::lrwpan::RitNwkHeader")
+            .SetParent<Header>()
+            .SetGroupName("LrWpan")
+            .AddConstructor<RitNwkHeader>();
+
+    return tid;
+}
+
+TypeId
+RitNwkHeader::GetInstanceTypeId() const
+{
+    return GetTypeId();
+}
+
+void
+RitNwkHeader::Print(std::ostream& os) const
+{
+    os << "RitNwkHeader"
+       << " [Rank=" << m_rank
+       << ", Src=" << m_srcAddr
+       << ", Dst=" << m_dstAddr
+       << "]";
+}
+
+} // namespace lrwpan
+} // namespace ns3
diff --git a/src/rit-wpan/model/rit-wpan-nwk-header.h b/src/rit-wpan/model/rit-wpan-nwk-header.h
new file mode 100644
index 0000000..8193776
--- /dev/null
+++ b/src/rit-wpan/model/rit-wpan-nwk-header.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#ifndef RIT_NWK_HEADER_H
+#define RIT_NWK_HEADER_H
+
+#include "ns3/header.h"
+#include "ns3/mac16-address.h"
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+/**
+ * \brief Minimal network-layer header for rank-based routing.
+ *
+ * This header is used by the simplified routing logic implemented
+ * for receiver-initiated (RIT) MAC protocol evaluation.
+ */
+class RitNwkHeader : public Header
+{
+  public:
+    RitNwkHeader();
+    ~RitNwkHeader() override;
+
+    /** Set the node rank carried by this header */
+    void SetRank(uint16_t rank);
+
+    /** Get the node rank */
+    uint16_t GetRank() const;
+
+    /** Set the source MAC short address */
+    void SetSrcAddr(Mac16Address addr);
+
+    /** Get the source MAC short address */
+    Mac16Address GetSrcAddr() const;
+
+    /** Set the destination MAC short address */
+    void SetDstAddr(Mac16Address addr);
+
+    /** Get the destination MAC short address */
+    Mac16Address GetDstAddr() const;
+
+    // ns-3 Header API
+    static TypeId GetTypeId();
+    TypeId GetInstanceTypeId() const override;
+    void Serialize(Buffer::Iterator start) const override;
+    uint32_t Deserialize(Buffer::Iterator start) override;
+    uint32_t GetSerializedSize() const override;
+    void Print(std::ostream& os) const override;
+
+  private:
+    uint16_t m_rank;        //!< Node rank used for rank-based forwarding
+    Mac16Address m_srcAddr; //!< Source address (currently optional in RIT mode)
+    Mac16Address m_dstAddr; //!< Destination address
+};
+
+} // namespace lrwpan
+} // namespace ns3
+
+#endif // RIT_NWK_HEADER_H
diff --git a/src/rit-wpan/model/rit-wpan-nwk.cc b/src/rit-wpan/model/rit-wpan-nwk.cc
new file mode 100644
index 0000000..3df2018
--- /dev/null
+++ b/src/rit-wpan/model/rit-wpan-nwk.cc
@@ -0,0 +1,366 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+/*
+ * NOTE [EXPERIMENTAL / SIMPLIFIED NETWORK LAYER]:
+ *
+ * This file implements a minimal network-layer component based on
+ * rank-based routing for RIT-WPAN evaluation.
+ *
+ * The routing behavior is intentionally simplified and relies on
+ * statically assigned rank values to forward packets toward a
+ * designated root (parent) node.
+ *
+ * Design scope:
+ *  - Rank-based routing without route discovery or maintenance
+ *  - Uplink-oriented, tree-like forwarding
+ *  - Best-effort retransmission on MAC-layer failures
+ *
+ * This implementation is required to enable multi-hop evaluation,
+ * while keeping the network-layer behavior simple and deterministic
+ * to avoid masking MAC-layer effects.
+ */
+
+#include "rit-wpan-nwk.h"
+#include "rit-wpan-nwk-header.h"
+
+#include "ns3/log.h"
+#include "ns3/mac16-address.h"
+#include "ns3/packet.h"
+#include "ns3/simulator.h"
+
+#include <cstdint>
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+NS_LOG_COMPONENT_DEFINE("RitSimpleRouting");
+NS_OBJECT_ENSURE_REGISTERED(RitSimpleRouting);
+
+TypeId
+RitSimpleRouting::GetTypeId()
+{
+    static TypeId tid =
+        TypeId("ns3::RitSimpleRouting")
+            .SetParent<Object>()
+            .SetGroupName("LrWpan")
+            .AddConstructor<RitSimpleRouting>()
+            .AddTraceSource("NwkTx",
+                            "NWK layer transmit trace",
+                            MakeTraceSourceAccessor(&RitSimpleRouting::m_nwkTxTrace),
+                            "ns3::Packet::TracedCallback")
+            .AddTraceSource("NwkTxOk",
+                            "NWK layer successful transmit trace",
+                            MakeTraceSourceAccessor(&RitSimpleRouting::m_nwkTxOkTrace),
+                            "ns3::Packet::TracedCallback")
+            .AddTraceSource("NwkTxDrop",
+                            "NWK layer transmit drop trace",
+                            MakeTraceSourceAccessor(&RitSimpleRouting::m_nwkTxDropTrace),
+                            "ns3::Packet::TracedCallback")
+            .AddTraceSource("NwkRx",
+                            "NWK layer receive trace",
+                            MakeTraceSourceAccessor(&RitSimpleRouting::m_nwkRxTrace),
+                            "ns3::Packet::TracedCallback")
+            .AddTraceSource("NwkRxDrop",
+                            "NWK layer receive drop trace",
+                            MakeTraceSourceAccessor(&RitSimpleRouting::m_nwkRxDropTrace),
+                            "ns3::Packet::TracedCallback")
+            .AddTraceSource("NwkReTx",
+                            "NWK layer re-transmit packet trace",
+                            MakeTraceSourceAccessor(&RitSimpleRouting::m_nwkReTxTrace),
+                            "ns3::Packet::TracedCallback");
+    return tid;
+}
+
+RitSimpleRouting::RitSimpleRouting()
+{
+    m_txPkt = nullptr;
+    m_reTxDelay = CreateObject<UniformRandomVariable>();
+}
+
+RitSimpleRouting::~RitSimpleRouting() = default;
+
+void
+RitSimpleRouting::Bootstrap()
+{
+    // NOTE [NOT IMPLEMENTED]:
+    // Bootstrap procedures (e.g., parent discovery / rank negotiation)
+    // are intentionally omitted in this simplified implementation.
+}
+
+void
+RitSimpleRouting::McpsDataIndication(McpsDataIndicationParams params, Ptr<Packet> p)
+{
+    NS_LOG_FUNCTION_NOARGS();
+
+    RitNwkHeader nwkHdr;
+    p->RemoveHeader(nwkHdr);
+
+    NS_LOG_DEBUG("McpsDataIndication: SrcAddr=" << nwkHdr.GetSrcAddr()
+                                                << ", DstAddr=" << nwkHdr.GetDstAddr()
+                                                << ", Rank=" << nwkHdr.GetRank());
+
+    // Case 1: The packet is destined to this node.
+    if (nwkHdr.GetDstAddr() == m_shortAddr)
+    {
+        if (m_nwkRxCallback.IsNull())
+        {
+            NS_LOG_DEBUG("Packet is for me but no RX callback is set; dropping.");
+            return;
+        }
+
+        NS_LOG_DEBUG("Packet is for me; delivering to upper layer.");
+        m_nwkRxTrace(p);
+        m_nwkRxCallback(p, nwkHdr.GetSrcAddr());
+        return;
+    }
+
+    /*
+     * Case 2: Forwarding (simplified).
+     * NOTE [EXPERIMENTAL]:
+     * Current behavior: forward only if the packet rank is higher than my rank.
+     * This is used as a simplified tree-based uplink forwarding rule.
+     */
+    if (nwkHdr.GetRank() > m_rank)
+    {
+        NS_LOG_DEBUG("Forwarding packet (rank-based): DstAddr=" << nwkHdr.GetDstAddr()
+                                                                << ", MyRank=" << m_rank
+                                                                << ", PktRank=" << nwkHdr.GetRank());
+        m_nwkRxTrace(p);
+
+        // IMPORTANT: Keep forwarding behavior unchanged.
+        // (Even if a "parent" address is conceptually expected, the current logic forwards to
+        //  nwkHdr.GetDstAddr() via SendRequest, as implemented originally.)
+        SendRequest(p, nwkHdr.GetDstAddr());
+        return;
+    }
+
+    NS_LOG_DEBUG("Dropping packet (not forwarded by rank rule).");
+    m_nwkRxDropTrace(p);
+}
+
+void
+RitSimpleRouting::McpsDataConfirm(McpsDataConfirmParams params)
+{
+    NS_LOG_FUNCTION(this << (uint32_t)params.m_msduHandle << ":" << params.m_status);
+
+    const uint8_t msduHandle = params.m_msduHandle;
+
+    // Resolve NWK handle from MAC handle.
+    auto it = m_msduToNwkHandleMap.find(msduHandle);
+    if (it == m_msduToNwkHandleMap.end())
+    {
+        NS_LOG_WARN("Unknown msduHandle: " << (uint32_t)msduHandle);
+        return;
+    }
+
+    const uint8_t nwkHandle = it->second;
+
+    auto pktIt = m_handleToPktMap.find(nwkHandle);
+    if (pktIt == m_handleToPktMap.end())
+    {
+        NS_LOG_WARN("Packet not found for nwkHandle=" << (uint32_t)nwkHandle);
+        m_msduToNwkHandleMap.erase(msduHandle);
+        return;
+    }
+
+    Ptr<Packet> packet = pktIt->second.first;
+    const Mac16Address dst = pktIt->second.second;
+    const uint8_t retries = m_retryCountMap[nwkHandle];
+
+    switch (params.m_status)
+    {
+    case MacStatus::SUCCESS:
+        NS_LOG_DEBUG("Tx SUCCESS: nwkHandle=" << (uint32_t)nwkHandle);
+        m_nwkTxOkTrace(packet);
+        break;
+
+    case MacStatus::NO_ACK:
+        NS_LOG_DEBUG("Tx RETRY (" << (uint32_t)retries << "/" << (uint32_t)MAX_RETRIES
+                                  << ") nwkHandle=" << (uint32_t)nwkHandle);
+
+        if (retries < MAX_RETRIES)
+        {
+            m_retryCountMap[nwkHandle] = retries + 1;
+
+            // Keep behavior: remove header before re-adding it in SendRequest().
+            RitNwkHeader nwkHdr;
+            packet->RemoveHeader(nwkHdr);
+
+            m_nwkReTxTrace(packet);
+
+            /*
+             * NOTE [EXPERIMENTAL]:
+             * Retransmission delay is randomized with a fixed range (0..5 seconds),
+             * kept intentionally simple for evaluation.
+             */
+            const Time delay = Seconds(m_reTxDelay->GetValue(0, 5));
+
+            Simulator::Schedule(
+                delay,
+                static_cast<void (RitSimpleRouting::*)(Ptr<Packet>, Mac16Address, uint8_t)>(
+                    &RitSimpleRouting::SendRequest),
+                this,
+                packet,
+                dst,
+                nwkHandle);
+
+            // Keep original cleanup behavior.
+            m_msduToNwkHandleMap.erase(msduHandle);
+            return;
+        }
+
+        NS_LOG_DEBUG("Max retries reached; dropping packet.");
+        m_nwkTxDropTrace(packet);
+        break;
+
+    case MacStatus::CHANNEL_ACCESS_FAILURE:
+        NS_LOG_DEBUG("Tx CSMA failure: nwkHandle=" << (uint32_t)nwkHandle);
+        // fallthrough
+
+    default:
+        NS_LOG_DEBUG("Tx FAILED with status=" << params.m_status);
+        m_nwkTxDropTrace(packet);
+        break;
+    }
+
+    // Cleanup (keep behavior unchanged).
+    m_handleToPktMap.erase(nwkHandle);
+    m_retryCountMap.erase(nwkHandle);
+    m_msduToNwkHandleMap.erase(msduHandle);
+}
+
+void
+RitSimpleRouting::MlmeRitRequestIndication(MlmeRitRequestIndicationParams params)
+{
+    NS_LOG_FUNCTION(this);
+
+    Ptr<Packet> ritPayload =
+        Create<Packet>(params.m_ritRequestPayload.data(), params.m_ritRequestPayload.size());
+
+    RitNwkHeader nwkHdr;
+    ritPayload->PeekHeader(nwkHdr);
+
+    /*
+     * NOTE [EXPERIMENTAL]:
+     * This is a simplified policy to trigger MAC transmission upon receiving a
+     * RIT request from a lower-rank node.
+     */
+    if (nwkHdr.GetRank() + 1 == m_rank)
+    {
+        NS_LOG_DEBUG("Processing RIT request from lower rank: " << nwkHdr.GetRank());
+        Simulator::ScheduleNow(&RitWpanMac::SendRitData, m_mac);
+    }
+    else
+    {
+        NS_LOG_DEBUG("RIT request ignored (rank mismatch). MyRank=" << m_rank);
+    }
+}
+
+// New transmission request (allocate NWK handle internally).
+void
+RitSimpleRouting::SendRequest(Ptr<Packet> packet, Mac16Address dst)
+{
+    const uint8_t nwkHandle = m_nwkHandle.GetValue();
+    m_retryCountMap[nwkHandle] = 0;
+    SendRequest(packet, dst, nwkHandle);
+}
+
+// Retransmission / handle-specified request.
+void
+RitSimpleRouting::SendRequest(Ptr<Packet> packet, Mac16Address dst, uint8_t nwkHandle)
+{
+    NS_LOG_FUNCTION(this << packet << dst << (uint32_t)nwkHandle);
+
+    const uint8_t msduHandle = m_macHandle.GetValue();
+    m_macHandle++;
+
+    McpsDataRequestParams params;
+    params.m_srcAddrMode = AddressMode::SHORT_ADDR;
+    params.m_dstAddrMode = AddressMode::SHORT_ADDR;
+    params.m_dstAddr = dst;
+    params.m_msduHandle = msduHandle;
+    params.m_txOptions |= TX_OPTION_ACK;
+
+    // Add network header (keep fields unchanged).
+    RitNwkHeader hdr;
+    hdr.SetSrcAddr(m_shortAddr);
+    hdr.SetDstAddr(dst);
+    hdr.SetRank(m_rank);
+    packet->AddHeader(hdr);
+
+    // Trace and store a copy (keep behavior unchanged).
+    Ptr<Packet> pktCopy = packet->Copy();
+    m_nwkTxTrace(pktCopy);
+
+    // Register handle mappings (keep behavior unchanged).
+    m_handleToPktMap[nwkHandle] = std::make_pair(pktCopy, dst);
+    m_msduToNwkHandleMap[msduHandle] = nwkHandle;
+
+    m_mac->McpsDataRequest(params, packet);
+}
+
+void
+RitSimpleRouting::SetMac(Ptr<RitWpanMac> mac)
+{
+    m_mac = mac;
+}
+
+Ptr<RitWpanMac>
+RitSimpleRouting::GetMac() const
+{
+    return m_mac;
+}
+
+void
+RitSimpleRouting::SetRank(uint16_t rank)
+{
+    NS_LOG_FUNCTION(this << rank);
+    m_rank = rank;
+
+    // Build and set RIT request payload (keep behavior unchanged).
+    RitNwkHeader nwkHeader;
+    nwkHeader.SetDstAddr(Mac16Address("FF:FF"));
+    nwkHeader.SetRank(m_rank);
+
+    Ptr<Packet> ritRequestPayload = Create<Packet>(0);
+    ritRequestPayload->AddHeader(nwkHeader);
+
+    std::vector<uint8_t> payload(ritRequestPayload->GetSize());
+    ritRequestPayload->CopyData(payload.data(), payload.size());
+
+    MacPibAttributeIdentifier id = macRitRequestPayload;
+    Ptr<MacPibAttributes> attribute = Create<MacPibAttributes>();
+    attribute->macRitRequestPayload = payload;
+
+    m_mac->MlmeSetRequest(id, attribute);
+}
+
+uint16_t
+RitSimpleRouting::GetRank() const
+{
+    return m_rank;
+}
+
+void
+RitSimpleRouting::SetShortAddress(Mac16Address addr)
+{
+    m_shortAddr = addr;
+}
+
+void
+RitSimpleRouting::SetNwkRxCallback(NwkRxCallback cb)
+{
+    m_nwkRxCallback = cb;
+}
+
+} // namespace lrwpan
+} // namespace ns3
diff --git a/src/rit-wpan/model/rit-wpan-nwk.h b/src/rit-wpan/model/rit-wpan-nwk.h
new file mode 100644
index 0000000..c86ae29
--- /dev/null
+++ b/src/rit-wpan/model/rit-wpan-nwk.h
@@ -0,0 +1,182 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#ifndef RIT_WPAN_NWK_H
+#define RIT_WPAN_NWK_H
+
+#include "rit-wpan-mac.h"
+
+#include "ns3/object.h"
+#include "ns3/random-variable-stream.h"
+
+#include <cstdint>
+#include <map>
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+/**
+ * \brief Simplified rank-based routing layer for RIT-WPAN evaluation
+ *
+ * RitSimpleRouting provides a minimal network-layer functionality
+ * required to enable multi-hop communication in RIT-WPAN simulations.
+ *
+ * Packet forwarding decisions are made solely based on node rank,
+ * assuming a static tree topology rooted at a designated parent.
+ *
+ * NOTE:
+ *  - No route discovery or maintenance is implemented.
+ *  - This class is tightly coupled with the evaluation scenarios.
+ */
+class RitSimpleRouting : public Object
+{
+  public:
+    /**
+     * \brief Get the TypeId of this object
+     * \return the TypeId
+     */
+    static TypeId GetTypeId();
+
+    /**
+     * \brief Default constructor
+     */
+    RitSimpleRouting();
+
+    ~RitSimpleRouting() override;
+
+    /**
+     * \brief Bootstrap procedure (not implemented)
+     *
+     * NOTE [NOT IMPLEMENTED / OUT OF SCOPE]:
+     * Dynamic bootstrap logic is intentionally omitted in this
+     * simplified evaluation-oriented implementation.
+     */
+    void Bootstrap();
+
+    /**
+     * \brief Handle incoming RIT request indication from MAC
+     *
+     * \param params RIT request indication parameters
+     */
+    void MlmeRitRequestIndication(MlmeRitRequestIndicationParams params);
+
+    /**
+     * \brief Set the underlying MAC instance
+     * \param mac Pointer to RitWpanMac
+     */
+    void SetMac(Ptr<RitWpanMac> mac);
+
+    /**
+     * \brief Get the underlying MAC instance
+     * \return Pointer to RitWpanMac
+     */
+    Ptr<RitWpanMac> GetMac() const;
+
+    /**
+     * \brief Set the rank of this node
+     * \param rank Rank value
+     */
+    void SetRank(uint16_t rank);
+
+    /**
+     * \brief Get the rank of this node
+     * \return Rank value
+     */
+    uint16_t GetRank() const;
+
+    /**
+     * \brief Set the short MAC address of this node
+     * \param addr Short address
+     */
+    void SetShortAddress(Mac16Address addr);
+
+    /**
+     * \brief Send a packet via the network layer
+     *
+     * A new network handle is allocated internally.
+     *
+     * \param packet Packet to send
+     * \param dst Destination MAC address
+     */
+    void SendRequest(Ptr<Packet> packet, Mac16Address dst);
+
+    /**
+     * \brief Send or re-send a packet with a specified network handle
+     *
+     * \param packet Packet to send
+     * \param dst Destination MAC address
+     * \param nwkHandle Network-layer handle
+     */
+    void SendRequest(Ptr<Packet> packet, Mac16Address dst, uint8_t nwkHandle);
+
+    /**
+     * \brief Indication of received data from MAC layer
+     *
+     * \param params MCPS indication parameters
+     * \param pkt Received packet
+     */
+    void McpsDataIndication(McpsDataIndicationParams params, Ptr<Packet> pkt);
+
+    /**
+     * \brief Confirmation of transmitted data from MAC layer
+     *
+     * \param params MCPS confirm parameters
+     */
+    void McpsDataConfirm(McpsDataConfirmParams params);
+
+    /**
+     * \brief Callback type for network-layer packet reception
+     */
+    typedef Callback<void, Ptr<Packet>, const Mac16Address&> NwkRxCallback;
+
+    /**
+     * \brief Set the callback to notify upper layers of packet reception
+     * \param cb Callback function
+     */
+    void SetNwkRxCallback(NwkRxCallback cb);
+
+  private:
+    // Node attributes
+    uint16_t m_rank;            //!< Rank of this node
+    Mac16Address m_shortAddr;   //!< Short MAC address
+    Ptr<Packet> m_txPkt;        //!< Temporary pointer for transmission
+
+    // Trace sources
+    TracedCallback<Ptr<const Packet>> m_nwkTxTrace;
+    TracedCallback<Ptr<const Packet>> m_nwkTxOkTrace;
+    TracedCallback<Ptr<const Packet>> m_nwkTxDropTrace;
+    TracedCallback<Ptr<const Packet>> m_nwkRxTrace;
+    TracedCallback<Ptr<const Packet>> m_nwkRxDropTrace;
+    TracedCallback<Ptr<const Packet>> m_nwkReTxTrace;
+
+    // Upper-layer callback
+    NwkRxCallback m_nwkRxCallback;
+
+    // Underlying MAC
+    Ptr<RitWpanMac> m_mac;
+
+    // Handle and retry management
+    std::map<uint8_t, std::pair<Ptr<Packet>, Mac16Address>> m_handleToPktMap;
+    std::map<uint8_t, uint8_t> m_retryCountMap;
+    std::map<uint8_t, uint8_t> m_msduToNwkHandleMap;
+
+    SequenceNumber8 m_nwkHandle;
+    SequenceNumber8 m_macHandle;
+
+    static constexpr uint8_t MAX_RETRIES = 0;
+
+    Ptr<UniformRandomVariable> m_reTxDelay;
+};
+
+} // namespace lrwpan
+} // namespace ns3
+
+#endif // RIT_WPAN_NWK_H
diff --git a/src/rit-wpan/model/rit-wpan-precs.cc b/src/rit-wpan/model/rit-wpan-precs.cc
new file mode 100644
index 0000000..52d42e5
--- /dev/null
+++ b/src/rit-wpan/model/rit-wpan-precs.cc
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#include "rit-wpan-precs.h"
+
+#include "ns3/log.h"
+#include "ns3/simulator.h"
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+NS_LOG_COMPONENT_DEFINE("RitWpanPreCs");
+NS_OBJECT_ENSURE_REGISTERED(RitWpanPreCs);
+
+TypeId
+RitWpanPreCs::GetTypeId()
+{
+    static TypeId tid = TypeId("ns3::RitWpanPreCs")
+                            .SetParent<Object>()
+                            .SetGroupName("RitWpan")
+                            .AddConstructor<RitWpanPreCs>();
+    return tid;
+}
+
+RitWpanPreCs::RitWpanPreCs()
+{
+    NS_LOG_FUNCTION(this);
+    m_ccaRequestRunning = false;
+}
+
+RitWpanPreCs::~RitWpanPreCs()
+{
+    NS_LOG_FUNCTION(this);
+    m_mac = nullptr;
+}
+
+void
+RitWpanPreCs::DoDispose()
+{
+    NS_LOG_FUNCTION(this);
+    m_lrWpanMacStateCallback = MakeNullCallback<void, MacState>();
+    Cancel();
+    m_mac = nullptr;
+    Object::DoDispose();
+}
+
+void
+RitWpanPreCs::SetMac(Ptr<RitWpanMac> mac)
+{
+    NS_LOG_FUNCTION(this << mac);
+    m_mac = mac;
+}
+
+Ptr<RitWpanMac>
+RitWpanPreCs::GetMac() const
+{
+    NS_LOG_FUNCTION(this);
+    return m_mac;
+}
+
+void
+RitWpanPreCs::SetLrWpanMacStateCallback(LrWpanMacStateCallback lrWpanMacStatusCallback)
+{
+    NS_LOG_FUNCTION(this);
+    m_lrWpanMacStateCallback = lrWpanMacStatusCallback;
+}
+
+void
+RitWpanPreCs::SetFallbackCcaConfirmCallback(FallbackCcaConfirmCallback fallbackCcaConfirmCallback)
+{
+    NS_LOG_FUNCTION(this);
+    m_fallbackCcaConfirmCallback = fallbackCcaConfirmCallback;
+}
+
+void
+RitWpanPreCs::Start()
+{
+    NS_LOG_FUNCTION(this);
+    NS_LOG_DEBUG("Starting Pre-CS algorithm - immediate CCA request");
+
+    // Pre-CS performs immediate CCA without any backoff or delay
+    RequestCCA();
+}
+
+void
+RitWpanPreCs::Cancel()
+{
+    NS_LOG_FUNCTION(this);
+
+    if (m_ccaRequestRunning)
+    {
+        NS_LOG_DEBUG("Canceling ongoing CCA request");
+        m_mac->GetPhy()->CcaCancel();
+        m_ccaRequestRunning = false;
+    }
+}
+
+void
+RitWpanPreCs::RequestCCA()
+{
+    NS_LOG_FUNCTION(this);
+    NS_LOG_DEBUG("Requesting CCA from PHY");
+
+    m_ccaRequestRunning = true;
+    m_mac->GetPhy()->PlmeCcaRequest();
+}
+
+void
+RitWpanPreCs::PlmeCcaConfirm(PhyEnumeration status)
+{
+    NS_LOG_FUNCTION(this << status);
+
+    // Only react on this event, if we are actually waiting for a CCA.
+    // If the Pre-CS algorithm was canceled, we could still receive this event from
+    // the PHY. In this case we ignore the event.
+    if (m_ccaRequestRunning)
+    {
+        m_ccaRequestRunning = false;
+
+        if (status == IEEE_802_15_4_PHY_IDLE)
+        {
+            NS_LOG_DEBUG("Channel assessed as IDLE - notifying MAC to proceed");
+
+            // Channel is idle, notify MAC that transmission can proceed
+            if (!m_lrWpanMacStateCallback.IsNull())
+            {
+                m_lrWpanMacStateCallback(CHANNEL_IDLE);
+            }
+        }
+        else
+        {
+            NS_LOG_DEBUG("Channel assessed as BUSY - notifying MAC of access failure");
+
+            // Channel is busy, notify MAC of immediate failure
+            // No retry or backoff in Pre-CS
+            if (!m_lrWpanMacStateCallback.IsNull())
+            {
+                m_lrWpanMacStateCallback(CHANNEL_ACCESS_FAILURE);
+            }
+        }
+    }
+    else
+    {
+        NS_LOG_DEBUG("Fallback to CSMA-CA via fallback CCA confirm callback.");
+        if (!m_fallbackCcaConfirmCallback.IsNull())
+        {
+            m_fallbackCcaConfirmCallback(status);
+        }
+        else
+        {
+            NS_LOG_WARN("FallbackCcaConfirmCallback is not set  ignoring CCA confirm.");
+        }
+    }
+}
+
+} // namespace lrwpan
+} // namespace ns3
diff --git a/src/rit-wpan/model/rit-wpan-precs.h b/src/rit-wpan/model/rit-wpan-precs.h
new file mode 100644
index 0000000..eb52e83
--- /dev/null
+++ b/src/rit-wpan/model/rit-wpan-precs.h
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#ifndef RIT_WPAN_PRECS_H
+#define RIT_WPAN_PRECS_H
+
+#include "rit-wpan-mac.h"
+
+#include "ns3/event-id.h"
+#include "ns3/object.h"
+
+namespace ns3
+{
+namespace lrwpan
+{
+
+/**
+ * @ingroup lr-wpan
+ *
+ * This method informs the MAC whether the channel is idle or busy for Pre-CS.
+ */
+typedef Callback<void, MacState> LrWpanMacStateCallback;
+
+/**
+ * @ingroup lr-wpan
+ *
+ * This method implements the PD SAP: PlmeCcaConfirm
+ *
+ * @param status the status of CCA
+ */
+typedef Callback<void, PhyEnumeration> FallbackCcaConfirmCallback;
+
+/**
+ * @ingroup lr-wpan
+ *
+ * @brief Pre-CS carrier sense access control class for IEEE 802.15.4e RIT
+ *
+ * This class implements a simplified carrier sense strategy (Pre-CS),
+ * designed specifically for sending RIT Data Request frames.
+ *
+ * Characteristics:
+ *  - Only one CCA attempt (no CW, no retry)
+ *  - No backoff, no slotted operation
+ *  - If channel is busy, notify failure immediately
+ *  - If channel is idle, notify MAC to proceed transmission
+ *
+ * Intended to reduce power and delay overhead when sending lightweight control frames.
+ */
+class RitWpanPreCs : public Object
+{
+  public:
+    /**
+     * Get the type ID.
+     *
+     * @return the object TypeId
+     */
+    static TypeId GetTypeId();
+
+    /**
+     * Default constructor.
+     */
+    RitWpanPreCs();
+
+    /**
+     * Destructor.
+     */
+    ~RitWpanPreCs() override;
+
+    /**
+     * Set the MAC to which this Pre-CS implementation is attached to.
+     *
+     * @param mac the used MAC
+     */
+    void SetMac(Ptr<RitWpanMac> mac);
+
+    /**
+     * Get the MAC to which this Pre-CS implementation is attached to.
+     *
+     * @return the used MAC
+     */
+    Ptr<RitWpanMac> GetMac() const;
+
+    /**
+     * Set the callback function to the MAC. Used at the end of a Channel Assessment, as part of the
+     * interconnections between the Pre-CS and the MAC. The callback
+     * lets MAC know a channel is either idle or busy.
+     *
+     * @param macState the mac state callback
+     */
+    void SetLrWpanMacStateCallback(LrWpanMacStateCallback macState);
+
+    void SetFallbackCcaConfirmCallback(FallbackCcaConfirmCallback fallbackCcaConfirmCallback);
+
+    /**
+     * Start Pre-CS algorithm (immediate CCA request).
+     * Performs a single carrier sense attempt without backoff or retry.
+     */
+    void Start();
+
+    /**
+     * Cancel Pre-CS algorithm.
+     * Cancels any ongoing CCA request.
+     */
+    void Cancel();
+
+    /**
+     * Request the Phy to perform CCA (single attempt)
+     */
+    void RequestCCA();
+
+    /**
+     * IEEE 802.15.4-2006 section 6.2.2.2
+     * PLME-CCA.confirm status
+     * @param status TRX_OFF, BUSY or IDLE
+     *
+     * When Phy has completed CCA, it calls back here which executes the final step
+     * of the Pre-CS algorithm.
+     * It checks if the Channel is idle and immediately notifies the MAC.
+     * If channel is busy, notifies channel access failure immediately.
+     */
+    void PlmeCcaConfirm(PhyEnumeration status);
+
+  private:
+    void DoDispose() override;
+
+    /**
+     * The callback to inform the configured MAC of the Pre-CS result.
+     */
+    LrWpanMacStateCallback m_lrWpanMacStateCallback;
+
+    FallbackCcaConfirmCallback m_fallbackCcaConfirmCallback;
+
+    /**
+     * The MAC instance for which this Pre-CS implementation is configured.
+     */
+    Ptr<RitWpanMac> m_mac;
+
+    /**
+     * Flag indicating that the PHY is currently running a CCA. Used to prevent
+     * reporting the channel status to the MAC while canceling the Pre-CS algorithm.
+     */
+    bool m_ccaRequestRunning;
+};
+
+} // namespace lrwpan
+} // namespace ns3
+
+#endif /* LR_WPAN_PRECS_H */
diff --git a/src/rit-wpan/model/time-drift-applier.cc b/src/rit-wpan/model/time-drift-applier.cc
new file mode 100644
index 0000000..59947f9
--- /dev/null
+++ b/src/rit-wpan/model/time-drift-applier.cc
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#include "time-drift-applier.h"
+
+#include <ns3/double.h>
+
+namespace ns3
+{
+
+NS_LOG_COMPONENT_DEFINE("TimeDriftApplier");
+
+TimeDriftApplier::TimeDriftApplier()
+    : m_driftRatio(0.0)
+    , m_rng(CreateObject<UniformRandomVariable>())
+{
+}
+
+void
+TimeDriftApplier::SetDriftRatio(double driftRatio)
+{
+    // Validate driftRatio (0.0 to 100.0)
+    NS_ABORT_MSG_IF(driftRatio < 0.0, "driftRatio must be >= 0");
+    NS_ABORT_MSG_IF(driftRatio > 100.0, "driftRatio must be <= 100");
+    m_driftRatio = driftRatio;
+}
+
+Time
+TimeDriftApplier::ApplyByRatio(Time inputTime) const
+{
+    return ApplyByRatio(inputTime, m_driftRatio);
+}
+
+Time
+TimeDriftApplier::ApplyByRatio(Time inputTime, double driftRatio) const
+{
+    // Validate driftRatio (0.0 to 100.0)
+    NS_ABORT_MSG_IF(driftRatio < 0.0, "driftRatio must be >= 0");
+    NS_ABORT_MSG_IF(driftRatio > 100.0, "driftRatio must be <= 100");
+
+    double inputTimeMs = inputTime.GetMilliSeconds();
+    double minDrift = -inputTimeMs * driftRatio / 100.0;
+    double maxDrift = inputTimeMs * driftRatio / 100.0;
+
+    m_rng->SetAttribute("Min", DoubleValue(minDrift));
+    m_rng->SetAttribute("Max", DoubleValue(maxDrift));
+    double randomDelay = m_rng->GetValue();
+    Time randomizedTime = inputTime + MilliSeconds(randomDelay);
+
+    NS_LOG_DEBUG("Input Time: " << inputTime.GetMilliSeconds()
+                                << "ms, Random Delay: " << randomDelay
+                                << "ms, Output Time: " << randomizedTime.GetMilliSeconds() << "ms");
+    return randomizedTime;
+}
+
+} // namespace ns3
diff --git a/src/rit-wpan/model/time-drift-applier.h b/src/rit-wpan/model/time-drift-applier.h
new file mode 100644
index 0000000..a2ec9d7
--- /dev/null
+++ b/src/rit-wpan/model/time-drift-applier.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ *
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#ifndef TIME_DRIFT_APPLIER_H
+#define TIME_DRIFT_APPLIER_H
+
+#include <ns3/log.h>
+#include <ns3/nstime.h>
+#include <ns3/object.h>
+#include <ns3/random-variable-stream.h>
+
+namespace ns3
+{
+
+class TimeDriftApplier : public Object
+{
+  public:
+    TimeDriftApplier();
+    void SetDriftRatio(double driftRatio);
+    Time ApplyByRatio(Time inputTime) const;
+    Time ApplyByRatio(Time inputTime, double driftRatio) const;
+
+  private:
+    double m_driftRatio; // percent (e.g. 10.0 means 10%)
+    Ptr<UniformRandomVariable> m_rng;
+};
+
+} // namespace ns3
+
+#endif // TIME_DRIFT_APPLIER_H
diff --git a/src/rit-wpan/test/periodic-sender-test.cc b/src/rit-wpan/test/periodic-sender-test.cc
new file mode 100644
index 0000000..8e381a4
--- /dev/null
+++ b/src/rit-wpan/test/periodic-sender-test.cc
@@ -0,0 +1,159 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#include "ns3/applications-module.h"
+#include "ns3/core-module.h"
+#include "ns3/internet-module.h"
+#include "ns3/lr-wpan-module.h"
+#include "ns3/lr-wpan-net-device.h"
+#include "ns3/mobility-helper.h"
+#include "ns3/network-module.h"
+#include "ns3/periodic-sender-helper.h"
+#include "ns3/periodic-sender.h"
+#include "ns3/test.h"
+
+using namespace ns3;
+using namespace ns3::lrwpan;
+
+NS_LOG_COMPONENT_DEFINE("periodic-sender-test");
+
+/**
+ * @brief Test case for the PeriodicSender application and LrWpan functionality.
+ *
+ * This test verifies the following aspects:
+ *  - Periodic packet transmission at a fixed interval
+ *  - Correct packet reception via LrWpanNetDevice
+ *  - Correct handling of packet size, timing, and transmission count
+ */
+class PeriodicSenderTRxTestCase : public TestCase
+{
+  public:
+    PeriodicSenderTRxTestCase();
+    virtual ~PeriodicSenderTRxTestCase();
+
+  private:
+    void DoRun() override;
+    bool ReceivePacket(Ptr<NetDevice> device,
+                       Ptr<const Packet> packet,
+                       uint16_t protocol,
+                       const Address& sender);
+
+    static constexpr uint8_t TEST_PKT_SIZE = 8;
+    static constexpr double TEST_INTERVAL = 1.0;
+    uint8_t m_receivedPktCount;
+    std::vector<uint8_t> m_receivedPktSizes;
+    std::vector<Time> m_receivedPktTimestamps;
+};
+
+PeriodicSenderTRxTestCase::PeriodicSenderTRxTestCase()
+    : TestCase("Verification of the periodic sender application and LrWpan functionality"),
+      m_receivedPktCount(0)
+{
+}
+
+PeriodicSenderTRxTestCase::~PeriodicSenderTRxTestCase()
+{
+}
+
+bool
+PeriodicSenderTRxTestCase::ReceivePacket(Ptr<NetDevice> device,
+                                         Ptr<const Packet> packet,
+                                         uint16_t protocol,
+                                         const Address& sender)
+{
+    NS_LOG_UNCOND("Packet received by node.");
+    m_receivedPktCount++;
+    m_receivedPktSizes.push_back(packet->GetSize());
+    m_receivedPktTimestamps.push_back(Simulator::Now());
+    return true;
+}
+
+void
+PeriodicSenderTRxTestCase::DoRun()
+{
+    // Configure logging for debugging
+    LogComponentEnable("PeriodicSender", LOG_LEVEL_DEBUG);
+    LogComponentEnable("LrWpanNetDevice", LOG_LEVEL_DEBUG);
+    LogComponentEnable("periodic-sender-test", LOG_LEVEL_ALL);
+
+    // 1. Create nodes
+    NodeContainer nodes;
+    nodes.Create(2);
+
+    // 2. Install LrWpanNetDevice on nodes
+    LrWpanHelper lrWpanHelper;
+    NetDeviceContainer devices = lrWpanHelper.Install(nodes);
+
+    // 3. Configure node positions to ensure connectivity
+    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();
+    positionAlloc->Add(Vector(0.0, 0.0, 0.0)); // Node 0
+    positionAlloc->Add(Vector(1.0, 0.0, 0.0)); // Node 1 (placed nearby)
+
+    MobilityHelper mobility;
+    mobility.SetPositionAllocator(positionAlloc);
+    mobility.SetMobilityModel("ns3::ConstantPositionMobilityModel");
+    mobility.Install(nodes);
+
+    // 4. Set MAC short addresses
+    Ptr<LrWpanNetDevice> lrWpanDevice0 = DynamicCast<LrWpanNetDevice>(devices.Get(0));
+    Ptr<LrWpanNetDevice> lrWpanDevice1 = DynamicCast<LrWpanNetDevice>(devices.Get(1));
+    lrWpanDevice0->GetMac()->SetShortAddress(Mac16Address("00:00"));
+    lrWpanDevice1->GetMac()->SetShortAddress(Mac16Address("00:01"));
+
+    // 5. Register receive callback on the receiver device
+    lrWpanDevice0->SetReceiveCallback(
+        MakeCallback(&PeriodicSenderTRxTestCase::ReceivePacket, this));
+
+    // 6. [Sender side] Configure PeriodicSender application
+    Ptr<PeriodicSender> senderApp = CreateObject<PeriodicSender>();
+    senderApp->SetNode(nodes.Get(1));
+    senderApp->SetDstAddr(Mac16Address("00:00"));
+    senderApp->SetPacketSize(TEST_PKT_SIZE);
+    senderApp->SetInterval(Seconds(TEST_INTERVAL));
+    senderApp->SetInitialDelay(Seconds(1.0));
+
+    nodes.Get(1)->AddApplication(senderApp);
+    senderApp->SetStartTime(Seconds(2.0));
+    senderApp->SetStopTime(Seconds(10.1));
+
+    // 7. Run simulation
+    Simulator::Run();
+
+    // 8. Verify that 8 packets are received
+    //    (from 2.0s to 10.1s, transmitted every 1 second)
+    NS_TEST_ASSERT_MSG_EQ(m_receivedPktCount, 8, "The number of received packets is incorrect.");
+
+    // Verify packet sizes
+    for (size_t i = 0; i < m_receivedPktSizes.size(); i++)
+    {
+        NS_TEST_ASSERT_MSG_EQ(m_receivedPktSizes[i],
+                              TEST_PKT_SIZE,
+                              "The packet size is incorrect for packet " << i + 1);
+    }
+
+    // Verify transmission interval
+    for (size_t i = 1; i < m_receivedPktTimestamps.size(); i++)
+    {
+        Time interval = m_receivedPktTimestamps[i] - m_receivedPktTimestamps[i - 1];
+        NS_TEST_ASSERT_MSG_EQ_TOL(
+            interval.GetSeconds(),
+            TEST_INTERVAL,
+            0.01,
+            "Packet " << i + 1 << " interval is incorrect. Expected interval: " << TEST_INTERVAL
+                      << " seconds, but got: " << interval.GetSeconds() << " seconds.");
+    }
+
+    // Verify sender-side transmission count
+    uint32_t sentPackets = senderApp->GetSentPackets();
+    NS_TEST_ASSERT_MSG_EQ(
+        sentPackets,
+        8,
+        "The number of sent packets is incorrect. Expected: 8, but got: " << sentPackets);
+
+    Simulator::Destroy();
+}
diff --git a/src/rit-wpan/test/rit-wpan-trx-test.cc b/src/rit-wpan/test/rit-wpan-trx-test.cc
new file mode 100644
index 0000000..3111c50
--- /dev/null
+++ b/src/rit-wpan/test/rit-wpan-trx-test.cc
@@ -0,0 +1,160 @@
+/*
+ * Copyright (c) 2025 Kanazawa Institute of Technology, Japan
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Authors:
+ *  Tomoya Murata <c1039548@st.kanazawa-it.ac.jp>
+ */
+
+#include "ns3/make-event.h"
+#include <ns3/core-module.h>
+#include <ns3/log.h>
+#include <ns3/lr-wpan-module.h>
+#include <ns3/mobility-module.h>
+#include <ns3/network-module.h>
+#include <ns3/packet.h>
+#include <ns3/propagation-delay-model.h>
+#include <ns3/propagation-loss-model.h>
+#include <ns3/rit-wpan-mac.h>
+#include <ns3/rit-wpan-net-device.h>
+#include <ns3/rit-wpan-nwk-header.h>
+#include <ns3/rit-wpan-precs.h>
+#include <ns3/single-model-spectrum-channel.h>
+
+using namespace ns3;
+using namespace ns3::lrwpan;
+
+NS_LOG_COMPONENT_DEFINE("rit-wpan-mac-trx-test");
+
+class RitWpanMacTrxTest : public TestCase
+{
+  public:
+    RitWpanMacTrxTest();
+    ~RitWpanMacTrxTest() override;
+
+  private:
+    bool DataIndication(Ptr<NetDevice> dev,
+                        Ptr<const Packet> pkt,
+                        uint16_t proto,
+                        const Address& addr);
+    void DoRun() override;
+
+    std::vector<uint32_t> expectedSizes = {30, 60, 90};
+    int receivedPacketIndex = 0;
+    int receivedCount = 0;
+};
+
+RitWpanMacTrxTest::RitWpanMacTrxTest()
+    : TestCase("RitWpanMac two-node three-transmission send/receive test (RIT)")
+{
+}
+
+RitWpanMacTrxTest::~RitWpanMacTrxTest()
+{
+}
+
+bool
+RitWpanMacTrxTest::DataIndication(Ptr<NetDevice> dev,
+                                  Ptr<const Packet> pkt,
+                                  uint16_t proto,
+                                  const Address& addr)
+{
+    NS_LOG_UNCOND("Received packet size: " << pkt->GetSize());
+    receivedPacketIndex++;
+    receivedCount++;
+
+    return true;
+}
+
+void
+RitWpanMacTrxTest::DoRun()
+{
+    // Enable logging for debug
+    LogComponentEnableAll(LOG_PREFIX_TIME);
+    LogComponentEnable("rit-wpan-mac-trx-test", LOG_LEVEL_DEBUG);
+
+    // 1. Create nodes
+    Ptr<Node> receiverNode = CreateObject<Node>();
+    Ptr<Node> senderNode = CreateObject<Node>();
+
+    // 2. Create NetDevices
+    Ptr<RitWpanNetDevice> receiverDevice = CreateObject<RitWpanNetDevice>();
+    Ptr<RitWpanNetDevice> senderDevice = CreateObject<RitWpanNetDevice>();
+
+    // 3. Create and set up channel
+    Ptr<SingleModelSpectrumChannel> channel = CreateObject<SingleModelSpectrumChannel>();
+    Ptr<LogDistancePropagationLossModel> propModel =
+        CreateObject<LogDistancePropagationLossModel>();
+    Ptr<ConstantSpeedPropagationDelayModel> delayModel =
+        CreateObject<ConstantSpeedPropagationDelayModel>();
+    channel->AddPropagationLossModel(propModel);
+    channel->SetPropagationDelayModel(delayModel);
+    receiverDevice->SetChannel(channel);
+    senderDevice->SetChannel(channel);
+
+    // 4. Set addresses
+    receiverDevice->SetAddress(Mac16Address("00:00"));
+    receiverDevice->SetRitRank(0);
+    senderDevice->SetAddress(Mac16Address("00:01"));
+    senderDevice->SetRitRank(1);
+
+    // 5. Register devices to nodes
+    receiverNode->AddDevice(receiverDevice);
+    senderNode->AddDevice(senderDevice);
+
+    // 6. Mobility setting (optional)
+
+    // 7. Set receive callback
+    receiverDevice->SetReceiveCallback(MakeCallback(&RitWpanMacTrxTest::DataIndication, this));
+
+    // 8. RIT period setting
+    Ptr<MacPibAttributes> pibAttr = Create<MacPibAttributes>();
+    pibAttr->macRitPeriodTime = Time(Seconds(1)); // About 1 second period
+    MacPibAttributeIdentifier id = macRitPeriodTime;
+    senderDevice->GetMac()->MlmeSetRequest(id, pibAttr);
+    receiverDevice->GetMac()->MlmeSetRequest(id, pibAttr);
+
+    // 9. Create transmission packets
+    Ptr<Packet> packet1 = Create<Packet>(30);
+    Ptr<Packet> packet2 = Create<Packet>(60);
+    Ptr<Packet> packet3 = Create<Packet>(90);
+
+    // 10. Transmission scheduling
+    Simulator::ScheduleWithContext(senderNode->GetId(), Seconds(8.0), [=]() {
+        senderDevice->Send(packet1, Mac16Address("00:00"), 0);
+    });
+
+    Simulator::ScheduleWithContext(senderNode->GetId(), Seconds(12.0), [=]() {
+        senderDevice->Send(packet2, Mac16Address("00:00"), 0);
+    });
+
+    Simulator::ScheduleWithContext(senderNode->GetId(), Seconds(16.0), [=]() {
+        senderDevice->Send(packet3, Mac16Address("00:00"), 0);
+    });
+
+    // 12. Start and stop simulation
+    Simulator::Stop(Seconds(20.0));
+    Simulator::Run();
+
+    // 13. Check that the number of received packets is 3
+    NS_TEST_ASSERT_MSG_EQ(
+        receivedCount,
+        3,
+        "The number of received packets is not 3, actual receivedCount: " << receivedCount);
+
+    Simulator::Destroy();
+}
+
+class RitWpanMacTestSuite : public TestSuite
+{
+  public:
+    RitWpanMacTestSuite();
+};
+
+RitWpanMacTestSuite::RitWpanMacTestSuite()
+    : TestSuite("rit-wpan-mac-trx-test", Type::UNIT)
+{
+    AddTestCase(new RitWpanMacTrxTest, Duration::QUICK);
+}
+
+static RitWpanMacTestSuite g_ritWpanMacTestSuite;
-- 
2.51.0

